// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

use crate::Result;
#[allow(unused_imports)]
use gax::error::Error;

/// Implements [CatalogService](super::stub::CatalogService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct CatalogService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for CatalogService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("CatalogService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl CatalogService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::CatalogService for CatalogService {
    async fn create_entry_type(
        &self,
        req: crate::model::CreateEntryTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/entryTypes",
                    composable_matches(
                        Some(&req).map(|m| &m.parent)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("entryTypeId", &req.entry_type_id)]);
        let builder = builder.query(&[("validateOnly", &req.validate_only)]);

        self.inner
            .execute(builder, Some(req.entry_type), options)
            .await
    }

    async fn update_entry_type(
        &self,
        req: crate::model::UpdateEntryTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req)
                            .and_then(|m| m.entry_type.as_ref())
                            .map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req)
                            .and_then(|m| m.entry_type.as_ref())
                            .map(|m| &m.name),
                        "entry_type.name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryTypes/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::PATCH, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });
        let builder = builder.query(&[("validateOnly", &req.validate_only)]);

        self.inner
            .execute(builder, Some(req.entry_type), options)
            .await
    }

    async fn delete_entry_type(
        &self,
        req: crate::model::DeleteEntryTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryTypes/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("etag", &req.etag)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_entry_types(
        &self,
        req: crate::model::ListEntryTypesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListEntryTypesResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/entryTypes",
                    composable_matches(
                        Some(&req).map(|m| &m.parent)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("orderBy", &req.order_by)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_entry_type(
        &self,
        req: crate::model::GetEntryTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::EntryType>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryTypes/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn create_aspect_type(
        &self,
        req: crate::model::CreateAspectTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/aspectTypes",
                    composable_matches(
                        Some(&req).map(|m| &m.parent)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("aspectTypeId", &req.aspect_type_id)]);
        let builder = builder.query(&[("validateOnly", &req.validate_only)]);

        self.inner
            .execute(builder, Some(req.aspect_type), options)
            .await
    }

    async fn update_aspect_type(
        &self,
        req: crate::model::UpdateAspectTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req)
                            .and_then(|m| m.aspect_type.as_ref())
                            .map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/aspectTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req)
                            .and_then(|m| m.aspect_type.as_ref())
                            .map(|m| &m.name),
                        "aspect_type.name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/aspectTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/aspectTypes/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::PATCH, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });
        let builder = builder.query(&[("validateOnly", &req.validate_only)]);

        self.inner
            .execute(builder, Some(req.aspect_type), options)
            .await
    }

    async fn delete_aspect_type(
        &self,
        req: crate::model::DeleteAspectTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/aspectTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/aspectTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/aspectTypes/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("etag", &req.etag)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_aspect_types(
        &self,
        req: crate::model::ListAspectTypesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListAspectTypesResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/aspectTypes",
                    composable_matches(
                        Some(&req).map(|m| &m.parent)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("orderBy", &req.order_by)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_aspect_type(
        &self,
        req: crate::model::GetAspectTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AspectType>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/aspectTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/aspectTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/aspectTypes/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn create_entry_group(
        &self,
        req: crate::model::CreateEntryGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/entryGroups",
                    composable_matches(
                        Some(&req).map(|m| &m.parent)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("entryGroupId", &req.entry_group_id)]);
        let builder = builder.query(&[("validateOnly", &req.validate_only)]);

        self.inner
            .execute(builder, Some(req.entry_group), options)
            .await
    }

    async fn update_entry_group(
        &self,
        req: crate::model::UpdateEntryGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req)
                            .and_then(|m| m.entry_group.as_ref())
                            .map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req)
                            .and_then(|m| m.entry_group.as_ref())
                            .map(|m| &m.name),
                        "entry_group.name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryGroups/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::PATCH, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });
        let builder = builder.query(&[("validateOnly", &req.validate_only)]);

        self.inner
            .execute(builder, Some(req.entry_group), options)
            .await
    }

    async fn delete_entry_group(
        &self,
        req: crate::model::DeleteEntryGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryGroups/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("etag", &req.etag)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_entry_groups(
        &self,
        req: crate::model::ListEntryGroupsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListEntryGroupsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/entryGroups",
                    composable_matches(
                        Some(&req).map(|m| &m.parent)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("orderBy", &req.order_by)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_entry_group(
        &self,
        req: crate::model::GetEntryGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::EntryGroup>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryGroups/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn create_entry(
        &self,
        req: crate::model::CreateEntryRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Entry>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/entries",
                    composable_matches(
                        Some(&req).map(|m| &m.parent)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryGroups/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("entryId", &req.entry_id)]);

        self.inner.execute(builder, Some(req.entry), options).await
    }

    async fn update_entry(
        &self,
        req: crate::model::UpdateEntryRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Entry>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).and_then(|m| m.entry.as_ref()).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entries/"),
                            Segment::MultiWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).and_then(|m| m.entry.as_ref()).map(|m| &m.name),
                        "entry.name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entries/"),
                            Segment::MultiWildcard,
                        ],
                        "projects/*/locations/*/entryGroups/*/entries/**",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::PATCH, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });
        let builder = builder.query(&[("allowMissing", &req.allow_missing)]);
        let builder = builder.query(&[("deleteMissingAspects", &req.delete_missing_aspects)]);
        let builder = req
            .aspect_keys
            .iter()
            .fold(builder, |builder, p| builder.query(&[("aspectKeys", p)]));

        self.inner.execute(builder, Some(req.entry), options).await
    }

    async fn delete_entry(
        &self,
        req: crate::model::DeleteEntryRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Entry>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entries/"),
                            Segment::MultiWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entries/"),
                            Segment::MultiWildcard,
                        ],
                        "projects/*/locations/*/entryGroups/*/entries/**",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_entries(
        &self,
        req: crate::model::ListEntriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListEntriesResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/entries",
                    composable_matches(
                        Some(&req).map(|m| &m.parent)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryGroups/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        let builder = builder.query(&[("filter", &req.filter)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_entry(
        &self,
        req: crate::model::GetEntryRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Entry>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entries/"),
                            Segment::MultiWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entries/"),
                            Segment::MultiWildcard,
                        ],
                        "projects/*/locations/*/entryGroups/*/entries/**",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("view", &req.view)]);
        let builder = req
            .aspect_types
            .iter()
            .fold(builder, |builder, p| builder.query(&[("aspectTypes", p)]));
        let builder = req
            .paths
            .iter()
            .fold(builder, |builder, p| builder.query(&[("paths", p)]));

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn lookup_entry(
        &self,
        req: crate::model::LookupEntryRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Entry>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}:lookupEntry",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("view", &req.view)]);
        let builder = req
            .aspect_types
            .iter()
            .fold(builder, |builder, p| builder.query(&[("aspectTypes", p)]));
        let builder = req
            .paths
            .iter()
            .fold(builder, |builder, p| builder.query(&[("paths", p)]));
        let builder = builder.query(&[("entry", &req.entry)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn search_entries(
        &self,
        req: crate::model::SearchEntriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SearchEntriesResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}:searchEntries",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("query", &req.query)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        let builder = builder.query(&[("orderBy", &req.order_by)]);
        let builder = builder.query(&[("scope", &req.scope)]);

        self.inner
            .execute(builder, Some(gaxi::http::NoBody), options)
            .await
    }

    async fn create_metadata_job(
        &self,
        req: crate::model::CreateMetadataJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/metadataJobs",
                    composable_matches(
                        Some(&req).map(|m| &m.parent)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("metadataJobId", &req.metadata_job_id)]);
        let builder = builder.query(&[("validateOnly", &req.validate_only)]);

        self.inner
            .execute(builder, Some(req.metadata_job), options)
            .await
    }

    async fn get_metadata_job(
        &self,
        req: crate::model::GetMetadataJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::MetadataJob>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/metadataJobs/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/metadataJobs/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/metadataJobs/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_metadata_jobs(
        &self,
        req: crate::model::ListMetadataJobsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListMetadataJobsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/metadataJobs",
                    composable_matches(
                        Some(&req).map(|m| &m.parent)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("orderBy", &req.order_by)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn cancel_metadata_job(
        &self,
        req: crate::model::CancelMetadataJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}:cancel",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/metadataJobs/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/metadataJobs/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/metadataJobs/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await.map(
            |r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            },
        )
    }

    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/locations",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[Segment::Literal("projects/"), Segment::SingleWildcard,]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[Segment::Literal("projects/"), Segment::SingleWildcard],
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/assets/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/environments/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/attributes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataAttributeBindings/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryLinkTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/aspectTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/governanceRules/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/categories/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/terms/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/encryptionConfigs/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/assets/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*/assets/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/tasks/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/environments/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/environments/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataScans/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataTaxonomies/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/attributes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataTaxonomies/*/attributes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataAttributeBindings/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataAttributeBindings/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryLinkTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryLinkTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/aspectTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/aspectTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryGroups/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/governanceRules/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/governanceRules/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/categories/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*/categories/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/terms/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*/terms/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/encryptionConfigs/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/encryptionConfigs/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/assets/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/environments/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/attributes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataAttributeBindings/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryLinkTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/aspectTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/governanceRules/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/categories/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/terms/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/encryptionConfigs/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/assets/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*/assets/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/tasks/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/environments/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/environments/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataScans/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataTaxonomies/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/attributes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataTaxonomies/*/attributes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataAttributeBindings/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataAttributeBindings/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryLinkTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryLinkTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/aspectTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/aspectTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryGroups/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/governanceRules/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/governanceRules/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/categories/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*/categories/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/terms/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*/terms/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/encryptionConfigs/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/encryptionConfigs/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .options
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "options")
            });

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/assets/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/environments/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/attributes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataAttributeBindings/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryLinkTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/aspectTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/governanceRules/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/categories/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/terms/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/encryptionConfigs/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/assets/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*/assets/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/tasks/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/environments/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/environments/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataScans/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataTaxonomies/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/attributes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataTaxonomies/*/attributes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataAttributeBindings/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataAttributeBindings/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryLinkTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryLinkTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/aspectTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/aspectTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryGroups/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/governanceRules/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/governanceRules/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/categories/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*/categories/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/terms/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*/terms/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/encryptionConfigs/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/encryptionConfigs/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/operations",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}:cancel",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:cancel",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await.map(
            |r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            },
        )
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [CmekService](super::stub::CmekService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct CmekService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for CmekService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("CmekService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl CmekService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::CmekService for CmekService {
    async fn create_encryption_config(
        &self,
        req: crate::model::CreateEncryptionConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/encryptionConfigs",
                    composable_matches(
                        Some(&req).map(|m| &m.parent)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("encryptionConfigId", &req.encryption_config_id)]);

        self.inner
            .execute(builder, Some(req.encryption_config), options)
            .await
    }

    async fn update_encryption_config(
        &self,
        req: crate::model::UpdateEncryptionConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req)
                            .and_then(|m| m.encryption_config.as_ref())
                            .map(|m| &m.name)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/encryptionConfigs/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req)
                            .and_then(|m| m.encryption_config.as_ref())
                            .map(|m| &m.name),
                        "encryption_config.name",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/encryptionConfigs/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/encryptionConfigs/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::PATCH, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });

        self.inner
            .execute(builder, Some(req.encryption_config), options)
            .await
    }

    async fn delete_encryption_config(
        &self,
        req: crate::model::DeleteEncryptionConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/encryptionConfigs/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/encryptionConfigs/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/encryptionConfigs/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("etag", &req.etag)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_encryption_configs(
        &self,
        req: crate::model::ListEncryptionConfigsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListEncryptionConfigsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/encryptionConfigs",
                    composable_matches(
                        Some(&req).map(|m| &m.parent)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("orderBy", &req.order_by)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_encryption_config(
        &self,
        req: crate::model::GetEncryptionConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::EncryptionConfig>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/encryptionConfigs/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/encryptionConfigs/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/encryptionConfigs/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/locations",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[Segment::Literal("projects/"), Segment::SingleWildcard,]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[Segment::Literal("projects/"), Segment::SingleWildcard],
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/assets/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/environments/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/attributes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataAttributeBindings/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryLinkTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/aspectTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/governanceRules/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/categories/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/terms/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/encryptionConfigs/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/assets/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*/assets/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/tasks/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/environments/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/environments/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataScans/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataTaxonomies/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/attributes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataTaxonomies/*/attributes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataAttributeBindings/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataAttributeBindings/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryLinkTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryLinkTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/aspectTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/aspectTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryGroups/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/governanceRules/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/governanceRules/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/categories/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*/categories/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/terms/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*/terms/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/encryptionConfigs/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/encryptionConfigs/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/assets/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/environments/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/attributes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataAttributeBindings/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryLinkTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/aspectTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/governanceRules/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/categories/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/terms/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/encryptionConfigs/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/assets/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*/assets/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/tasks/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/environments/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/environments/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataScans/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataTaxonomies/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/attributes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataTaxonomies/*/attributes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataAttributeBindings/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataAttributeBindings/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryLinkTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryLinkTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/aspectTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/aspectTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryGroups/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/governanceRules/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/governanceRules/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/categories/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*/categories/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/terms/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*/terms/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/encryptionConfigs/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/encryptionConfigs/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .options
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "options")
            });

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/assets/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/environments/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/attributes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataAttributeBindings/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryLinkTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/aspectTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/governanceRules/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/categories/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/terms/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/encryptionConfigs/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/assets/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*/assets/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/tasks/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/environments/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/environments/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataScans/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataTaxonomies/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/attributes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataTaxonomies/*/attributes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataAttributeBindings/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataAttributeBindings/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryLinkTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryLinkTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/aspectTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/aspectTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryGroups/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/governanceRules/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/governanceRules/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/categories/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*/categories/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/terms/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*/terms/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/encryptionConfigs/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/encryptionConfigs/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/operations",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}:cancel",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:cancel",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await.map(
            |r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            },
        )
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [ContentService](super::stub::ContentService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct ContentService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for ContentService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("ContentService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl ContentService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::ContentService for ContentService {
    async fn create_content(
        &self,
        req: crate::model::CreateContentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Content>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/contentitems",
                    composable_matches(
                        Some(&req).map(|m| &m.parent)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}/content",
                    composable_matches(
                        Some(&req).map(|m| &m.parent)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("validateOnly", &req.validate_only)]);

        self.inner
            .execute(builder, Some(req.content), options)
            .await
    }

    async fn update_content(
        &self,
        req: crate::model::UpdateContentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Content>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req)
                            .and_then(|m| m.content.as_ref())
                            .map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/contentitems/"),
                            Segment::MultiWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req)
                            .and_then(|m| m.content.as_ref())
                            .map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/content/"),
                            Segment::MultiWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).and_then(|m| m.content.as_ref()).map(|m| &m.name),
                        "content.name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/contentitems/"),
                            Segment::MultiWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/contentitems/**",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).and_then(|m| m.content.as_ref()).map(|m| &m.name),
                        "content.name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/content/"),
                            Segment::MultiWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/content/**",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::PATCH, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });
        let builder = builder.query(&[("validateOnly", &req.validate_only)]);

        self.inner
            .execute(builder, Some(req.content), options)
            .await
    }

    async fn delete_content(
        &self,
        req: crate::model::DeleteContentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/contentitems/"),
                            Segment::MultiWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/content/"),
                            Segment::MultiWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/contentitems/"),
                            Segment::MultiWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/contentitems/**",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/content/"),
                            Segment::MultiWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/content/**",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn get_content(
        &self,
        req: crate::model::GetContentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Content>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/contentitems/"),
                            Segment::MultiWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/content/"),
                            Segment::MultiWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/contentitems/"),
                            Segment::MultiWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/contentitems/**",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/content/"),
                            Segment::MultiWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/content/**",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("view", &req.view)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/contentitems/"),
                            Segment::MultiWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/content/"),
                            Segment::MultiWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/contentitems/"),
                            Segment::MultiWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/contentitems/**",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/content/"),
                            Segment::MultiWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/content/**",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .options
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "options")
            });

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/contentitems/"),
                            Segment::MultiWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/content/"),
                            Segment::MultiWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/contentitems/"),
                            Segment::MultiWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/contentitems/**",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/content/"),
                            Segment::MultiWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/content/**",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/contentitems/"),
                            Segment::MultiWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/content/"),
                            Segment::MultiWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/contentitems/"),
                            Segment::MultiWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/contentitems/**",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/content/"),
                            Segment::MultiWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/content/**",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn list_content(
        &self,
        req: crate::model::ListContentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListContentResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/contentitems",
                    composable_matches(
                        Some(&req).map(|m| &m.parent)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}/content",
                    composable_matches(
                        Some(&req).map(|m| &m.parent)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        let builder = builder.query(&[("filter", &req.filter)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/locations",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[Segment::Literal("projects/"), Segment::SingleWildcard,]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[Segment::Literal("projects/"), Segment::SingleWildcard],
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/operations",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}:cancel",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:cancel",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await.map(
            |r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            },
        )
    }
}

/// Implements [DataTaxonomyService](super::stub::DataTaxonomyService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct DataTaxonomyService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for DataTaxonomyService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("DataTaxonomyService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl DataTaxonomyService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::DataTaxonomyService for DataTaxonomyService {
    async fn create_data_taxonomy(
        &self,
        req: crate::model::CreateDataTaxonomyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/dataTaxonomies",
                    composable_matches(
                        Some(&req).map(|m| &m.parent)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("dataTaxonomyId", &req.data_taxonomy_id)]);
        let builder = builder.query(&[("validateOnly", &req.validate_only)]);

        self.inner
            .execute(builder, Some(req.data_taxonomy), options)
            .await
    }

    async fn update_data_taxonomy(
        &self,
        req: crate::model::UpdateDataTaxonomyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req)
                            .and_then(|m| m.data_taxonomy.as_ref())
                            .map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req)
                            .and_then(|m| m.data_taxonomy.as_ref())
                            .map(|m| &m.name),
                        "data_taxonomy.name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataTaxonomies/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::PATCH, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });
        let builder = builder.query(&[("validateOnly", &req.validate_only)]);

        self.inner
            .execute(builder, Some(req.data_taxonomy), options)
            .await
    }

    async fn delete_data_taxonomy(
        &self,
        req: crate::model::DeleteDataTaxonomyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataTaxonomies/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("etag", &req.etag)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_data_taxonomies(
        &self,
        req: crate::model::ListDataTaxonomiesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListDataTaxonomiesResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/dataTaxonomies",
                    composable_matches(
                        Some(&req).map(|m| &m.parent)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("orderBy", &req.order_by)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_data_taxonomy(
        &self,
        req: crate::model::GetDataTaxonomyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DataTaxonomy>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataTaxonomies/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn create_data_attribute_binding(
        &self,
        req: crate::model::CreateDataAttributeBindingRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/dataAttributeBindings",
                    composable_matches(
                        Some(&req).map(|m| &m.parent)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("dataAttributeBindingId", &req.data_attribute_binding_id)]);
        let builder = builder.query(&[("validateOnly", &req.validate_only)]);

        self.inner
            .execute(builder, Some(req.data_attribute_binding), options)
            .await
    }

    async fn update_data_attribute_binding(
        &self,
        req: crate::model::UpdateDataAttributeBindingRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req)
                            .and_then(|m| m.data_attribute_binding.as_ref())
                            .map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataAttributeBindings/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req)
                            .and_then(|m| m.data_attribute_binding.as_ref())
                            .map(|m| &m.name),
                        "data_attribute_binding.name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataAttributeBindings/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataAttributeBindings/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::PATCH, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });
        let builder = builder.query(&[("validateOnly", &req.validate_only)]);

        self.inner
            .execute(builder, Some(req.data_attribute_binding), options)
            .await
    }

    async fn delete_data_attribute_binding(
        &self,
        req: crate::model::DeleteDataAttributeBindingRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataAttributeBindings/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataAttributeBindings/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataAttributeBindings/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("etag", &req.etag)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_data_attribute_bindings(
        &self,
        req: crate::model::ListDataAttributeBindingsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListDataAttributeBindingsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/dataAttributeBindings",
                    composable_matches(
                        Some(&req).map(|m| &m.parent)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("orderBy", &req.order_by)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_data_attribute_binding(
        &self,
        req: crate::model::GetDataAttributeBindingRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DataAttributeBinding>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataAttributeBindings/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataAttributeBindings/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataAttributeBindings/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn create_data_attribute(
        &self,
        req: crate::model::CreateDataAttributeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/attributes",
                    composable_matches(
                        Some(&req).map(|m| &m.parent)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataTaxonomies/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("dataAttributeId", &req.data_attribute_id)]);
        let builder = builder.query(&[("validateOnly", &req.validate_only)]);

        self.inner
            .execute(builder, Some(req.data_attribute), options)
            .await
    }

    async fn update_data_attribute(
        &self,
        req: crate::model::UpdateDataAttributeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req)
                            .and_then(|m| m.data_attribute.as_ref())
                            .map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/attributes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req)
                            .and_then(|m| m.data_attribute.as_ref())
                            .map(|m| &m.name),
                        "data_attribute.name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/attributes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataTaxonomies/*/attributes/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::PATCH, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });
        let builder = builder.query(&[("validateOnly", &req.validate_only)]);

        self.inner
            .execute(builder, Some(req.data_attribute), options)
            .await
    }

    async fn delete_data_attribute(
        &self,
        req: crate::model::DeleteDataAttributeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/attributes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/attributes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataTaxonomies/*/attributes/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("etag", &req.etag)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_data_attributes(
        &self,
        req: crate::model::ListDataAttributesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListDataAttributesResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/attributes",
                    composable_matches(
                        Some(&req).map(|m| &m.parent)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataTaxonomies/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("orderBy", &req.order_by)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_data_attribute(
        &self,
        req: crate::model::GetDataAttributeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DataAttribute>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/attributes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/attributes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataTaxonomies/*/attributes/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/locations",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[Segment::Literal("projects/"), Segment::SingleWildcard,]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[Segment::Literal("projects/"), Segment::SingleWildcard],
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/assets/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/environments/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/attributes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataAttributeBindings/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryLinkTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/aspectTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/governanceRules/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/categories/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/terms/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/encryptionConfigs/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/assets/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*/assets/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/tasks/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/environments/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/environments/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataScans/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataTaxonomies/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/attributes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataTaxonomies/*/attributes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataAttributeBindings/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataAttributeBindings/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryLinkTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryLinkTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/aspectTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/aspectTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryGroups/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/governanceRules/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/governanceRules/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/categories/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*/categories/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/terms/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*/terms/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/encryptionConfigs/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/encryptionConfigs/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/assets/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/environments/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/attributes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataAttributeBindings/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryLinkTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/aspectTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/governanceRules/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/categories/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/terms/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/encryptionConfigs/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/assets/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*/assets/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/tasks/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/environments/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/environments/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataScans/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataTaxonomies/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/attributes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataTaxonomies/*/attributes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataAttributeBindings/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataAttributeBindings/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryLinkTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryLinkTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/aspectTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/aspectTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryGroups/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/governanceRules/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/governanceRules/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/categories/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*/categories/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/terms/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*/terms/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/encryptionConfigs/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/encryptionConfigs/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .options
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "options")
            });

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/assets/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/environments/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/attributes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataAttributeBindings/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryLinkTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/aspectTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/governanceRules/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/categories/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/terms/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/encryptionConfigs/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/assets/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*/assets/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/tasks/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/environments/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/environments/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataScans/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataTaxonomies/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/attributes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataTaxonomies/*/attributes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataAttributeBindings/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataAttributeBindings/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryLinkTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryLinkTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/aspectTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/aspectTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryGroups/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/governanceRules/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/governanceRules/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/categories/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*/categories/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/terms/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*/terms/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/encryptionConfigs/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/encryptionConfigs/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/operations",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}:cancel",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:cancel",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await.map(
            |r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            },
        )
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [DataScanService](super::stub::DataScanService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct DataScanService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for DataScanService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("DataScanService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl DataScanService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::DataScanService for DataScanService {
    async fn create_data_scan(
        &self,
        req: crate::model::CreateDataScanRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/dataScans",
                    composable_matches(
                        Some(&req).map(|m| &m.parent)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("dataScanId", &req.data_scan_id)]);
        let builder = builder.query(&[("validateOnly", &req.validate_only)]);

        self.inner
            .execute(builder, Some(req.data_scan), options)
            .await
    }

    async fn update_data_scan(
        &self,
        req: crate::model::UpdateDataScanRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req)
                            .and_then(|m| m.data_scan.as_ref())
                            .map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req)
                            .and_then(|m| m.data_scan.as_ref())
                            .map(|m| &m.name),
                        "data_scan.name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataScans/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::PATCH, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });
        let builder = builder.query(&[("validateOnly", &req.validate_only)]);

        self.inner
            .execute(builder, Some(req.data_scan), options)
            .await
    }

    async fn delete_data_scan(
        &self,
        req: crate::model::DeleteDataScanRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataScans/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("force", &req.force)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_data_scan(
        &self,
        req: crate::model::GetDataScanRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DataScan>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataScans/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("view", &req.view)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_data_scans(
        &self,
        req: crate::model::ListDataScansRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListDataScansResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/dataScans",
                    composable_matches(
                        Some(&req).map(|m| &m.parent)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("orderBy", &req.order_by)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn run_data_scan(
        &self,
        req: crate::model::RunDataScanRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RunDataScanResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}:run",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataScans/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn get_data_scan_job(
        &self,
        req: crate::model::GetDataScanJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DataScanJob>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/jobs/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/jobs/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataScans/*/jobs/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("view", &req.view)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_data_scan_jobs(
        &self,
        req: crate::model::ListDataScanJobsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListDataScanJobsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/jobs",
                    composable_matches(
                        Some(&req).map(|m| &m.parent)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataScans/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        let builder = builder.query(&[("filter", &req.filter)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn generate_data_quality_rules(
        &self,
        req: crate::model::GenerateDataQualityRulesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GenerateDataQualityRulesResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}:generateDataQualityRules",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:generateDataQualityRules",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/jobs/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataScans/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/jobs/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataScans/*/jobs/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/locations",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[Segment::Literal("projects/"), Segment::SingleWildcard,]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[Segment::Literal("projects/"), Segment::SingleWildcard],
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/assets/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/environments/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/attributes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataAttributeBindings/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryLinkTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/aspectTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/governanceRules/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/categories/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/terms/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/encryptionConfigs/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/assets/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*/assets/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/tasks/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/environments/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/environments/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataScans/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataTaxonomies/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/attributes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataTaxonomies/*/attributes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataAttributeBindings/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataAttributeBindings/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryLinkTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryLinkTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/aspectTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/aspectTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryGroups/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/governanceRules/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/governanceRules/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/categories/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*/categories/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/terms/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*/terms/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/encryptionConfigs/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/encryptionConfigs/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/assets/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/environments/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/attributes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataAttributeBindings/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryLinkTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/aspectTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/governanceRules/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/categories/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/terms/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/encryptionConfigs/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/assets/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*/assets/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/tasks/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/environments/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/environments/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataScans/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataTaxonomies/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/attributes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataTaxonomies/*/attributes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataAttributeBindings/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataAttributeBindings/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryLinkTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryLinkTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/aspectTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/aspectTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryGroups/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/governanceRules/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/governanceRules/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/categories/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*/categories/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/terms/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*/terms/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/encryptionConfigs/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/encryptionConfigs/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .options
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "options")
            });

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/assets/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/environments/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/attributes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataAttributeBindings/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryLinkTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/aspectTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/governanceRules/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/categories/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/terms/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/encryptionConfigs/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/assets/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*/assets/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/tasks/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/environments/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/environments/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataScans/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataTaxonomies/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/attributes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataTaxonomies/*/attributes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataAttributeBindings/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataAttributeBindings/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryLinkTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryLinkTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/aspectTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/aspectTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryGroups/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/governanceRules/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/governanceRules/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/categories/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*/categories/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/terms/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*/terms/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/encryptionConfigs/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/encryptionConfigs/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/operations",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}:cancel",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:cancel",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await.map(
            |r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            },
        )
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [MetadataService](super::stub::MetadataService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct MetadataService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for MetadataService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("MetadataService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl MetadataService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::MetadataService for MetadataService {
    async fn create_entity(
        &self,
        req: crate::model::CreateEntityRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Entity>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/entities",
                    composable_matches(
                        Some(&req).map(|m| &m.parent)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("validateOnly", &req.validate_only)]);

        self.inner.execute(builder, Some(req.entity), options).await
    }

    async fn update_entity(
        &self,
        req: crate::model::UpdateEntityRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Entity>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req)
                            .and_then(|m| m.entity.as_ref())
                            .map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entities/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).and_then(|m| m.entity.as_ref()).map(|m| &m.name),
                        "entity.name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entities/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*/entities/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::PUT, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("validateOnly", &req.validate_only)]);

        self.inner.execute(builder, Some(req.entity), options).await
    }

    async fn delete_entity(
        &self,
        req: crate::model::DeleteEntityRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entities/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entities/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*/entities/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("etag", &req.etag)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn get_entity(
        &self,
        req: crate::model::GetEntityRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Entity>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entities/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entities/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*/entities/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("view", &req.view)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_entities(
        &self,
        req: crate::model::ListEntitiesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListEntitiesResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/entities",
                    composable_matches(
                        Some(&req).map(|m| &m.parent)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("view", &req.view)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        let builder = builder.query(&[("filter", &req.filter)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn create_partition(
        &self,
        req: crate::model::CreatePartitionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Partition>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/partitions",
                    composable_matches(
                        Some(&req).map(|m| &m.parent)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entities/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entities/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*/entities/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("validateOnly", &req.validate_only)]);

        self.inner
            .execute(builder, Some(req.partition), options)
            .await
    }

    async fn delete_partition(
        &self,
        req: crate::model::DeletePartitionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entities/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/partitions/"),
                            Segment::MultiWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entities/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/partitions/"),
                            Segment::MultiWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*/entities/*/partitions/**",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("etag", &req.etag)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn get_partition(
        &self,
        req: crate::model::GetPartitionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Partition>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entities/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/partitions/"),
                            Segment::MultiWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entities/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/partitions/"),
                            Segment::MultiWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*/entities/*/partitions/**",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_partitions(
        &self,
        req: crate::model::ListPartitionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListPartitionsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/partitions",
                    composable_matches(
                        Some(&req).map(|m| &m.parent)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entities/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entities/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*/entities/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        let builder = builder.query(&[("filter", &req.filter)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/locations",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[Segment::Literal("projects/"), Segment::SingleWildcard,]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[Segment::Literal("projects/"), Segment::SingleWildcard],
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/assets/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/environments/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/attributes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataAttributeBindings/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryLinkTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/aspectTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/governanceRules/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/categories/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/terms/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/encryptionConfigs/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/assets/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*/assets/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/tasks/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/environments/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/environments/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataScans/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataTaxonomies/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/attributes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataTaxonomies/*/attributes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataAttributeBindings/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataAttributeBindings/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryLinkTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryLinkTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/aspectTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/aspectTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryGroups/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/governanceRules/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/governanceRules/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/categories/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*/categories/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/terms/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*/terms/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/encryptionConfigs/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/encryptionConfigs/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/assets/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/environments/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/attributes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataAttributeBindings/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryLinkTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/aspectTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/governanceRules/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/categories/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/terms/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/encryptionConfigs/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/assets/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*/assets/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/tasks/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/environments/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/environments/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataScans/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataTaxonomies/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/attributes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataTaxonomies/*/attributes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataAttributeBindings/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataAttributeBindings/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryLinkTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryLinkTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/aspectTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/aspectTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryGroups/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/governanceRules/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/governanceRules/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/categories/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*/categories/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/terms/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*/terms/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/encryptionConfigs/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/encryptionConfigs/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .options
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "options")
            });

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/assets/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/environments/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/attributes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataAttributeBindings/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryLinkTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/aspectTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/governanceRules/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/categories/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/terms/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/encryptionConfigs/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/assets/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*/assets/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/tasks/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/environments/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/environments/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataScans/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataTaxonomies/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/attributes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataTaxonomies/*/attributes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataAttributeBindings/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataAttributeBindings/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryLinkTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryLinkTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/aspectTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/aspectTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryGroups/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/governanceRules/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/governanceRules/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/categories/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*/categories/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/terms/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*/terms/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/encryptionConfigs/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/encryptionConfigs/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/operations",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}:cancel",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:cancel",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await.map(
            |r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            },
        )
    }
}

/// Implements [DataplexService](super::stub::DataplexService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct DataplexService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for DataplexService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("DataplexService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl DataplexService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::DataplexService for DataplexService {
    async fn create_lake(
        &self,
        req: crate::model::CreateLakeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/lakes",
                    composable_matches(
                        Some(&req).map(|m| &m.parent)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("lakeId", &req.lake_id)]);
        let builder = builder.query(&[("validateOnly", &req.validate_only)]);

        self.inner.execute(builder, Some(req.lake), options).await
    }

    async fn update_lake(
        &self,
        req: crate::model::UpdateLakeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).and_then(|m| m.lake.as_ref()).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).and_then(|m| m.lake.as_ref()).map(|m| &m.name),
                        "lake.name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::PATCH, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });
        let builder = builder.query(&[("validateOnly", &req.validate_only)]);

        self.inner.execute(builder, Some(req.lake), options).await
    }

    async fn delete_lake(
        &self,
        req: crate::model::DeleteLakeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_lakes(
        &self,
        req: crate::model::ListLakesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListLakesResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/lakes",
                    composable_matches(
                        Some(&req).map(|m| &m.parent)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("orderBy", &req.order_by)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_lake(
        &self,
        req: crate::model::GetLakeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Lake>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_lake_actions(
        &self,
        req: crate::model::ListLakeActionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListActionsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/actions",
                    composable_matches(
                        Some(&req).map(|m| &m.parent)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn create_zone(
        &self,
        req: crate::model::CreateZoneRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/zones",
                    composable_matches(
                        Some(&req).map(|m| &m.parent)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("zoneId", &req.zone_id)]);
        let builder = builder.query(&[("validateOnly", &req.validate_only)]);

        self.inner.execute(builder, Some(req.zone), options).await
    }

    async fn update_zone(
        &self,
        req: crate::model::UpdateZoneRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).and_then(|m| m.zone.as_ref()).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).and_then(|m| m.zone.as_ref()).map(|m| &m.name),
                        "zone.name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::PATCH, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });
        let builder = builder.query(&[("validateOnly", &req.validate_only)]);

        self.inner.execute(builder, Some(req.zone), options).await
    }

    async fn delete_zone(
        &self,
        req: crate::model::DeleteZoneRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_zones(
        &self,
        req: crate::model::ListZonesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListZonesResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/zones",
                    composable_matches(
                        Some(&req).map(|m| &m.parent)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("orderBy", &req.order_by)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_zone(
        &self,
        req: crate::model::GetZoneRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Zone>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_zone_actions(
        &self,
        req: crate::model::ListZoneActionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListActionsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/actions",
                    composable_matches(
                        Some(&req).map(|m| &m.parent)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn create_asset(
        &self,
        req: crate::model::CreateAssetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/assets",
                    composable_matches(
                        Some(&req).map(|m| &m.parent)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("assetId", &req.asset_id)]);
        let builder = builder.query(&[("validateOnly", &req.validate_only)]);

        self.inner.execute(builder, Some(req.asset), options).await
    }

    async fn update_asset(
        &self,
        req: crate::model::UpdateAssetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).and_then(|m| m.asset.as_ref()).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/assets/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).and_then(|m| m.asset.as_ref()).map(|m| &m.name),
                        "asset.name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/assets/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*/assets/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::PATCH, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });
        let builder = builder.query(&[("validateOnly", &req.validate_only)]);

        self.inner.execute(builder, Some(req.asset), options).await
    }

    async fn delete_asset(
        &self,
        req: crate::model::DeleteAssetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/assets/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/assets/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*/assets/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_assets(
        &self,
        req: crate::model::ListAssetsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListAssetsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/assets",
                    composable_matches(
                        Some(&req).map(|m| &m.parent)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("orderBy", &req.order_by)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_asset(
        &self,
        req: crate::model::GetAssetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Asset>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/assets/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/assets/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*/assets/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_asset_actions(
        &self,
        req: crate::model::ListAssetActionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListActionsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/actions",
                    composable_matches(
                        Some(&req).map(|m| &m.parent)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/assets/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/assets/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*/assets/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn create_task(
        &self,
        req: crate::model::CreateTaskRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/tasks",
                    composable_matches(
                        Some(&req).map(|m| &m.parent)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("taskId", &req.task_id)]);
        let builder = builder.query(&[("validateOnly", &req.validate_only)]);

        self.inner.execute(builder, Some(req.task), options).await
    }

    async fn update_task(
        &self,
        req: crate::model::UpdateTaskRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).and_then(|m| m.task.as_ref()).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).and_then(|m| m.task.as_ref()).map(|m| &m.name),
                        "task.name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/tasks/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::PATCH, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });
        let builder = builder.query(&[("validateOnly", &req.validate_only)]);

        self.inner.execute(builder, Some(req.task), options).await
    }

    async fn delete_task(
        &self,
        req: crate::model::DeleteTaskRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/tasks/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_tasks(
        &self,
        req: crate::model::ListTasksRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListTasksResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/tasks",
                    composable_matches(
                        Some(&req).map(|m| &m.parent)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("orderBy", &req.order_by)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_task(
        &self,
        req: crate::model::GetTaskRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Task>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/tasks/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_jobs(
        &self,
        req: crate::model::ListJobsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListJobsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/jobs",
                    composable_matches(
                        Some(&req).map(|m| &m.parent)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/tasks/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn run_task(
        &self,
        req: crate::model::RunTaskRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RunTaskResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}:run",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/tasks/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn get_job(
        &self,
        req: crate::model::GetJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Job>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/jobs/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/jobs/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/tasks/*/jobs/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn cancel_job(
        &self,
        req: crate::model::CancelJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}:cancel",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/jobs/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/jobs/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/tasks/*/jobs/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await.map(
            |r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            },
        )
    }

    async fn create_environment(
        &self,
        req: crate::model::CreateEnvironmentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/environments",
                    composable_matches(
                        Some(&req).map(|m| &m.parent)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("environmentId", &req.environment_id)]);
        let builder = builder.query(&[("validateOnly", &req.validate_only)]);

        self.inner
            .execute(builder, Some(req.environment), options)
            .await
    }

    async fn update_environment(
        &self,
        req: crate::model::UpdateEnvironmentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req)
                            .and_then(|m| m.environment.as_ref())
                            .map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/environments/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req)
                            .and_then(|m| m.environment.as_ref())
                            .map(|m| &m.name),
                        "environment.name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/environments/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/environments/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::PATCH, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });
        let builder = builder.query(&[("validateOnly", &req.validate_only)]);

        self.inner
            .execute(builder, Some(req.environment), options)
            .await
    }

    async fn delete_environment(
        &self,
        req: crate::model::DeleteEnvironmentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/environments/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/environments/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/environments/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_environments(
        &self,
        req: crate::model::ListEnvironmentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListEnvironmentsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/environments",
                    composable_matches(
                        Some(&req).map(|m| &m.parent)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("orderBy", &req.order_by)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_environment(
        &self,
        req: crate::model::GetEnvironmentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Environment>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/environments/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/environments/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/environments/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_sessions(
        &self,
        req: crate::model::ListSessionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListSessionsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/sessions",
                    composable_matches(
                        Some(&req).map(|m| &m.parent)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/environments/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/environments/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/environments/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        let builder = builder.query(&[("filter", &req.filter)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/locations",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[Segment::Literal("projects/"), Segment::SingleWildcard,]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[Segment::Literal("projects/"), Segment::SingleWildcard],
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/assets/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/environments/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/attributes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataAttributeBindings/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryLinkTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/aspectTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/governanceRules/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/categories/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/terms/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:setIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/encryptionConfigs/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/assets/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*/assets/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/tasks/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/environments/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/environments/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataScans/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataTaxonomies/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/attributes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataTaxonomies/*/attributes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataAttributeBindings/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataAttributeBindings/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryLinkTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryLinkTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/aspectTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/aspectTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryGroups/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/governanceRules/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/governanceRules/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/categories/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*/categories/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/terms/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*/terms/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/encryptionConfigs/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/encryptionConfigs/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/assets/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/environments/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/attributes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataAttributeBindings/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryLinkTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/aspectTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/governanceRules/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/categories/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/terms/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:getIamPolicy",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/encryptionConfigs/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/assets/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*/assets/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/tasks/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/environments/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/environments/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataScans/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataTaxonomies/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/attributes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataTaxonomies/*/attributes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataAttributeBindings/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataAttributeBindings/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryLinkTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryLinkTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/aspectTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/aspectTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryGroups/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/governanceRules/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/governanceRules/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/categories/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*/categories/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/terms/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*/terms/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/encryptionConfigs/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/encryptionConfigs/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .options
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "options")
            });

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/assets/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/environments/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/attributes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataAttributeBindings/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryLinkTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/aspectTypes/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/governanceRules/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/categories/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/terms/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:testIamPermissions",
                    composable_matches(
                        Some(&req).map(|m| &m.resource)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/encryptionConfigs/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/assets/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/zones/*/assets/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/tasks/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/tasks/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/lakes/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/environments/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/lakes/*/environments/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataScans/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataScans/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataTaxonomies/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataTaxonomies/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/attributes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataTaxonomies/*/attributes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/dataAttributeBindings/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/dataAttributeBindings/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryLinkTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryLinkTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/aspectTypes/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/aspectTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/entryGroups/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/entryGroups/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/governanceRules/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/governanceRules/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/categories/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*/categories/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/glossaries/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/terms/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/glossaries/*/terms/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.resource),
                        "resource",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/encryptionConfigs/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/encryptionConfigs/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}/operations",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, composable_matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                Some(format!(
                    "/v1/{}:cancel",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .or_else(|| {
                Some(format!(
                    "/v1/{}:cancel",
                    composable_matches(
                        Some(&req).map(|m| &m.name)?,
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ]
                    )?,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("organizations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "organizations/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await.map(
            |r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            },
        )
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}
