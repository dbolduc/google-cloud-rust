// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

use crate::Result;
#[allow(unused_imports)]
use gax::error::Error;

/// Implements [Agents](super::stub::Agents) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct Agents {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for Agents {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("Agents")
            .field("inner", &self.inner)
            .finish()
    }
}

impl Agents {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::Agents for Agents {
    async fn list_agents(
        &self,
        req: crate::model::ListAgentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListAgentsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/agents", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_agent(
        &self,
        req: crate::model::GetAgentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Agent>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn create_agent(
        &self,
        req: crate::model::CreateAgentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Agent>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/agents", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req.agent), options).await
    }

    async fn update_agent(
        &self,
        req: crate::model::UpdateAgentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Agent>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).and_then(|m| m.agent.as_ref()).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).and_then(|m| m.agent.as_ref()).map(|m| &m.name),
                        "agent.name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::PATCH, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });

        self.inner.execute(builder, Some(req.agent), options).await
    }

    async fn delete_agent(
        &self,
        req: crate::model::DeleteAgentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn export_agent(
        &self,
        req: crate::model::ExportAgentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:export", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn restore_agent(
        &self,
        req: crate::model::RestoreAgentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:restore", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn validate_agent(
        &self,
        req: crate::model::ValidateAgentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AgentValidationResult>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:validate", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn get_agent_validation_result(
        &self,
        req: crate::model::GetAgentValidationResultRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AgentValidationResult>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("validationResult"),
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("validationResult"),
                        ],
                        "projects/*/locations/*/agents/*/validationResult",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("languageCode", &req.language_code)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_generative_settings(
        &self,
        req: crate::model::GetGenerativeSettingsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GenerativeSettings>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("generativeSettings"),
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("generativeSettings"),
                        ],
                        "projects/*/locations/*/agents/*/generativeSettings",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("languageCode", &req.language_code)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn update_generative_settings(
        &self,
        req: crate::model::UpdateGenerativeSettingsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GenerativeSettings>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req)
                    .and_then(|m| m.generative_settings.as_ref())
                    .map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("generativeSettings"),
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req)
                            .and_then(|m| m.generative_settings.as_ref())
                            .map(|m| &m.name),
                        "generative_settings.name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("generativeSettings"),
                        ],
                        "projects/*/locations/*/agents/*/generativeSettings",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::PATCH, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });

        self.inner
            .execute(builder, Some(req.generative_settings), options)
            .await
    }

    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/locations", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/operations", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/operations", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:cancel", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:cancel", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, Some(gaxi::http::NoBody), options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [Changelogs](super::stub::Changelogs) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct Changelogs {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for Changelogs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("Changelogs")
            .field("inner", &self.inner)
            .finish()
    }
}

impl Changelogs {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::Changelogs for Changelogs {
    async fn list_changelogs(
        &self,
        req: crate::model::ListChangelogsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListChangelogsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/changelogs", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_changelog(
        &self,
        req: crate::model::GetChangelogRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Changelog>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("changelogs"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("changelogs"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/changelogs/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/locations", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/operations", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/operations", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:cancel", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:cancel", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, Some(gaxi::http::NoBody), options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }
}

/// Implements [Deployments](super::stub::Deployments) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct Deployments {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for Deployments {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("Deployments")
            .field("inner", &self.inner)
            .finish()
    }
}

impl Deployments {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::Deployments for Deployments {
    async fn list_deployments(
        &self,
        req: crate::model::ListDeploymentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListDeploymentsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("environments"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/deployments", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("environments"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/environments/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_deployment(
        &self,
        req: crate::model::GetDeploymentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Deployment>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("environments"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("deployments"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("environments"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("deployments"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/environments/*/deployments/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/locations", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/operations", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/operations", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:cancel", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:cancel", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, Some(gaxi::http::NoBody), options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }
}

/// Implements [EntityTypes](super::stub::EntityTypes) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct EntityTypes {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for EntityTypes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("EntityTypes")
            .field("inner", &self.inner)
            .finish()
    }
}

impl EntityTypes {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::EntityTypes for EntityTypes {
    async fn get_entity_type(
        &self,
        req: crate::model::GetEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::EntityType>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("entityTypes"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("entityTypes"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/entityTypes/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("languageCode", &req.language_code)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn create_entity_type(
        &self,
        req: crate::model::CreateEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::EntityType>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/entityTypes", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("languageCode", &req.language_code)]);

        self.inner
            .execute(builder, Some(req.entity_type), options)
            .await
    }

    async fn update_entity_type(
        &self,
        req: crate::model::UpdateEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::EntityType>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req)
                    .and_then(|m| m.entity_type.as_ref())
                    .map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("entityTypes"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req)
                            .and_then(|m| m.entity_type.as_ref())
                            .map(|m| &m.name),
                        "entity_type.name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("entityTypes"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/entityTypes/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::PATCH, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("languageCode", &req.language_code)]);
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });

        self.inner
            .execute(builder, Some(req.entity_type), options)
            .await
    }

    async fn delete_entity_type(
        &self,
        req: crate::model::DeleteEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("entityTypes"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("entityTypes"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/entityTypes/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("force", &req.force)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn list_entity_types(
        &self,
        req: crate::model::ListEntityTypesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListEntityTypesResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/entityTypes", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("languageCode", &req.language_code)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn export_entity_types(
        &self,
        req: crate::model::ExportEntityTypesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/entityTypes:export", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn import_entity_types(
        &self,
        req: crate::model::ImportEntityTypesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/entityTypes:import", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/locations", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/operations", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/operations", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:cancel", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:cancel", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, Some(gaxi::http::NoBody), options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [Environments](super::stub::Environments) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct Environments {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for Environments {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("Environments")
            .field("inner", &self.inner)
            .finish()
    }
}

impl Environments {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::Environments for Environments {
    async fn list_environments(
        &self,
        req: crate::model::ListEnvironmentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListEnvironmentsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/environments", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_environment(
        &self,
        req: crate::model::GetEnvironmentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Environment>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("environments"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("environments"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/environments/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn create_environment(
        &self,
        req: crate::model::CreateEnvironmentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/environments", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, Some(req.environment), options)
            .await
    }

    async fn update_environment(
        &self,
        req: crate::model::UpdateEnvironmentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req)
                    .and_then(|m| m.environment.as_ref())
                    .map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("environments"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req)
                            .and_then(|m| m.environment.as_ref())
                            .map(|m| &m.name),
                        "environment.name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("environments"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/environments/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::PATCH, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });

        self.inner
            .execute(builder, Some(req.environment), options)
            .await
    }

    async fn delete_environment(
        &self,
        req: crate::model::DeleteEnvironmentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("environments"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("environments"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/environments/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn lookup_environment_history(
        &self,
        req: crate::model::LookupEnvironmentHistoryRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::LookupEnvironmentHistoryResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("environments"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:lookupEnvironmentHistory", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("environments"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/environments/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn run_continuous_test(
        &self,
        req: crate::model::RunContinuousTestRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.environment)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("environments"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:runContinuousTest", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.environment),
                        "environment",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("environments"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/environments/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn list_continuous_test_results(
        &self,
        req: crate::model::ListContinuousTestResultsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListContinuousTestResultsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("environments"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/continuousTestResults", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("environments"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/environments/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn deploy_flow(
        &self,
        req: crate::model::DeployFlowRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.environment)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("environments"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:deployFlow", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.environment),
                        "environment",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("environments"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/environments/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/locations", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/operations", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/operations", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:cancel", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:cancel", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, Some(gaxi::http::NoBody), options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [Experiments](super::stub::Experiments) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct Experiments {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for Experiments {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("Experiments")
            .field("inner", &self.inner)
            .finish()
    }
}

impl Experiments {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::Experiments for Experiments {
    async fn list_experiments(
        &self,
        req: crate::model::ListExperimentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListExperimentsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("environments"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/experiments", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("environments"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/environments/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_experiment(
        &self,
        req: crate::model::GetExperimentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Experiment>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("environments"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("experiments"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("environments"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("experiments"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/environments/*/experiments/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn create_experiment(
        &self,
        req: crate::model::CreateExperimentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Experiment>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("environments"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/experiments", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("environments"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/environments/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, Some(req.experiment), options)
            .await
    }

    async fn update_experiment(
        &self,
        req: crate::model::UpdateExperimentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Experiment>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req)
                    .and_then(|m| m.experiment.as_ref())
                    .map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("environments"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("experiments"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req)
                            .and_then(|m| m.experiment.as_ref())
                            .map(|m| &m.name),
                        "experiment.name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("environments"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("experiments"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/environments/*/experiments/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::PATCH, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });

        self.inner
            .execute(builder, Some(req.experiment), options)
            .await
    }

    async fn delete_experiment(
        &self,
        req: crate::model::DeleteExperimentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("environments"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("experiments"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("environments"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("experiments"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/environments/*/experiments/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn start_experiment(
        &self,
        req: crate::model::StartExperimentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Experiment>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("environments"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("experiments"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:start", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("environments"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("experiments"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/environments/*/experiments/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn stop_experiment(
        &self,
        req: crate::model::StopExperimentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Experiment>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("environments"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("experiments"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:stop", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("environments"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("experiments"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/environments/*/experiments/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/locations", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/operations", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/operations", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:cancel", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:cancel", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, Some(gaxi::http::NoBody), options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }
}

/// Implements [Flows](super::stub::Flows) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct Flows {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for Flows {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("Flows").field("inner", &self.inner).finish()
    }
}

impl Flows {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::Flows for Flows {
    async fn create_flow(
        &self,
        req: crate::model::CreateFlowRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Flow>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/flows", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("languageCode", &req.language_code)]);

        self.inner.execute(builder, Some(req.flow), options).await
    }

    async fn delete_flow(
        &self,
        req: crate::model::DeleteFlowRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("flows"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("flows"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/flows/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("force", &req.force)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn list_flows(
        &self,
        req: crate::model::ListFlowsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListFlowsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/flows", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        let builder = builder.query(&[("languageCode", &req.language_code)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_flow(
        &self,
        req: crate::model::GetFlowRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Flow>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("flows"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("flows"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/flows/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("languageCode", &req.language_code)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn update_flow(
        &self,
        req: crate::model::UpdateFlowRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Flow>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).and_then(|m| m.flow.as_ref()).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("flows"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).and_then(|m| m.flow.as_ref()).map(|m| &m.name),
                        "flow.name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("flows"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/flows/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::PATCH, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });
        let builder = builder.query(&[("languageCode", &req.language_code)]);

        self.inner.execute(builder, Some(req.flow), options).await
    }

    async fn train_flow(
        &self,
        req: crate::model::TrainFlowRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("flows"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:train", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("flows"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/flows/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn validate_flow(
        &self,
        req: crate::model::ValidateFlowRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FlowValidationResult>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("flows"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:validate", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("flows"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/flows/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn get_flow_validation_result(
        &self,
        req: crate::model::GetFlowValidationResultRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FlowValidationResult>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("flows"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("validationResult"),
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("flows"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("validationResult"),
                        ],
                        "projects/*/locations/*/agents/*/flows/*/validationResult",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("languageCode", &req.language_code)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn import_flow(
        &self,
        req: crate::model::ImportFlowRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/flows:import", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn export_flow(
        &self,
        req: crate::model::ExportFlowRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("flows"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:export", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("flows"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/flows/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/locations", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/operations", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/operations", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:cancel", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:cancel", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, Some(gaxi::http::NoBody), options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [Generators](super::stub::Generators) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct Generators {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for Generators {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("Generators")
            .field("inner", &self.inner)
            .finish()
    }
}

impl Generators {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::Generators for Generators {
    async fn list_generators(
        &self,
        req: crate::model::ListGeneratorsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListGeneratorsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/generators", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("languageCode", &req.language_code)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_generator(
        &self,
        req: crate::model::GetGeneratorRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Generator>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("generators"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("generators"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/generators/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("languageCode", &req.language_code)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn create_generator(
        &self,
        req: crate::model::CreateGeneratorRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Generator>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/generators", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("languageCode", &req.language_code)]);

        self.inner
            .execute(builder, Some(req.generator), options)
            .await
    }

    async fn update_generator(
        &self,
        req: crate::model::UpdateGeneratorRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Generator>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req)
                    .and_then(|m| m.generator.as_ref())
                    .map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("generators"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req)
                            .and_then(|m| m.generator.as_ref())
                            .map(|m| &m.name),
                        "generator.name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("generators"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/generators/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::PATCH, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("languageCode", &req.language_code)]);
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });

        self.inner
            .execute(builder, Some(req.generator), options)
            .await
    }

    async fn delete_generator(
        &self,
        req: crate::model::DeleteGeneratorRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("generators"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("generators"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/generators/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("force", &req.force)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/locations", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/operations", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/operations", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:cancel", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:cancel", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, Some(gaxi::http::NoBody), options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }
}

/// Implements [Intents](super::stub::Intents) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct Intents {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for Intents {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("Intents")
            .field("inner", &self.inner)
            .finish()
    }
}

impl Intents {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::Intents for Intents {
    async fn list_intents(
        &self,
        req: crate::model::ListIntentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListIntentsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/intents", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("languageCode", &req.language_code)]);
        let builder = builder.query(&[("intentView", &req.intent_view)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_intent(
        &self,
        req: crate::model::GetIntentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Intent>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("intents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("intents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/intents/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("languageCode", &req.language_code)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn create_intent(
        &self,
        req: crate::model::CreateIntentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Intent>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/intents", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("languageCode", &req.language_code)]);

        self.inner.execute(builder, Some(req.intent), options).await
    }

    async fn update_intent(
        &self,
        req: crate::model::UpdateIntentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Intent>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req)
                    .and_then(|m| m.intent.as_ref())
                    .map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("intents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).and_then(|m| m.intent.as_ref()).map(|m| &m.name),
                        "intent.name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("intents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/intents/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::PATCH, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("languageCode", &req.language_code)]);
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });

        self.inner.execute(builder, Some(req.intent), options).await
    }

    async fn delete_intent(
        &self,
        req: crate::model::DeleteIntentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("intents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("intents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/intents/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn import_intents(
        &self,
        req: crate::model::ImportIntentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/intents:import", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn export_intents(
        &self,
        req: crate::model::ExportIntentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/intents:export", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/locations", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/operations", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/operations", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:cancel", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:cancel", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, Some(gaxi::http::NoBody), options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [Pages](super::stub::Pages) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct Pages {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for Pages {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("Pages").field("inner", &self.inner).finish()
    }
}

impl Pages {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::Pages for Pages {
    async fn list_pages(
        &self,
        req: crate::model::ListPagesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListPagesResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("flows"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/pages", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("flows"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/flows/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("languageCode", &req.language_code)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_page(
        &self,
        req: crate::model::GetPageRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Page>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("flows"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("pages"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("flows"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("pages"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/flows/*/pages/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("languageCode", &req.language_code)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn create_page(
        &self,
        req: crate::model::CreatePageRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Page>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("flows"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/pages", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("flows"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/flows/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("languageCode", &req.language_code)]);

        self.inner.execute(builder, Some(req.page), options).await
    }

    async fn update_page(
        &self,
        req: crate::model::UpdatePageRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Page>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).and_then(|m| m.page.as_ref()).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("flows"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("pages"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).and_then(|m| m.page.as_ref()).map(|m| &m.name),
                        "page.name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("flows"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("pages"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/flows/*/pages/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::PATCH, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("languageCode", &req.language_code)]);
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });

        self.inner.execute(builder, Some(req.page), options).await
    }

    async fn delete_page(
        &self,
        req: crate::model::DeletePageRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("flows"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("pages"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("flows"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("pages"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/flows/*/pages/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("force", &req.force)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/locations", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/operations", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/operations", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:cancel", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:cancel", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, Some(gaxi::http::NoBody), options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }
}

/// Implements [SecuritySettingsService](super::stub::SecuritySettingsService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct SecuritySettingsService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for SecuritySettingsService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("SecuritySettingsService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl SecuritySettingsService {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::SecuritySettingsService for SecuritySettingsService {
    async fn create_security_settings(
        &self,
        req: crate::model::CreateSecuritySettingsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SecuritySettings>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/securitySettings", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, Some(req.security_settings), options)
            .await
    }

    async fn get_security_settings(
        &self,
        req: crate::model::GetSecuritySettingsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SecuritySettings>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("securitySettings"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("securitySettings"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/securitySettings/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn update_security_settings(
        &self,
        req: crate::model::UpdateSecuritySettingsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SecuritySettings>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req)
                    .and_then(|m| m.security_settings.as_ref())
                    .map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("securitySettings"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req)
                            .and_then(|m| m.security_settings.as_ref())
                            .map(|m| &m.name),
                        "security_settings.name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("securitySettings"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/securitySettings/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::PATCH, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });

        self.inner
            .execute(builder, Some(req.security_settings), options)
            .await
    }

    async fn list_security_settings(
        &self,
        req: crate::model::ListSecuritySettingsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListSecuritySettingsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/securitySettings", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn delete_security_settings(
        &self,
        req: crate::model::DeleteSecuritySettingsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("securitySettings"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("securitySettings"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/securitySettings/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/locations", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/operations", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/operations", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:cancel", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:cancel", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, Some(gaxi::http::NoBody), options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }
}

/// Implements [Sessions](super::stub::Sessions) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct Sessions {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for Sessions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("Sessions")
            .field("inner", &self.inner)
            .finish()
    }
}

impl Sessions {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::Sessions for Sessions {
    async fn detect_intent(
        &self,
        req: crate::model::DetectIntentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DetectIntentResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.session)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("sessions"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:detectIntent", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.session)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("environments"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("sessions"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:detectIntent", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.session),
                        "session",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("sessions"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/sessions/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.session),
                        "session",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("environments"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("sessions"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/environments/*/sessions/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn match_intent(
        &self,
        req: crate::model::MatchIntentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::MatchIntentResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.session)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("sessions"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:matchIntent", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.session)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("environments"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("sessions"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:matchIntent", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.session),
                        "session",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("sessions"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/sessions/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.session),
                        "session",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("environments"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("sessions"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/environments/*/sessions/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn fulfill_intent(
        &self,
        req: crate::model::FulfillIntentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FulfillIntentResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req)
                    .and_then(|m| m.match_intent_request.as_ref())
                    .map(|m| &m.session)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("sessions"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:fulfillIntent", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req)
                    .and_then(|m| m.match_intent_request.as_ref())
                    .map(|m| &m.session)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("environments"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("sessions"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:fulfillIntent", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req)
                            .and_then(|m| m.match_intent_request.as_ref())
                            .map(|m| &m.session),
                        "match_intent_request.session",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("sessions"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/sessions/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req)
                            .and_then(|m| m.match_intent_request.as_ref())
                            .map(|m| &m.session),
                        "match_intent_request.session",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("environments"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("sessions"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/environments/*/sessions/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn submit_answer_feedback(
        &self,
        req: crate::model::SubmitAnswerFeedbackRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AnswerFeedback>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.session)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("sessions"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:submitAnswerFeedback", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.session),
                        "session",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("sessions"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/sessions/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/locations", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/operations", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/operations", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:cancel", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:cancel", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, Some(gaxi::http::NoBody), options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }
}

/// Implements [SessionEntityTypes](super::stub::SessionEntityTypes) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct SessionEntityTypes {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for SessionEntityTypes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("SessionEntityTypes")
            .field("inner", &self.inner)
            .finish()
    }
}

impl SessionEntityTypes {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::SessionEntityTypes for SessionEntityTypes {
    async fn list_session_entity_types(
        &self,
        req: crate::model::ListSessionEntityTypesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListSessionEntityTypesResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("sessions"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/entityTypes", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("environments"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("sessions"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/entityTypes", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("sessions"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/sessions/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("environments"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("sessions"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/environments/*/sessions/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_session_entity_type(
        &self,
        req: crate::model::GetSessionEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SessionEntityType>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("sessions"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("entityTypes"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("environments"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("sessions"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("entityTypes"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("sessions"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("entityTypes"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/sessions/*/entityTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("environments"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("sessions"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("entityTypes"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/environments/*/sessions/*/entityTypes/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn create_session_entity_type(
        &self,
        req: crate::model::CreateSessionEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SessionEntityType>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("sessions"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/entityTypes", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("environments"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("sessions"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/entityTypes", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("sessions"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/sessions/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("environments"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("sessions"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/environments/*/sessions/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, Some(req.session_entity_type), options)
            .await
    }

    async fn update_session_entity_type(
        &self,
        req: crate::model::UpdateSessionEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SessionEntityType>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req)
                    .and_then(|m| m.session_entity_type.as_ref())
                    .map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("sessions"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("entityTypes"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req)
                    .and_then(|m| m.session_entity_type.as_ref())
                    .map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("environments"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("sessions"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("entityTypes"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req)
                            .and_then(|m| m.session_entity_type.as_ref())
                            .map(|m| &m.name),
                        "session_entity_type.name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("sessions"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("entityTypes"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/sessions/*/entityTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req)
                            .and_then(|m| m.session_entity_type.as_ref())
                            .map(|m| &m.name),
                        "session_entity_type.name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("environments"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("sessions"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("entityTypes"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/environments/*/sessions/*/entityTypes/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::PATCH, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });

        self.inner
            .execute(builder, Some(req.session_entity_type), options)
            .await
    }

    async fn delete_session_entity_type(
        &self,
        req: crate::model::DeleteSessionEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("sessions"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("entityTypes"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("environments"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("sessions"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("entityTypes"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("sessions"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("entityTypes"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/sessions/*/entityTypes/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("environments"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("sessions"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("entityTypes"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/environments/*/sessions/*/entityTypes/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/locations", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/operations", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/operations", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:cancel", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:cancel", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, Some(gaxi::http::NoBody), options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }
}

/// Implements [TestCases](super::stub::TestCases) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct TestCases {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for TestCases {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("TestCases")
            .field("inner", &self.inner)
            .finish()
    }
}

impl TestCases {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::TestCases for TestCases {
    async fn list_test_cases(
        &self,
        req: crate::model::ListTestCasesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListTestCasesResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/testCases", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        let builder = builder.query(&[("view", &req.view)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn batch_delete_test_cases(
        &self,
        req: crate::model::BatchDeleteTestCasesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/testCases:batchDelete", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await.map(
            |r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            },
        )
    }

    async fn get_test_case(
        &self,
        req: crate::model::GetTestCaseRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestCase>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("testCases"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("testCases"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/testCases/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn create_test_case(
        &self,
        req: crate::model::CreateTestCaseRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestCase>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/testCases", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, Some(req.test_case), options)
            .await
    }

    async fn update_test_case(
        &self,
        req: crate::model::UpdateTestCaseRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestCase>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req)
                    .and_then(|m| m.test_case.as_ref())
                    .map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("testCases"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req)
                            .and_then(|m| m.test_case.as_ref())
                            .map(|m| &m.name),
                        "test_case.name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("testCases"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/testCases/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::PATCH, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });

        self.inner
            .execute(builder, Some(req.test_case), options)
            .await
    }

    async fn run_test_case(
        &self,
        req: crate::model::RunTestCaseRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("testCases"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:run", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("testCases"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/testCases/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn batch_run_test_cases(
        &self,
        req: crate::model::BatchRunTestCasesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/testCases:batchRun", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn calculate_coverage(
        &self,
        req: crate::model::CalculateCoverageRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CalculateCoverageResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.agent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/testCases:calculateCoverage", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.agent),
                        "agent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("type", &req.r#type)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn import_test_cases(
        &self,
        req: crate::model::ImportTestCasesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/testCases:import", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn export_test_cases(
        &self,
        req: crate::model::ExportTestCasesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/testCases:export", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn list_test_case_results(
        &self,
        req: crate::model::ListTestCaseResultsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListTestCaseResultsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("testCases"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/results", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("testCases"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/testCases/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        let builder = builder.query(&[("filter", &req.filter)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_test_case_result(
        &self,
        req: crate::model::GetTestCaseResultRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestCaseResult>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("testCases"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("results"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("testCases"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("results"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/testCases/*/results/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/locations", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/operations", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/operations", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:cancel", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:cancel", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, Some(gaxi::http::NoBody), options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [TransitionRouteGroups](super::stub::TransitionRouteGroups) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct TransitionRouteGroups {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for TransitionRouteGroups {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("TransitionRouteGroups")
            .field("inner", &self.inner)
            .finish()
    }
}

impl TransitionRouteGroups {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::TransitionRouteGroups for TransitionRouteGroups {
    async fn list_transition_route_groups(
        &self,
        req: crate::model::ListTransitionRouteGroupsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListTransitionRouteGroupsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("flows"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/transitionRouteGroups", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/transitionRouteGroups", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("flows"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/flows/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        let builder = builder.query(&[("languageCode", &req.language_code)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_transition_route_group(
        &self,
        req: crate::model::GetTransitionRouteGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TransitionRouteGroup>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("flows"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("transitionRouteGroups"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("transitionRouteGroups"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("flows"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("transitionRouteGroups"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/flows/*/transitionRouteGroups/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("transitionRouteGroups"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/transitionRouteGroups/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("languageCode", &req.language_code)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn create_transition_route_group(
        &self,
        req: crate::model::CreateTransitionRouteGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TransitionRouteGroup>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("flows"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/transitionRouteGroups", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/transitionRouteGroups", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("flows"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/flows/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("languageCode", &req.language_code)]);

        self.inner
            .execute(builder, Some(req.transition_route_group), options)
            .await
    }

    async fn update_transition_route_group(
        &self,
        req: crate::model::UpdateTransitionRouteGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TransitionRouteGroup>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req)
                    .and_then(|m| m.transition_route_group.as_ref())
                    .map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("flows"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("transitionRouteGroups"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req)
                    .and_then(|m| m.transition_route_group.as_ref())
                    .map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("transitionRouteGroups"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req)
                            .and_then(|m| m.transition_route_group.as_ref())
                            .map(|m| &m.name),
                        "transition_route_group.name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("flows"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("transitionRouteGroups"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/flows/*/transitionRouteGroups/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req)
                            .and_then(|m| m.transition_route_group.as_ref())
                            .map(|m| &m.name),
                        "transition_route_group.name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("transitionRouteGroups"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/transitionRouteGroups/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::PATCH, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });
        let builder = builder.query(&[("languageCode", &req.language_code)]);

        self.inner
            .execute(builder, Some(req.transition_route_group), options)
            .await
    }

    async fn delete_transition_route_group(
        &self,
        req: crate::model::DeleteTransitionRouteGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("flows"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("transitionRouteGroups"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("transitionRouteGroups"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("flows"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("transitionRouteGroups"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/flows/*/transitionRouteGroups/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("transitionRouteGroups"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/transitionRouteGroups/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("force", &req.force)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/locations", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/operations", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/operations", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:cancel", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:cancel", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, Some(gaxi::http::NoBody), options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }
}

/// Implements [Versions](super::stub::Versions) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct Versions {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for Versions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("Versions")
            .field("inner", &self.inner)
            .finish()
    }
}

impl Versions {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::Versions for Versions {
    async fn list_versions(
        &self,
        req: crate::model::ListVersionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListVersionsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("flows"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/versions", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("flows"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/flows/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_version(
        &self,
        req: crate::model::GetVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Version>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("flows"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("versions"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("flows"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("versions"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/flows/*/versions/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn create_version(
        &self,
        req: crate::model::CreateVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("flows"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/versions", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("flows"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/flows/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, Some(req.version), options)
            .await
    }

    async fn update_version(
        &self,
        req: crate::model::UpdateVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Version>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req)
                    .and_then(|m| m.version.as_ref())
                    .map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("flows"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("versions"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).and_then(|m| m.version.as_ref()).map(|m| &m.name),
                        "version.name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("flows"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("versions"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/flows/*/versions/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::PATCH, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });

        self.inner
            .execute(builder, Some(req.version), options)
            .await
    }

    async fn delete_version(
        &self,
        req: crate::model::DeleteVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("flows"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("versions"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("flows"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("versions"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/flows/*/versions/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn load_version(
        &self,
        req: crate::model::LoadVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("flows"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("versions"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:load", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("flows"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("versions"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/flows/*/versions/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn compare_versions(
        &self,
        req: crate::model::CompareVersionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CompareVersionsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.base_version)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("flows"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("versions"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:compareVersions", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.base_version),
                        "base_version",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("flows"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("versions"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/flows/*/versions/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/locations", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/operations", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/operations", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:cancel", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:cancel", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, Some(gaxi::http::NoBody), options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [Webhooks](super::stub::Webhooks) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct Webhooks {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for Webhooks {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("Webhooks")
            .field("inner", &self.inner)
            .finish()
    }
}

impl Webhooks {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::Webhooks for Webhooks {
    async fn list_webhooks(
        &self,
        req: crate::model::ListWebhooksRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListWebhooksResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/webhooks", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_webhook(
        &self,
        req: crate::model::GetWebhookRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Webhook>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("webhooks"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("webhooks"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/webhooks/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn create_webhook(
        &self,
        req: crate::model::CreateWebhookRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Webhook>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/webhooks", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, Some(req.webhook), options)
            .await
    }

    async fn update_webhook(
        &self,
        req: crate::model::UpdateWebhookRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Webhook>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req)
                    .and_then(|m| m.webhook.as_ref())
                    .map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("webhooks"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).and_then(|m| m.webhook.as_ref()).map(|m| &m.name),
                        "webhook.name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("webhooks"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/webhooks/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::PATCH, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });

        self.inner
            .execute(builder, Some(req.webhook), options)
            .await
    }

    async fn delete_webhook(
        &self,
        req: crate::model::DeleteWebhookRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("agents"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("webhooks"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("agents"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("webhooks"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/agents/*/webhooks/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("force", &req.force)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/locations", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/operations", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}/operations", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:cancel", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v3/{}:cancel", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, Some(gaxi::http::NoBody), options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }
}
