// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

use crate::Result;
#[allow(unused_imports)]
use gax::error::Error;

/// Implements [ClusterManager](super::stub::ClusterManager) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct ClusterManager {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for ClusterManager {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("ClusterManager")
            .field("inner", &self.inner)
            .finish()
    }
}

impl ClusterManager {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::ClusterManager for ClusterManager {
    async fn list_clusters(
        &self,
        req: crate::model::ListClustersRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListClustersResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v1/{}/clusters", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.project_id)?;
                let arg2 = Some(&req).map(|m| &m.zone)?;
                if !matches(arg1, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg2, &[Segment::SingleWildcard]) {
                    return None;
                }
                Some(format!("/v1/projects/{}/zones/{}/clusters", arg1, arg2,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.project_id),
                        "project_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.zone),
                        "zone",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("projectId", &req.project_id)]);
        let builder = builder.query(&[("zone", &req.zone)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_cluster(
        &self,
        req: crate::model::GetClusterRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Cluster>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("clusters"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v1/{}", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.project_id)?;
                let arg2 = Some(&req).map(|m| &m.zone)?;
                let arg3 = Some(&req).map(|m| &m.cluster_id)?;
                if !matches(arg1, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg2, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg3, &[Segment::SingleWildcard]) {
                    return None;
                }
                Some(format!(
                    "/v1/projects/{}/zones/{}/clusters/{}",
                    arg1, arg2, arg3,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("clusters"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/clusters/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.project_id),
                        "project_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.zone),
                        "zone",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.cluster_id),
                        "cluster_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("projectId", &req.project_id)]);
        let builder = builder.query(&[("zone", &req.zone)]);
        let builder = builder.query(&[("clusterId", &req.cluster_id)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn create_cluster(
        &self,
        req: crate::model::CreateClusterRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v1/{}/clusters", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.project_id)?;
                let arg2 = Some(&req).map(|m| &m.zone)?;
                if !matches(arg1, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg2, &[Segment::SingleWildcard]) {
                    return None;
                }
                Some(format!("/v1/projects/{}/zones/{}/clusters", arg1, arg2,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.project_id),
                        "project_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.zone),
                        "zone",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn update_cluster(
        &self,
        req: crate::model::UpdateClusterRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("clusters"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v1/{}", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.project_id)?;
                let arg2 = Some(&req).map(|m| &m.zone)?;
                let arg3 = Some(&req).map(|m| &m.cluster_id)?;
                if !matches(arg1, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg2, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg3, &[Segment::SingleWildcard]) {
                    return None;
                }
                Some(format!(
                    "/v1/projects/{}/zones/{}/clusters/{}",
                    arg1, arg2, arg3,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("clusters"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/clusters/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.project_id),
                        "project_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.zone),
                        "zone",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.cluster_id),
                        "cluster_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::PUT, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn update_node_pool(
        &self,
        req: crate::model::UpdateNodePoolRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("clusters"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("nodePools"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v1/{}", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.project_id)?;
                let arg2 = Some(&req).map(|m| &m.zone)?;
                let arg3 = Some(&req).map(|m| &m.cluster_id)?;
                let arg4 = Some(&req).map(|m| &m.node_pool_id)?;
                if !matches(arg1, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg2, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg3, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg4, &[Segment::SingleWildcard]) {
                    return None;
                }
                Some(format!(
                    "/v1/projects/{}/zones/{}/clusters/{}/nodePools/{}/update",
                    arg1, arg2, arg3, arg4,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("clusters"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("nodePools"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/clusters/*/nodePools/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.project_id),
                        "project_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.zone),
                        "zone",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.cluster_id),
                        "cluster_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.node_pool_id),
                        "node_pool_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::PUT, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn set_node_pool_autoscaling(
        &self,
        req: crate::model::SetNodePoolAutoscalingRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("clusters"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("nodePools"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v1/{}:setAutoscaling", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.project_id)?;
                let arg2 = Some(&req).map(|m| &m.zone)?;
                let arg3 = Some(&req).map(|m| &m.cluster_id)?;
                let arg4 = Some(&req).map(|m| &m.node_pool_id)?;
                if !matches(arg1, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg2, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg3, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg4, &[Segment::SingleWildcard]) {
                    return None;
                }
                Some(format!(
                    "/v1/projects/{}/zones/{}/clusters/{}/nodePools/{}/autoscaling",
                    arg1, arg2, arg3, arg4,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("clusters"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("nodePools"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/clusters/*/nodePools/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.project_id),
                        "project_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.zone),
                        "zone",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.cluster_id),
                        "cluster_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.node_pool_id),
                        "node_pool_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn set_logging_service(
        &self,
        req: crate::model::SetLoggingServiceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("clusters"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v1/{}:setLogging", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.project_id)?;
                let arg2 = Some(&req).map(|m| &m.zone)?;
                let arg3 = Some(&req).map(|m| &m.cluster_id)?;
                if !matches(arg1, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg2, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg3, &[Segment::SingleWildcard]) {
                    return None;
                }
                Some(format!(
                    "/v1/projects/{}/zones/{}/clusters/{}/logging",
                    arg1, arg2, arg3,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("clusters"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/clusters/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.project_id),
                        "project_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.zone),
                        "zone",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.cluster_id),
                        "cluster_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn set_monitoring_service(
        &self,
        req: crate::model::SetMonitoringServiceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("clusters"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v1/{}:setMonitoring", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.project_id)?;
                let arg2 = Some(&req).map(|m| &m.zone)?;
                let arg3 = Some(&req).map(|m| &m.cluster_id)?;
                if !matches(arg1, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg2, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg3, &[Segment::SingleWildcard]) {
                    return None;
                }
                Some(format!(
                    "/v1/projects/{}/zones/{}/clusters/{}/monitoring",
                    arg1, arg2, arg3,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("clusters"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/clusters/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.project_id),
                        "project_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.zone),
                        "zone",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.cluster_id),
                        "cluster_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn set_addons_config(
        &self,
        req: crate::model::SetAddonsConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("clusters"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v1/{}:setAddons", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.project_id)?;
                let arg2 = Some(&req).map(|m| &m.zone)?;
                let arg3 = Some(&req).map(|m| &m.cluster_id)?;
                if !matches(arg1, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg2, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg3, &[Segment::SingleWildcard]) {
                    return None;
                }
                Some(format!(
                    "/v1/projects/{}/zones/{}/clusters/{}/addons",
                    arg1, arg2, arg3,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("clusters"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/clusters/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.project_id),
                        "project_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.zone),
                        "zone",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.cluster_id),
                        "cluster_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn set_locations(
        &self,
        req: crate::model::SetLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("clusters"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v1/{}:setLocations", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.project_id)?;
                let arg2 = Some(&req).map(|m| &m.zone)?;
                let arg3 = Some(&req).map(|m| &m.cluster_id)?;
                if !matches(arg1, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg2, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg3, &[Segment::SingleWildcard]) {
                    return None;
                }
                Some(format!(
                    "/v1/projects/{}/zones/{}/clusters/{}/locations",
                    arg1, arg2, arg3,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("clusters"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/clusters/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.project_id),
                        "project_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.zone),
                        "zone",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.cluster_id),
                        "cluster_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn update_master(
        &self,
        req: crate::model::UpdateMasterRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("clusters"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v1/{}:updateMaster", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.project_id)?;
                let arg2 = Some(&req).map(|m| &m.zone)?;
                let arg3 = Some(&req).map(|m| &m.cluster_id)?;
                if !matches(arg1, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg2, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg3, &[Segment::SingleWildcard]) {
                    return None;
                }
                Some(format!(
                    "/v1/projects/{}/zones/{}/clusters/{}/master",
                    arg1, arg2, arg3,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("clusters"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/clusters/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.project_id),
                        "project_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.zone),
                        "zone",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.cluster_id),
                        "cluster_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn set_master_auth(
        &self,
        req: crate::model::SetMasterAuthRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("clusters"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v1/{}:setMasterAuth", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.project_id)?;
                let arg2 = Some(&req).map(|m| &m.zone)?;
                let arg3 = Some(&req).map(|m| &m.cluster_id)?;
                if !matches(arg1, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg2, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg3, &[Segment::SingleWildcard]) {
                    return None;
                }
                Some(format!(
                    "/v1/projects/{}/zones/{}/clusters/{}:setMasterAuth",
                    arg1, arg2, arg3,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("clusters"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/clusters/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.project_id),
                        "project_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.zone),
                        "zone",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.cluster_id),
                        "cluster_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn delete_cluster(
        &self,
        req: crate::model::DeleteClusterRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("clusters"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v1/{}", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.project_id)?;
                let arg2 = Some(&req).map(|m| &m.zone)?;
                let arg3 = Some(&req).map(|m| &m.cluster_id)?;
                if !matches(arg1, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg2, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg3, &[Segment::SingleWildcard]) {
                    return None;
                }
                Some(format!(
                    "/v1/projects/{}/zones/{}/clusters/{}",
                    arg1, arg2, arg3,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("clusters"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/clusters/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.project_id),
                        "project_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.zone),
                        "zone",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.cluster_id),
                        "cluster_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("projectId", &req.project_id)]);
        let builder = builder.query(&[("zone", &req.zone)]);
        let builder = builder.query(&[("clusterId", &req.cluster_id)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_operations(
        &self,
        req: crate::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListOperationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v1/{}/operations", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.project_id)?;
                let arg2 = Some(&req).map(|m| &m.zone)?;
                if !matches(arg1, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg2, &[Segment::SingleWildcard]) {
                    return None;
                }
                Some(format!("/v1/projects/{}/zones/{}/operations", arg1, arg2,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.project_id),
                        "project_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.zone),
                        "zone",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("projectId", &req.project_id)]);
        let builder = builder.query(&[("zone", &req.zone)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_operation(
        &self,
        req: crate::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v1/{}", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.project_id)?;
                let arg2 = Some(&req).map(|m| &m.zone)?;
                let arg3 = Some(&req).map(|m| &m.operation_id)?;
                if !matches(arg1, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg2, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg3, &[Segment::SingleWildcard]) {
                    return None;
                }
                Some(format!(
                    "/v1/projects/{}/zones/{}/operations/{}",
                    arg1, arg2, arg3,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.project_id),
                        "project_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.zone),
                        "zone",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.operation_id),
                        "operation_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("projectId", &req.project_id)]);
        let builder = builder.query(&[("zone", &req.zone)]);
        let builder = builder.query(&[("operationId", &req.operation_id)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn cancel_operation(
        &self,
        req: crate::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("operations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v1/{}:cancel", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.project_id)?;
                let arg2 = Some(&req).map(|m| &m.zone)?;
                let arg3 = Some(&req).map(|m| &m.operation_id)?;
                if !matches(arg1, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg2, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg3, &[Segment::SingleWildcard]) {
                    return None;
                }
                Some(format!(
                    "/v1/projects/{}/zones/{}/operations/{}:cancel",
                    arg1, arg2, arg3,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("operations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.project_id),
                        "project_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.zone),
                        "zone",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.operation_id),
                        "operation_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await.map(
            |r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            },
        )
    }

    async fn get_server_config(
        &self,
        req: crate::model::GetServerConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ServerConfig>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v1/{}/serverConfig", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.project_id)?;
                let arg2 = Some(&req).map(|m| &m.zone)?;
                if !matches(arg1, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg2, &[Segment::SingleWildcard]) {
                    return None;
                }
                Some(format!("/v1/projects/{}/zones/{}/serverconfig", arg1, arg2,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.project_id),
                        "project_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.zone),
                        "zone",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("projectId", &req.project_id)]);
        let builder = builder.query(&[("zone", &req.zone)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_json_web_keys(
        &self,
        req: crate::model::GetJSONWebKeysRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GetJSONWebKeysResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("clusters"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v1/{}/jwks", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("clusters"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/clusters/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_node_pools(
        &self,
        req: crate::model::ListNodePoolsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListNodePoolsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("clusters"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v1/{}/nodePools", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.project_id)?;
                let arg2 = Some(&req).map(|m| &m.zone)?;
                let arg3 = Some(&req).map(|m| &m.cluster_id)?;
                if !matches(arg1, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg2, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg3, &[Segment::SingleWildcard]) {
                    return None;
                }
                Some(format!(
                    "/v1/projects/{}/zones/{}/clusters/{}/nodePools",
                    arg1, arg2, arg3,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("clusters"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/clusters/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.project_id),
                        "project_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.zone),
                        "zone",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.cluster_id),
                        "cluster_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("projectId", &req.project_id)]);
        let builder = builder.query(&[("zone", &req.zone)]);
        let builder = builder.query(&[("clusterId", &req.cluster_id)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_node_pool(
        &self,
        req: crate::model::GetNodePoolRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NodePool>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("clusters"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("nodePools"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v1/{}", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.project_id)?;
                let arg2 = Some(&req).map(|m| &m.zone)?;
                let arg3 = Some(&req).map(|m| &m.cluster_id)?;
                let arg4 = Some(&req).map(|m| &m.node_pool_id)?;
                if !matches(arg1, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg2, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg3, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg4, &[Segment::SingleWildcard]) {
                    return None;
                }
                Some(format!(
                    "/v1/projects/{}/zones/{}/clusters/{}/nodePools/{}",
                    arg1, arg2, arg3, arg4,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("clusters"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("nodePools"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/clusters/*/nodePools/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.project_id),
                        "project_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.zone),
                        "zone",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.cluster_id),
                        "cluster_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.node_pool_id),
                        "node_pool_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("projectId", &req.project_id)]);
        let builder = builder.query(&[("zone", &req.zone)]);
        let builder = builder.query(&[("clusterId", &req.cluster_id)]);
        let builder = builder.query(&[("nodePoolId", &req.node_pool_id)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn create_node_pool(
        &self,
        req: crate::model::CreateNodePoolRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("clusters"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v1/{}/nodePools", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.project_id)?;
                let arg2 = Some(&req).map(|m| &m.zone)?;
                let arg3 = Some(&req).map(|m| &m.cluster_id)?;
                if !matches(arg1, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg2, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg3, &[Segment::SingleWildcard]) {
                    return None;
                }
                Some(format!(
                    "/v1/projects/{}/zones/{}/clusters/{}/nodePools",
                    arg1, arg2, arg3,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("clusters"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/clusters/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.project_id),
                        "project_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.zone),
                        "zone",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.cluster_id),
                        "cluster_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn delete_node_pool(
        &self,
        req: crate::model::DeleteNodePoolRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("clusters"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("nodePools"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v1/{}", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.project_id)?;
                let arg2 = Some(&req).map(|m| &m.zone)?;
                let arg3 = Some(&req).map(|m| &m.cluster_id)?;
                let arg4 = Some(&req).map(|m| &m.node_pool_id)?;
                if !matches(arg1, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg2, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg3, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg4, &[Segment::SingleWildcard]) {
                    return None;
                }
                Some(format!(
                    "/v1/projects/{}/zones/{}/clusters/{}/nodePools/{}",
                    arg1, arg2, arg3, arg4,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("clusters"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("nodePools"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/clusters/*/nodePools/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.project_id),
                        "project_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.zone),
                        "zone",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.cluster_id),
                        "cluster_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.node_pool_id),
                        "node_pool_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("projectId", &req.project_id)]);
        let builder = builder.query(&[("zone", &req.zone)]);
        let builder = builder.query(&[("clusterId", &req.cluster_id)]);
        let builder = builder.query(&[("nodePoolId", &req.node_pool_id)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn complete_node_pool_upgrade(
        &self,
        req: crate::model::CompleteNodePoolUpgradeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("clusters"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("nodePools"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v1/{}:completeUpgrade", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("clusters"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("nodePools"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/clusters/*/nodePools/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await.map(
            |r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            },
        )
    }

    async fn rollback_node_pool_upgrade(
        &self,
        req: crate::model::RollbackNodePoolUpgradeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("clusters"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("nodePools"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v1/{}:rollback", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.project_id)?;
                let arg2 = Some(&req).map(|m| &m.zone)?;
                let arg3 = Some(&req).map(|m| &m.cluster_id)?;
                let arg4 = Some(&req).map(|m| &m.node_pool_id)?;
                if !matches(arg1, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg2, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg3, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg4, &[Segment::SingleWildcard]) {
                    return None;
                }
                Some(format!(
                    "/v1/projects/{}/zones/{}/clusters/{}/nodePools/{}:rollback",
                    arg1, arg2, arg3, arg4,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("clusters"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("nodePools"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/clusters/*/nodePools/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.project_id),
                        "project_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.zone),
                        "zone",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.cluster_id),
                        "cluster_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.node_pool_id),
                        "node_pool_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn set_node_pool_management(
        &self,
        req: crate::model::SetNodePoolManagementRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("clusters"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("nodePools"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v1/{}:setManagement", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.project_id)?;
                let arg2 = Some(&req).map(|m| &m.zone)?;
                let arg3 = Some(&req).map(|m| &m.cluster_id)?;
                let arg4 = Some(&req).map(|m| &m.node_pool_id)?;
                if !matches(arg1, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg2, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg3, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg4, &[Segment::SingleWildcard]) {
                    return None;
                }
                Some(format!(
                    "/v1/projects/{}/zones/{}/clusters/{}/nodePools/{}/setManagement",
                    arg1, arg2, arg3, arg4,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("clusters"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("nodePools"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/clusters/*/nodePools/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.project_id),
                        "project_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.zone),
                        "zone",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.cluster_id),
                        "cluster_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.node_pool_id),
                        "node_pool_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn set_labels(
        &self,
        req: crate::model::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("clusters"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v1/{}:setResourceLabels", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.project_id)?;
                let arg2 = Some(&req).map(|m| &m.zone)?;
                let arg3 = Some(&req).map(|m| &m.cluster_id)?;
                if !matches(arg1, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg2, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg3, &[Segment::SingleWildcard]) {
                    return None;
                }
                Some(format!(
                    "/v1/projects/{}/zones/{}/clusters/{}/resourceLabels",
                    arg1, arg2, arg3,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("clusters"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/clusters/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.project_id),
                        "project_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.zone),
                        "zone",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.cluster_id),
                        "cluster_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn set_legacy_abac(
        &self,
        req: crate::model::SetLegacyAbacRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("clusters"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v1/{}:setLegacyAbac", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.project_id)?;
                let arg2 = Some(&req).map(|m| &m.zone)?;
                let arg3 = Some(&req).map(|m| &m.cluster_id)?;
                if !matches(arg1, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg2, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg3, &[Segment::SingleWildcard]) {
                    return None;
                }
                Some(format!(
                    "/v1/projects/{}/zones/{}/clusters/{}/legacyAbac",
                    arg1, arg2, arg3,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("clusters"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/clusters/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.project_id),
                        "project_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.zone),
                        "zone",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.cluster_id),
                        "cluster_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn start_ip_rotation(
        &self,
        req: crate::model::StartIPRotationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("clusters"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v1/{}:startIpRotation", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.project_id)?;
                let arg2 = Some(&req).map(|m| &m.zone)?;
                let arg3 = Some(&req).map(|m| &m.cluster_id)?;
                if !matches(arg1, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg2, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg3, &[Segment::SingleWildcard]) {
                    return None;
                }
                Some(format!(
                    "/v1/projects/{}/zones/{}/clusters/{}:startIpRotation",
                    arg1, arg2, arg3,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("clusters"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/clusters/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.project_id),
                        "project_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.zone),
                        "zone",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.cluster_id),
                        "cluster_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn complete_ip_rotation(
        &self,
        req: crate::model::CompleteIPRotationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("clusters"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v1/{}:completeIpRotation", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.project_id)?;
                let arg2 = Some(&req).map(|m| &m.zone)?;
                let arg3 = Some(&req).map(|m| &m.cluster_id)?;
                if !matches(arg1, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg2, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg3, &[Segment::SingleWildcard]) {
                    return None;
                }
                Some(format!(
                    "/v1/projects/{}/zones/{}/clusters/{}:completeIpRotation",
                    arg1, arg2, arg3,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("clusters"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/clusters/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.project_id),
                        "project_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.zone),
                        "zone",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.cluster_id),
                        "cluster_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn set_node_pool_size(
        &self,
        req: crate::model::SetNodePoolSizeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("clusters"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("nodePools"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v1/{}:setSize", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.project_id)?;
                let arg2 = Some(&req).map(|m| &m.zone)?;
                let arg3 = Some(&req).map(|m| &m.cluster_id)?;
                let arg4 = Some(&req).map(|m| &m.node_pool_id)?;
                if !matches(arg1, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg2, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg3, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg4, &[Segment::SingleWildcard]) {
                    return None;
                }
                Some(format!(
                    "/v1/projects/{}/zones/{}/clusters/{}/nodePools/{}/setSize",
                    arg1, arg2, arg3, arg4,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("clusters"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("nodePools"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/clusters/*/nodePools/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.project_id),
                        "project_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.zone),
                        "zone",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.cluster_id),
                        "cluster_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.node_pool_id),
                        "node_pool_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn set_network_policy(
        &self,
        req: crate::model::SetNetworkPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("clusters"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v1/{}:setNetworkPolicy", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.project_id)?;
                let arg2 = Some(&req).map(|m| &m.zone)?;
                let arg3 = Some(&req).map(|m| &m.cluster_id)?;
                if !matches(arg1, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg2, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg3, &[Segment::SingleWildcard]) {
                    return None;
                }
                Some(format!(
                    "/v1/projects/{}/zones/{}/clusters/{}:setNetworkPolicy",
                    arg1, arg2, arg3,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("clusters"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/clusters/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.project_id),
                        "project_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.zone),
                        "zone",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.cluster_id),
                        "cluster_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn set_maintenance_policy(
        &self,
        req: crate::model::SetMaintenancePolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("clusters"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v1/{}:setMaintenancePolicy", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.project_id)?;
                let arg2 = Some(&req).map(|m| &m.zone)?;
                let arg3 = Some(&req).map(|m| &m.cluster_id)?;
                if !matches(arg1, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg2, &[Segment::SingleWildcard]) {
                    return None;
                }
                if !matches(arg3, &[Segment::SingleWildcard]) {
                    return None;
                }
                Some(format!(
                    "/v1/projects/{}/zones/{}/clusters/{}:setMaintenancePolicy",
                    arg1, arg2, arg3,
                ))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("clusters"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/clusters/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.project_id),
                        "project_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.zone),
                        "zone",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.cluster_id),
                        "cluster_id",
                        &[Segment::SingleWildcard],
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner.execute(builder, Some(req), options).await
    }

    async fn list_usable_subnetworks(
        &self,
        req: crate::model::ListUsableSubnetworksRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListUsableSubnetworksResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.parent)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v1/{}/aggregated/usableSubnetworks", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.parent),
                        "parent",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn check_autopilot_compatibility(
        &self,
        req: crate::model::CheckAutopilotCompatibilityRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CheckAutopilotCompatibilityResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("clusters"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v1/{}:checkAutopilotCompatibility", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("clusters"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/clusters/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn fetch_cluster_upgrade_info(
        &self,
        req: crate::model::FetchClusterUpgradeInfoRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ClusterUpgradeInfo>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("clusters"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v1/{}:fetchClusterUpgradeInfo", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("zones"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("clusters"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v1/{}:fetchClusterUpgradeInfo", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("clusters"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/clusters/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("zones"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("clusters"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/zones/*/clusters/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("version", &req.version)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn fetch_node_pool_upgrade_info(
        &self,
        req: crate::model::FetchNodePoolUpgradeInfoRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NodePoolUpgradeInfo>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        use gaxi::path_parameter::{BindingError, PathMismatchBuilder, matches};
        use gaxi::routing_parameter::Segment;

        let path = None
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("locations"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("clusters"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("nodePools"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v1/{}:fetchNodePoolUpgradeInfo", arg1,))
            })
            .or_else(|| {
                let arg1 = Some(&req).map(|m| &m.name)?;
                if !matches(
                    arg1,
                    &[
                        Segment::Literal("projects"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("zones"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("clusters"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                        Segment::Literal("/"),
                        Segment::Literal("nodePools"),
                        Segment::Literal("/"),
                        Segment::SingleWildcard,
                    ],
                ) {
                    return None;
                }
                Some(format!("/v1/{}:fetchNodePoolUpgradeInfo", arg1,))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("locations"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("clusters"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("nodePools"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/locations/*/clusters/*/nodePools/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add_match_error(
                        Some(&req).map(|m| &m.name),
                        "name",
                        &[
                            Segment::Literal("projects"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("zones"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("clusters"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/"),
                            Segment::Literal("nodePools"),
                            Segment::Literal("/"),
                            Segment::SingleWildcard,
                        ],
                        "projects/*/zones/*/clusters/*/nodePools/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })?;

        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("version", &req.version)]);

        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }
}
