// This file is @generated by prost-build.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AcceleratorType {
    Unspecified = 0,
    NvidiaTeslaK80 = 1,
    NvidiaTeslaP100 = 2,
    NvidiaTeslaV100 = 3,
    NvidiaTeslaP4 = 4,
    NvidiaTeslaT4 = 5,
    NvidiaTeslaA100 = 8,
    NvidiaA10080gb = 9,
    NvidiaL4 = 11,
    NvidiaH10080gb = 13,
    NvidiaH100Mega80gb = 14,
    NvidiaH200141gb = 15,
    NvidiaB200 = 16,
    NvidiaGb200 = 17,
    TpuV2 = 6,
    TpuV3 = 7,
    TpuV4Pod = 10,
    TpuV5Litepod = 12,
}
impl AcceleratorType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ACCELERATOR_TYPE_UNSPECIFIED",
            Self::NvidiaTeslaK80 => "NVIDIA_TESLA_K80",
            Self::NvidiaTeslaP100 => "NVIDIA_TESLA_P100",
            Self::NvidiaTeslaV100 => "NVIDIA_TESLA_V100",
            Self::NvidiaTeslaP4 => "NVIDIA_TESLA_P4",
            Self::NvidiaTeslaT4 => "NVIDIA_TESLA_T4",
            Self::NvidiaTeslaA100 => "NVIDIA_TESLA_A100",
            Self::NvidiaA10080gb => "NVIDIA_A100_80GB",
            Self::NvidiaL4 => "NVIDIA_L4",
            Self::NvidiaH10080gb => "NVIDIA_H100_80GB",
            Self::NvidiaH100Mega80gb => "NVIDIA_H100_MEGA_80GB",
            Self::NvidiaH200141gb => "NVIDIA_H200_141GB",
            Self::NvidiaB200 => "NVIDIA_B200",
            Self::NvidiaGb200 => "NVIDIA_GB200",
            Self::TpuV2 => "TPU_V2",
            Self::TpuV3 => "TPU_V3",
            Self::TpuV4Pod => "TPU_V4_POD",
            Self::TpuV5Litepod => "TPU_V5_LITEPOD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ACCELERATOR_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "NVIDIA_TESLA_K80" => Some(Self::NvidiaTeslaK80),
            "NVIDIA_TESLA_P100" => Some(Self::NvidiaTeslaP100),
            "NVIDIA_TESLA_V100" => Some(Self::NvidiaTeslaV100),
            "NVIDIA_TESLA_P4" => Some(Self::NvidiaTeslaP4),
            "NVIDIA_TESLA_T4" => Some(Self::NvidiaTeslaT4),
            "NVIDIA_TESLA_A100" => Some(Self::NvidiaTeslaA100),
            "NVIDIA_A100_80GB" => Some(Self::NvidiaA10080gb),
            "NVIDIA_L4" => Some(Self::NvidiaL4),
            "NVIDIA_H100_80GB" => Some(Self::NvidiaH10080gb),
            "NVIDIA_H100_MEGA_80GB" => Some(Self::NvidiaH100Mega80gb),
            "NVIDIA_H200_141GB" => Some(Self::NvidiaH200141gb),
            "NVIDIA_B200" => Some(Self::NvidiaB200),
            "NVIDIA_GB200" => Some(Self::NvidiaGb200),
            "TPU_V2" => Some(Self::TpuV2),
            "TPU_V3" => Some(Self::TpuV3),
            "TPU_V4_POD" => Some(Self::TpuV4Pod),
            "TPU_V5_LITEPOD" => Some(Self::TpuV5Litepod),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserActionReference {
    #[prost(string, tag = "3")]
    pub method: ::prost::alloc::string::String,
    #[prost(oneof = "user_action_reference::Reference", tags = "1, 2")]
    pub reference: ::core::option::Option<user_action_reference::Reference>,
}
/// Nested message and enum types in `UserActionReference`.
pub mod user_action_reference {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Reference {
        #[prost(string, tag = "1")]
        Operation(::prost::alloc::string::String),
        #[prost(string, tag = "2")]
        DataLabelingJob(::prost::alloc::string::String),
    }
}
impl ::prost::Name for UserActionReference {
    const NAME: &'static str = "UserActionReference";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UserActionReference".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UserActionReference".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Annotation {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub payload_schema_uri: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub payload: ::core::option::Option<::prost_types::Value>,
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "8")]
    pub etag: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub annotation_source: ::core::option::Option<UserActionReference>,
    #[prost(map = "string, string", tag = "6")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
impl ::prost::Name for Annotation {
    const NAME: &'static str = "Annotation";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.Annotation".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.Annotation".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnnotationSpec {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "5")]
    pub etag: ::prost::alloc::string::String,
}
impl ::prost::Name for AnnotationSpec {
    const NAME: &'static str = "AnnotationSpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.AnnotationSpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.AnnotationSpec".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApiAuth {
    #[prost(oneof = "api_auth::AuthConfig", tags = "1")]
    pub auth_config: ::core::option::Option<api_auth::AuthConfig>,
}
/// Nested message and enum types in `ApiAuth`.
pub mod api_auth {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ApiKeyConfig {
        #[prost(string, tag = "1")]
        pub api_key_secret_version: ::prost::alloc::string::String,
    }
    impl ::prost::Name for ApiKeyConfig {
        const NAME: &'static str = "ApiKeyConfig";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.ApiAuth.ApiKeyConfig".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.ApiAuth.ApiKeyConfig".into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum AuthConfig {
        #[prost(message, tag = "1")]
        ApiKeyConfig(ApiKeyConfig),
    }
}
impl ::prost::Name for ApiAuth {
    const NAME: &'static str = "ApiAuth";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ApiAuth".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ApiAuth".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Artifact {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub uri: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub etag: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "10")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "11")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "12")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration = "artifact::State", tag = "13")]
    pub state: i32,
    #[prost(string, tag = "14")]
    pub schema_title: ::prost::alloc::string::String,
    #[prost(string, tag = "15")]
    pub schema_version: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "16")]
    pub metadata: ::core::option::Option<::prost_types::Struct>,
    #[prost(string, tag = "17")]
    pub description: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Artifact`.
pub mod artifact {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Pending = 1,
        Live = 2,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Pending => "PENDING",
                Self::Live => "LIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PENDING" => Some(Self::Pending),
                "LIVE" => Some(Self::Live),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for Artifact {
    const NAME: &'static str = "Artifact";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.Artifact".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.Artifact".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CompletionStats {
    #[prost(int64, tag = "1")]
    pub successful_count: i64,
    #[prost(int64, tag = "2")]
    pub failed_count: i64,
    #[prost(int64, tag = "3")]
    pub incomplete_count: i64,
    #[prost(int64, tag = "5")]
    pub successful_forecast_point_count: i64,
}
impl ::prost::Name for CompletionStats {
    const NAME: &'static str = "CompletionStats";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CompletionStats".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CompletionStats".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EncryptionSpec {
    #[prost(string, tag = "1")]
    pub kms_key_name: ::prost::alloc::string::String,
}
impl ::prost::Name for EncryptionSpec {
    const NAME: &'static str = "EncryptionSpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.EncryptionSpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.EncryptionSpec".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExplanationMetadata {
    #[prost(map = "string, message", tag = "1")]
    pub inputs: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        explanation_metadata::InputMetadata,
    >,
    #[prost(map = "string, message", tag = "2")]
    pub outputs: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        explanation_metadata::OutputMetadata,
    >,
    #[prost(string, tag = "3")]
    pub feature_attributions_schema_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub latent_space_source: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ExplanationMetadata`.
pub mod explanation_metadata {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InputMetadata {
        #[prost(message, repeated, tag = "1")]
        pub input_baselines: ::prost::alloc::vec::Vec<::prost_types::Value>,
        #[prost(string, tag = "2")]
        pub input_tensor_name: ::prost::alloc::string::String,
        #[prost(enumeration = "input_metadata::Encoding", tag = "3")]
        pub encoding: i32,
        #[prost(string, tag = "4")]
        pub modality: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "5")]
        pub feature_value_domain: ::core::option::Option<
            input_metadata::FeatureValueDomain,
        >,
        #[prost(string, tag = "6")]
        pub indices_tensor_name: ::prost::alloc::string::String,
        #[prost(string, tag = "7")]
        pub dense_shape_tensor_name: ::prost::alloc::string::String,
        #[prost(string, repeated, tag = "8")]
        pub index_feature_mapping: ::prost::alloc::vec::Vec<
            ::prost::alloc::string::String,
        >,
        #[prost(string, tag = "9")]
        pub encoded_tensor_name: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "10")]
        pub encoded_baselines: ::prost::alloc::vec::Vec<::prost_types::Value>,
        #[prost(message, optional, tag = "11")]
        pub visualization: ::core::option::Option<input_metadata::Visualization>,
        #[prost(string, tag = "12")]
        pub group_name: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `InputMetadata`.
    pub mod input_metadata {
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct FeatureValueDomain {
            #[prost(float, tag = "1")]
            pub min_value: f32,
            #[prost(float, tag = "2")]
            pub max_value: f32,
            #[prost(float, tag = "3")]
            pub original_mean: f32,
            #[prost(float, tag = "4")]
            pub original_stddev: f32,
        }
        impl ::prost::Name for FeatureValueDomain {
            const NAME: &'static str = "FeatureValueDomain";
            const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.FeatureValueDomain"
                    .into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.FeatureValueDomain"
                    .into()
            }
        }
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Visualization {
            #[prost(enumeration = "visualization::Type", tag = "1")]
            pub r#type: i32,
            #[prost(enumeration = "visualization::Polarity", tag = "2")]
            pub polarity: i32,
            #[prost(enumeration = "visualization::ColorMap", tag = "3")]
            pub color_map: i32,
            #[prost(float, tag = "4")]
            pub clip_percent_upperbound: f32,
            #[prost(float, tag = "5")]
            pub clip_percent_lowerbound: f32,
            #[prost(enumeration = "visualization::OverlayType", tag = "6")]
            pub overlay_type: i32,
        }
        /// Nested message and enum types in `Visualization`.
        pub mod visualization {
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum Type {
                Unspecified = 0,
                Pixels = 1,
                Outlines = 2,
            }
            impl Type {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Unspecified => "TYPE_UNSPECIFIED",
                        Self::Pixels => "PIXELS",
                        Self::Outlines => "OUTLINES",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                        "PIXELS" => Some(Self::Pixels),
                        "OUTLINES" => Some(Self::Outlines),
                        _ => None,
                    }
                }
            }
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum Polarity {
                Unspecified = 0,
                Positive = 1,
                Negative = 2,
                Both = 3,
            }
            impl Polarity {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Unspecified => "POLARITY_UNSPECIFIED",
                        Self::Positive => "POSITIVE",
                        Self::Negative => "NEGATIVE",
                        Self::Both => "BOTH",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "POLARITY_UNSPECIFIED" => Some(Self::Unspecified),
                        "POSITIVE" => Some(Self::Positive),
                        "NEGATIVE" => Some(Self::Negative),
                        "BOTH" => Some(Self::Both),
                        _ => None,
                    }
                }
            }
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum ColorMap {
                Unspecified = 0,
                PinkGreen = 1,
                Viridis = 2,
                Red = 3,
                Green = 4,
                RedGreen = 6,
                PinkWhiteGreen = 5,
            }
            impl ColorMap {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Unspecified => "COLOR_MAP_UNSPECIFIED",
                        Self::PinkGreen => "PINK_GREEN",
                        Self::Viridis => "VIRIDIS",
                        Self::Red => "RED",
                        Self::Green => "GREEN",
                        Self::RedGreen => "RED_GREEN",
                        Self::PinkWhiteGreen => "PINK_WHITE_GREEN",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "COLOR_MAP_UNSPECIFIED" => Some(Self::Unspecified),
                        "PINK_GREEN" => Some(Self::PinkGreen),
                        "VIRIDIS" => Some(Self::Viridis),
                        "RED" => Some(Self::Red),
                        "GREEN" => Some(Self::Green),
                        "RED_GREEN" => Some(Self::RedGreen),
                        "PINK_WHITE_GREEN" => Some(Self::PinkWhiteGreen),
                        _ => None,
                    }
                }
            }
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum OverlayType {
                Unspecified = 0,
                None = 1,
                Original = 2,
                Grayscale = 3,
                MaskBlack = 4,
            }
            impl OverlayType {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Unspecified => "OVERLAY_TYPE_UNSPECIFIED",
                        Self::None => "NONE",
                        Self::Original => "ORIGINAL",
                        Self::Grayscale => "GRAYSCALE",
                        Self::MaskBlack => "MASK_BLACK",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "OVERLAY_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                        "NONE" => Some(Self::None),
                        "ORIGINAL" => Some(Self::Original),
                        "GRAYSCALE" => Some(Self::Grayscale),
                        "MASK_BLACK" => Some(Self::MaskBlack),
                        _ => None,
                    }
                }
            }
        }
        impl ::prost::Name for Visualization {
            const NAME: &'static str = "Visualization";
            const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.Visualization"
                    .into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata.Visualization"
                    .into()
            }
        }
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Encoding {
            Unspecified = 0,
            Identity = 1,
            BagOfFeatures = 2,
            BagOfFeaturesSparse = 3,
            Indicator = 4,
            CombinedEmbedding = 5,
            ConcatEmbedding = 6,
        }
        impl Encoding {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "ENCODING_UNSPECIFIED",
                    Self::Identity => "IDENTITY",
                    Self::BagOfFeatures => "BAG_OF_FEATURES",
                    Self::BagOfFeaturesSparse => "BAG_OF_FEATURES_SPARSE",
                    Self::Indicator => "INDICATOR",
                    Self::CombinedEmbedding => "COMBINED_EMBEDDING",
                    Self::ConcatEmbedding => "CONCAT_EMBEDDING",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "ENCODING_UNSPECIFIED" => Some(Self::Unspecified),
                    "IDENTITY" => Some(Self::Identity),
                    "BAG_OF_FEATURES" => Some(Self::BagOfFeatures),
                    "BAG_OF_FEATURES_SPARSE" => Some(Self::BagOfFeaturesSparse),
                    "INDICATOR" => Some(Self::Indicator),
                    "COMBINED_EMBEDDING" => Some(Self::CombinedEmbedding),
                    "CONCAT_EMBEDDING" => Some(Self::ConcatEmbedding),
                    _ => None,
                }
            }
        }
    }
    impl ::prost::Name for InputMetadata {
        const NAME: &'static str = "InputMetadata";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.ExplanationMetadata.InputMetadata"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct OutputMetadata {
        #[prost(string, tag = "3")]
        pub output_tensor_name: ::prost::alloc::string::String,
        #[prost(oneof = "output_metadata::DisplayNameMapping", tags = "1, 2")]
        pub display_name_mapping: ::core::option::Option<
            output_metadata::DisplayNameMapping,
        >,
    }
    /// Nested message and enum types in `OutputMetadata`.
    pub mod output_metadata {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum DisplayNameMapping {
            #[prost(message, tag = "1")]
            IndexDisplayNameMapping(::prost_types::Value),
            #[prost(string, tag = "2")]
            DisplayNameMappingKey(::prost::alloc::string::String),
        }
    }
    impl ::prost::Name for OutputMetadata {
        const NAME: &'static str = "OutputMetadata";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.ExplanationMetadata.OutputMetadata".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.ExplanationMetadata.OutputMetadata"
                .into()
        }
    }
}
impl ::prost::Name for ExplanationMetadata {
    const NAME: &'static str = "ExplanationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ExplanationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExplanationMetadata".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AvroSource {
    #[prost(message, optional, tag = "1")]
    pub gcs_source: ::core::option::Option<GcsSource>,
}
impl ::prost::Name for AvroSource {
    const NAME: &'static str = "AvroSource";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.AvroSource".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.AvroSource".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvSource {
    #[prost(message, optional, tag = "1")]
    pub gcs_source: ::core::option::Option<GcsSource>,
}
impl ::prost::Name for CsvSource {
    const NAME: &'static str = "CsvSource";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CsvSource".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CsvSource".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcsSource {
    #[prost(string, repeated, tag = "1")]
    pub uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for GcsSource {
    const NAME: &'static str = "GcsSource";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GcsSource".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GcsSource".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcsDestination {
    #[prost(string, tag = "1")]
    pub output_uri_prefix: ::prost::alloc::string::String,
}
impl ::prost::Name for GcsDestination {
    const NAME: &'static str = "GcsDestination";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GcsDestination".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GcsDestination".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BigQuerySource {
    #[prost(string, tag = "1")]
    pub input_uri: ::prost::alloc::string::String,
}
impl ::prost::Name for BigQuerySource {
    const NAME: &'static str = "BigQuerySource";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.BigQuerySource".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.BigQuerySource".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BigQueryDestination {
    #[prost(string, tag = "1")]
    pub output_uri: ::prost::alloc::string::String,
}
impl ::prost::Name for BigQueryDestination {
    const NAME: &'static str = "BigQueryDestination";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.BigQueryDestination".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.BigQueryDestination".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvDestination {
    #[prost(message, optional, tag = "1")]
    pub gcs_destination: ::core::option::Option<GcsDestination>,
}
impl ::prost::Name for CsvDestination {
    const NAME: &'static str = "CsvDestination";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CsvDestination".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CsvDestination".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TfRecordDestination {
    #[prost(message, optional, tag = "1")]
    pub gcs_destination: ::core::option::Option<GcsDestination>,
}
impl ::prost::Name for TfRecordDestination {
    const NAME: &'static str = "TFRecordDestination";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.TFRecordDestination".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.TFRecordDestination".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContainerRegistryDestination {
    #[prost(string, tag = "1")]
    pub output_uri: ::prost::alloc::string::String,
}
impl ::prost::Name for ContainerRegistryDestination {
    const NAME: &'static str = "ContainerRegistryDestination";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ContainerRegistryDestination".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ContainerRegistryDestination"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GoogleDriveSource {
    #[prost(message, repeated, tag = "1")]
    pub resource_ids: ::prost::alloc::vec::Vec<google_drive_source::ResourceId>,
}
/// Nested message and enum types in `GoogleDriveSource`.
pub mod google_drive_source {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ResourceId {
        #[prost(enumeration = "resource_id::ResourceType", tag = "1")]
        pub resource_type: i32,
        #[prost(string, tag = "2")]
        pub resource_id: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `ResourceId`.
    pub mod resource_id {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum ResourceType {
            Unspecified = 0,
            File = 1,
            Folder = 2,
        }
        impl ResourceType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "RESOURCE_TYPE_UNSPECIFIED",
                    Self::File => "RESOURCE_TYPE_FILE",
                    Self::Folder => "RESOURCE_TYPE_FOLDER",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "RESOURCE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "RESOURCE_TYPE_FILE" => Some(Self::File),
                    "RESOURCE_TYPE_FOLDER" => Some(Self::Folder),
                    _ => None,
                }
            }
        }
    }
    impl ::prost::Name for ResourceId {
        const NAME: &'static str = "ResourceId";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.GoogleDriveSource.ResourceId".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.GoogleDriveSource.ResourceId"
                .into()
        }
    }
}
impl ::prost::Name for GoogleDriveSource {
    const NAME: &'static str = "GoogleDriveSource";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GoogleDriveSource".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GoogleDriveSource".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DirectUploadSource {}
impl ::prost::Name for DirectUploadSource {
    const NAME: &'static str = "DirectUploadSource";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DirectUploadSource".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DirectUploadSource".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SlackSource {
    #[prost(message, repeated, tag = "1")]
    pub channels: ::prost::alloc::vec::Vec<slack_source::SlackChannels>,
}
/// Nested message and enum types in `SlackSource`.
pub mod slack_source {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SlackChannels {
        #[prost(message, repeated, tag = "1")]
        pub channels: ::prost::alloc::vec::Vec<slack_channels::SlackChannel>,
        #[prost(message, optional, tag = "3")]
        pub api_key_config: ::core::option::Option<super::api_auth::ApiKeyConfig>,
    }
    /// Nested message and enum types in `SlackChannels`.
    pub mod slack_channels {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct SlackChannel {
            #[prost(string, tag = "1")]
            pub channel_id: ::prost::alloc::string::String,
            #[prost(message, optional, tag = "2")]
            pub start_time: ::core::option::Option<::prost_types::Timestamp>,
            #[prost(message, optional, tag = "3")]
            pub end_time: ::core::option::Option<::prost_types::Timestamp>,
        }
        impl ::prost::Name for SlackChannel {
            const NAME: &'static str = "SlackChannel";
            const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "google.cloud.aiplatform.v1.SlackSource.SlackChannels.SlackChannel"
                    .into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.cloud.aiplatform.v1.SlackSource.SlackChannels.SlackChannel"
                    .into()
            }
        }
    }
    impl ::prost::Name for SlackChannels {
        const NAME: &'static str = "SlackChannels";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.SlackSource.SlackChannels".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.SlackSource.SlackChannels"
                .into()
        }
    }
}
impl ::prost::Name for SlackSource {
    const NAME: &'static str = "SlackSource";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SlackSource".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SlackSource".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct JiraSource {
    #[prost(message, repeated, tag = "1")]
    pub jira_queries: ::prost::alloc::vec::Vec<jira_source::JiraQueries>,
}
/// Nested message and enum types in `JiraSource`.
pub mod jira_source {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct JiraQueries {
        #[prost(string, repeated, tag = "3")]
        pub projects: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "4")]
        pub custom_queries: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, tag = "5")]
        pub email: ::prost::alloc::string::String,
        #[prost(string, tag = "6")]
        pub server_uri: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "7")]
        pub api_key_config: ::core::option::Option<super::api_auth::ApiKeyConfig>,
    }
    impl ::prost::Name for JiraQueries {
        const NAME: &'static str = "JiraQueries";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.JiraSource.JiraQueries".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.JiraSource.JiraQueries"
                .into()
        }
    }
}
impl ::prost::Name for JiraSource {
    const NAME: &'static str = "JiraSource";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.JiraSource".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.JiraSource".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SharePointSources {
    #[prost(message, repeated, tag = "1")]
    pub share_point_sources: ::prost::alloc::vec::Vec<
        share_point_sources::SharePointSource,
    >,
}
/// Nested message and enum types in `SharePointSources`.
pub mod share_point_sources {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SharePointSource {
        #[prost(string, tag = "1")]
        pub client_id: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub client_secret: ::core::option::Option<super::api_auth::ApiKeyConfig>,
        #[prost(string, tag = "3")]
        pub tenant_id: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub sharepoint_site_name: ::prost::alloc::string::String,
        #[prost(string, tag = "9")]
        pub file_id: ::prost::alloc::string::String,
        #[prost(oneof = "share_point_source::FolderSource", tags = "5, 6")]
        pub folder_source: ::core::option::Option<share_point_source::FolderSource>,
        #[prost(oneof = "share_point_source::DriveSource", tags = "7, 8")]
        pub drive_source: ::core::option::Option<share_point_source::DriveSource>,
    }
    /// Nested message and enum types in `SharePointSource`.
    pub mod share_point_source {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum FolderSource {
            #[prost(string, tag = "5")]
            SharepointFolderPath(::prost::alloc::string::String),
            #[prost(string, tag = "6")]
            SharepointFolderId(::prost::alloc::string::String),
        }
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum DriveSource {
            #[prost(string, tag = "7")]
            DriveName(::prost::alloc::string::String),
            #[prost(string, tag = "8")]
            DriveId(::prost::alloc::string::String),
        }
    }
    impl ::prost::Name for SharePointSource {
        const NAME: &'static str = "SharePointSource";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.SharePointSources.SharePointSource".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.SharePointSources.SharePointSource"
                .into()
        }
    }
}
impl ::prost::Name for SharePointSources {
    const NAME: &'static str = "SharePointSources";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SharePointSources".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SharePointSources".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Explanation {
    #[prost(message, repeated, tag = "1")]
    pub attributions: ::prost::alloc::vec::Vec<Attribution>,
    #[prost(message, repeated, tag = "2")]
    pub neighbors: ::prost::alloc::vec::Vec<Neighbor>,
}
impl ::prost::Name for Explanation {
    const NAME: &'static str = "Explanation";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.Explanation".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.Explanation".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModelExplanation {
    #[prost(message, repeated, tag = "1")]
    pub mean_attributions: ::prost::alloc::vec::Vec<Attribution>,
}
impl ::prost::Name for ModelExplanation {
    const NAME: &'static str = "ModelExplanation";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ModelExplanation".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ModelExplanation".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Attribution {
    #[prost(double, tag = "1")]
    pub baseline_output_value: f64,
    #[prost(double, tag = "2")]
    pub instance_output_value: f64,
    #[prost(message, optional, tag = "3")]
    pub feature_attributions: ::core::option::Option<::prost_types::Value>,
    #[prost(int32, repeated, packed = "false", tag = "4")]
    pub output_index: ::prost::alloc::vec::Vec<i32>,
    #[prost(string, tag = "5")]
    pub output_display_name: ::prost::alloc::string::String,
    #[prost(double, tag = "6")]
    pub approximation_error: f64,
    #[prost(string, tag = "7")]
    pub output_name: ::prost::alloc::string::String,
}
impl ::prost::Name for Attribution {
    const NAME: &'static str = "Attribution";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.Attribution".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.Attribution".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Neighbor {
    #[prost(string, tag = "1")]
    pub neighbor_id: ::prost::alloc::string::String,
    #[prost(double, tag = "2")]
    pub neighbor_distance: f64,
}
impl ::prost::Name for Neighbor {
    const NAME: &'static str = "Neighbor";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.Neighbor".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.Neighbor".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExplanationSpec {
    #[prost(message, optional, tag = "1")]
    pub parameters: ::core::option::Option<ExplanationParameters>,
    #[prost(message, optional, tag = "2")]
    pub metadata: ::core::option::Option<ExplanationMetadata>,
}
impl ::prost::Name for ExplanationSpec {
    const NAME: &'static str = "ExplanationSpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ExplanationSpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExplanationSpec".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExplanationParameters {
    #[prost(int32, tag = "4")]
    pub top_k: i32,
    #[prost(message, optional, tag = "5")]
    pub output_indices: ::core::option::Option<::prost_types::ListValue>,
    #[prost(oneof = "explanation_parameters::Method", tags = "1, 2, 3, 7")]
    pub method: ::core::option::Option<explanation_parameters::Method>,
}
/// Nested message and enum types in `ExplanationParameters`.
pub mod explanation_parameters {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Method {
        #[prost(message, tag = "1")]
        SampledShapleyAttribution(super::SampledShapleyAttribution),
        #[prost(message, tag = "2")]
        IntegratedGradientsAttribution(super::IntegratedGradientsAttribution),
        #[prost(message, tag = "3")]
        XraiAttribution(super::XraiAttribution),
        #[prost(message, tag = "7")]
        Examples(super::Examples),
    }
}
impl ::prost::Name for ExplanationParameters {
    const NAME: &'static str = "ExplanationParameters";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ExplanationParameters".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExplanationParameters".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SampledShapleyAttribution {
    #[prost(int32, tag = "1")]
    pub path_count: i32,
}
impl ::prost::Name for SampledShapleyAttribution {
    const NAME: &'static str = "SampledShapleyAttribution";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SampledShapleyAttribution".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SampledShapleyAttribution".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IntegratedGradientsAttribution {
    #[prost(int32, tag = "1")]
    pub step_count: i32,
    #[prost(message, optional, tag = "2")]
    pub smooth_grad_config: ::core::option::Option<SmoothGradConfig>,
    #[prost(message, optional, tag = "3")]
    pub blur_baseline_config: ::core::option::Option<BlurBaselineConfig>,
}
impl ::prost::Name for IntegratedGradientsAttribution {
    const NAME: &'static str = "IntegratedGradientsAttribution";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.IntegratedGradientsAttribution".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.IntegratedGradientsAttribution"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct XraiAttribution {
    #[prost(int32, tag = "1")]
    pub step_count: i32,
    #[prost(message, optional, tag = "2")]
    pub smooth_grad_config: ::core::option::Option<SmoothGradConfig>,
    #[prost(message, optional, tag = "3")]
    pub blur_baseline_config: ::core::option::Option<BlurBaselineConfig>,
}
impl ::prost::Name for XraiAttribution {
    const NAME: &'static str = "XraiAttribution";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.XraiAttribution".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.XraiAttribution".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SmoothGradConfig {
    #[prost(int32, tag = "3")]
    pub noisy_sample_count: i32,
    #[prost(oneof = "smooth_grad_config::GradientNoiseSigma", tags = "1, 2")]
    pub gradient_noise_sigma: ::core::option::Option<
        smooth_grad_config::GradientNoiseSigma,
    >,
}
/// Nested message and enum types in `SmoothGradConfig`.
pub mod smooth_grad_config {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum GradientNoiseSigma {
        #[prost(float, tag = "1")]
        NoiseSigma(f32),
        #[prost(message, tag = "2")]
        FeatureNoiseSigma(super::FeatureNoiseSigma),
    }
}
impl ::prost::Name for SmoothGradConfig {
    const NAME: &'static str = "SmoothGradConfig";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SmoothGradConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SmoothGradConfig".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeatureNoiseSigma {
    #[prost(message, repeated, tag = "1")]
    pub noise_sigma: ::prost::alloc::vec::Vec<feature_noise_sigma::NoiseSigmaForFeature>,
}
/// Nested message and enum types in `FeatureNoiseSigma`.
pub mod feature_noise_sigma {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NoiseSigmaForFeature {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(float, tag = "2")]
        pub sigma: f32,
    }
    impl ::prost::Name for NoiseSigmaForFeature {
        const NAME: &'static str = "NoiseSigmaForFeature";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.FeatureNoiseSigma.NoiseSigmaForFeature".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeatureNoiseSigma.NoiseSigmaForFeature"
                .into()
        }
    }
}
impl ::prost::Name for FeatureNoiseSigma {
    const NAME: &'static str = "FeatureNoiseSigma";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.FeatureNoiseSigma".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.FeatureNoiseSigma".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BlurBaselineConfig {
    #[prost(float, tag = "1")]
    pub max_blur_sigma: f32,
}
impl ::prost::Name for BlurBaselineConfig {
    const NAME: &'static str = "BlurBaselineConfig";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.BlurBaselineConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.BlurBaselineConfig".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Examples {
    #[prost(int32, tag = "3")]
    pub neighbor_count: i32,
    #[prost(oneof = "examples::Source", tags = "5")]
    pub source: ::core::option::Option<examples::Source>,
    #[prost(oneof = "examples::Config", tags = "2, 4")]
    pub config: ::core::option::Option<examples::Config>,
}
/// Nested message and enum types in `Examples`.
pub mod examples {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ExampleGcsSource {
        #[prost(enumeration = "example_gcs_source::DataFormat", tag = "1")]
        pub data_format: i32,
        #[prost(message, optional, tag = "2")]
        pub gcs_source: ::core::option::Option<super::GcsSource>,
    }
    /// Nested message and enum types in `ExampleGcsSource`.
    pub mod example_gcs_source {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum DataFormat {
            Unspecified = 0,
            Jsonl = 1,
        }
        impl DataFormat {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "DATA_FORMAT_UNSPECIFIED",
                    Self::Jsonl => "JSONL",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "DATA_FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
                    "JSONL" => Some(Self::Jsonl),
                    _ => None,
                }
            }
        }
    }
    impl ::prost::Name for ExampleGcsSource {
        const NAME: &'static str = "ExampleGcsSource";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.Examples.ExampleGcsSource".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.Examples.ExampleGcsSource"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        #[prost(message, tag = "5")]
        ExampleGcsSource(ExampleGcsSource),
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Config {
        #[prost(message, tag = "2")]
        NearestNeighborSearchConfig(::prost_types::Value),
        #[prost(message, tag = "4")]
        Presets(super::Presets),
    }
}
impl ::prost::Name for Examples {
    const NAME: &'static str = "Examples";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.Examples".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.Examples".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Presets {
    #[prost(enumeration = "presets::Query", optional, tag = "1")]
    pub query: ::core::option::Option<i32>,
    #[prost(enumeration = "presets::Modality", tag = "2")]
    pub modality: i32,
}
/// Nested message and enum types in `Presets`.
pub mod presets {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Query {
        Precise = 0,
        Fast = 1,
    }
    impl Query {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Precise => "PRECISE",
                Self::Fast => "FAST",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PRECISE" => Some(Self::Precise),
                "FAST" => Some(Self::Fast),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Modality {
        Unspecified = 0,
        Image = 1,
        Text = 2,
        Tabular = 3,
    }
    impl Modality {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "MODALITY_UNSPECIFIED",
                Self::Image => "IMAGE",
                Self::Text => "TEXT",
                Self::Tabular => "TABULAR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MODALITY_UNSPECIFIED" => Some(Self::Unspecified),
                "IMAGE" => Some(Self::Image),
                "TEXT" => Some(Self::Text),
                "TABULAR" => Some(Self::Tabular),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for Presets {
    const NAME: &'static str = "Presets";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.Presets".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.Presets".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExplanationSpecOverride {
    #[prost(message, optional, tag = "1")]
    pub parameters: ::core::option::Option<ExplanationParameters>,
    #[prost(message, optional, tag = "2")]
    pub metadata: ::core::option::Option<ExplanationMetadataOverride>,
    #[prost(message, optional, tag = "3")]
    pub examples_override: ::core::option::Option<ExamplesOverride>,
}
impl ::prost::Name for ExplanationSpecOverride {
    const NAME: &'static str = "ExplanationSpecOverride";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ExplanationSpecOverride".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExplanationSpecOverride".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExplanationMetadataOverride {
    #[prost(map = "string, message", tag = "1")]
    pub inputs: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        explanation_metadata_override::InputMetadataOverride,
    >,
}
/// Nested message and enum types in `ExplanationMetadataOverride`.
pub mod explanation_metadata_override {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InputMetadataOverride {
        #[prost(message, repeated, tag = "1")]
        pub input_baselines: ::prost::alloc::vec::Vec<::prost_types::Value>,
    }
    impl ::prost::Name for InputMetadataOverride {
        const NAME: &'static str = "InputMetadataOverride";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.ExplanationMetadataOverride.InputMetadataOverride"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.ExplanationMetadataOverride.InputMetadataOverride"
                .into()
        }
    }
}
impl ::prost::Name for ExplanationMetadataOverride {
    const NAME: &'static str = "ExplanationMetadataOverride";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ExplanationMetadataOverride".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExplanationMetadataOverride"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExamplesOverride {
    #[prost(int32, tag = "1")]
    pub neighbor_count: i32,
    #[prost(int32, tag = "2")]
    pub crowding_count: i32,
    #[prost(message, repeated, tag = "3")]
    pub restrictions: ::prost::alloc::vec::Vec<ExamplesRestrictionsNamespace>,
    #[prost(bool, tag = "4")]
    pub return_embeddings: bool,
    #[prost(enumeration = "examples_override::DataFormat", tag = "5")]
    pub data_format: i32,
}
/// Nested message and enum types in `ExamplesOverride`.
pub mod examples_override {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DataFormat {
        Unspecified = 0,
        Instances = 1,
        Embeddings = 2,
    }
    impl DataFormat {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "DATA_FORMAT_UNSPECIFIED",
                Self::Instances => "INSTANCES",
                Self::Embeddings => "EMBEDDINGS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DATA_FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
                "INSTANCES" => Some(Self::Instances),
                "EMBEDDINGS" => Some(Self::Embeddings),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for ExamplesOverride {
    const NAME: &'static str = "ExamplesOverride";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ExamplesOverride".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExamplesOverride".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExamplesRestrictionsNamespace {
    #[prost(string, tag = "1")]
    pub namespace_name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub allow: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "3")]
    pub deny: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for ExamplesRestrictionsNamespace {
    const NAME: &'static str = "ExamplesRestrictionsNamespace";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ExamplesRestrictionsNamespace".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExamplesRestrictionsNamespace"
            .into()
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum JobState {
    Unspecified = 0,
    Queued = 1,
    Pending = 2,
    Running = 3,
    Succeeded = 4,
    Failed = 5,
    Cancelling = 6,
    Cancelled = 7,
    Paused = 8,
    Expired = 9,
    Updating = 10,
    PartiallySucceeded = 11,
}
impl JobState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "JOB_STATE_UNSPECIFIED",
            Self::Queued => "JOB_STATE_QUEUED",
            Self::Pending => "JOB_STATE_PENDING",
            Self::Running => "JOB_STATE_RUNNING",
            Self::Succeeded => "JOB_STATE_SUCCEEDED",
            Self::Failed => "JOB_STATE_FAILED",
            Self::Cancelling => "JOB_STATE_CANCELLING",
            Self::Cancelled => "JOB_STATE_CANCELLED",
            Self::Paused => "JOB_STATE_PAUSED",
            Self::Expired => "JOB_STATE_EXPIRED",
            Self::Updating => "JOB_STATE_UPDATING",
            Self::PartiallySucceeded => "JOB_STATE_PARTIALLY_SUCCEEDED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "JOB_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "JOB_STATE_QUEUED" => Some(Self::Queued),
            "JOB_STATE_PENDING" => Some(Self::Pending),
            "JOB_STATE_RUNNING" => Some(Self::Running),
            "JOB_STATE_SUCCEEDED" => Some(Self::Succeeded),
            "JOB_STATE_FAILED" => Some(Self::Failed),
            "JOB_STATE_CANCELLING" => Some(Self::Cancelling),
            "JOB_STATE_CANCELLED" => Some(Self::Cancelled),
            "JOB_STATE_PAUSED" => Some(Self::Paused),
            "JOB_STATE_EXPIRED" => Some(Self::Expired),
            "JOB_STATE_UPDATING" => Some(Self::Updating),
            "JOB_STATE_PARTIALLY_SUCCEEDED" => Some(Self::PartiallySucceeded),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReservationAffinity {
    #[prost(enumeration = "reservation_affinity::Type", tag = "1")]
    pub reservation_affinity_type: i32,
    #[prost(string, tag = "2")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `ReservationAffinity`.
pub mod reservation_affinity {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unspecified = 0,
        NoReservation = 1,
        AnyReservation = 2,
        SpecificReservation = 3,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_UNSPECIFIED",
                Self::NoReservation => "NO_RESERVATION",
                Self::AnyReservation => "ANY_RESERVATION",
                Self::SpecificReservation => "SPECIFIC_RESERVATION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "NO_RESERVATION" => Some(Self::NoReservation),
                "ANY_RESERVATION" => Some(Self::AnyReservation),
                "SPECIFIC_RESERVATION" => Some(Self::SpecificReservation),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for ReservationAffinity {
    const NAME: &'static str = "ReservationAffinity";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ReservationAffinity".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ReservationAffinity".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MachineSpec {
    #[prost(string, tag = "1")]
    pub machine_type: ::prost::alloc::string::String,
    #[prost(enumeration = "AcceleratorType", tag = "2")]
    pub accelerator_type: i32,
    #[prost(int32, tag = "3")]
    pub accelerator_count: i32,
    #[prost(string, tag = "4")]
    pub tpu_topology: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub reservation_affinity: ::core::option::Option<ReservationAffinity>,
}
impl ::prost::Name for MachineSpec {
    const NAME: &'static str = "MachineSpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.MachineSpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.MachineSpec".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DedicatedResources {
    #[prost(message, optional, tag = "1")]
    pub machine_spec: ::core::option::Option<MachineSpec>,
    #[prost(int32, tag = "2")]
    pub min_replica_count: i32,
    #[prost(int32, tag = "3")]
    pub max_replica_count: i32,
    #[prost(int32, tag = "9")]
    pub required_replica_count: i32,
    #[prost(message, repeated, tag = "4")]
    pub autoscaling_metric_specs: ::prost::alloc::vec::Vec<AutoscalingMetricSpec>,
    #[prost(bool, tag = "5")]
    pub spot: bool,
}
impl ::prost::Name for DedicatedResources {
    const NAME: &'static str = "DedicatedResources";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DedicatedResources".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DedicatedResources".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AutomaticResources {
    #[prost(int32, tag = "1")]
    pub min_replica_count: i32,
    #[prost(int32, tag = "2")]
    pub max_replica_count: i32,
}
impl ::prost::Name for AutomaticResources {
    const NAME: &'static str = "AutomaticResources";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.AutomaticResources".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.AutomaticResources".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchDedicatedResources {
    #[prost(message, optional, tag = "1")]
    pub machine_spec: ::core::option::Option<MachineSpec>,
    #[prost(int32, tag = "2")]
    pub starting_replica_count: i32,
    #[prost(int32, tag = "3")]
    pub max_replica_count: i32,
}
impl ::prost::Name for BatchDedicatedResources {
    const NAME: &'static str = "BatchDedicatedResources";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.BatchDedicatedResources".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchDedicatedResources".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResourcesConsumed {
    #[prost(double, tag = "1")]
    pub replica_hours: f64,
}
impl ::prost::Name for ResourcesConsumed {
    const NAME: &'static str = "ResourcesConsumed";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ResourcesConsumed".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ResourcesConsumed".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiskSpec {
    #[prost(string, tag = "1")]
    pub boot_disk_type: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub boot_disk_size_gb: i32,
}
impl ::prost::Name for DiskSpec {
    const NAME: &'static str = "DiskSpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DiskSpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DiskSpec".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PersistentDiskSpec {
    #[prost(string, tag = "1")]
    pub disk_type: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub disk_size_gb: i64,
}
impl ::prost::Name for PersistentDiskSpec {
    const NAME: &'static str = "PersistentDiskSpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.PersistentDiskSpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.PersistentDiskSpec".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NfsMount {
    #[prost(string, tag = "1")]
    pub server: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub path: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub mount_point: ::prost::alloc::string::String,
}
impl ::prost::Name for NfsMount {
    const NAME: &'static str = "NfsMount";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.NfsMount".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.NfsMount".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutoscalingMetricSpec {
    #[prost(string, tag = "1")]
    pub metric_name: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub target: i32,
}
impl ::prost::Name for AutoscalingMetricSpec {
    const NAME: &'static str = "AutoscalingMetricSpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.AutoscalingMetricSpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.AutoscalingMetricSpec".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ShieldedVmConfig {
    #[prost(bool, tag = "1")]
    pub enable_secure_boot: bool,
}
impl ::prost::Name for ShieldedVmConfig {
    const NAME: &'static str = "ShieldedVmConfig";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ShieldedVmConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ShieldedVmConfig".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ManualBatchTuningParameters {
    #[prost(int32, tag = "1")]
    pub batch_size: i32,
}
impl ::prost::Name for ManualBatchTuningParameters {
    const NAME: &'static str = "ManualBatchTuningParameters";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ManualBatchTuningParameters".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ManualBatchTuningParameters"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployedModelRef {
    #[prost(string, tag = "1")]
    pub endpoint: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub deployed_model_id: ::prost::alloc::string::String,
}
impl ::prost::Name for DeployedModelRef {
    const NAME: &'static str = "DeployedModelRef";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeployedModelRef".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeployedModelRef".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnvVar {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
}
impl ::prost::Name for EnvVar {
    const NAME: &'static str = "EnvVar";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.EnvVar".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.EnvVar".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecretRef {
    #[prost(string, tag = "1")]
    pub secret: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
}
impl ::prost::Name for SecretRef {
    const NAME: &'static str = "SecretRef";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SecretRef".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SecretRef".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecretEnvVar {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub secret_ref: ::core::option::Option<SecretRef>,
}
impl ::prost::Name for SecretEnvVar {
    const NAME: &'static str = "SecretEnvVar";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SecretEnvVar".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SecretEnvVar".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Model {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "28")]
    pub version_id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "29")]
    pub version_aliases: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "31")]
    pub version_create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "32")]
    pub version_update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "30")]
    pub version_description: ::prost::alloc::string::String,
    #[prost(string, tag = "53")]
    pub default_checkpoint_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub predict_schemata: ::core::option::Option<PredictSchemata>,
    #[prost(string, tag = "5")]
    pub metadata_schema_uri: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub metadata: ::core::option::Option<::prost_types::Value>,
    #[prost(message, repeated, tag = "20")]
    pub supported_export_formats: ::prost::alloc::vec::Vec<model::ExportFormat>,
    #[prost(string, tag = "7")]
    pub training_pipeline: ::prost::alloc::string::String,
    #[prost(string, tag = "47")]
    pub pipeline_job: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "9")]
    pub container_spec: ::core::option::Option<ModelContainerSpec>,
    #[prost(string, tag = "26")]
    pub artifact_uri: ::prost::alloc::string::String,
    #[prost(
        enumeration = "model::DeploymentResourcesType",
        repeated,
        packed = "false",
        tag = "10"
    )]
    pub supported_deployment_resources_types: ::prost::alloc::vec::Vec<i32>,
    #[prost(string, repeated, tag = "11")]
    pub supported_input_storage_formats: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(string, repeated, tag = "12")]
    pub supported_output_storage_formats: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "13")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "14")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, repeated, tag = "15")]
    pub deployed_models: ::prost::alloc::vec::Vec<DeployedModelRef>,
    #[prost(message, optional, tag = "23")]
    pub explanation_spec: ::core::option::Option<ExplanationSpec>,
    #[prost(string, tag = "16")]
    pub etag: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "17")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "21")]
    pub data_stats: ::core::option::Option<model::DataStats>,
    #[prost(message, optional, tag = "24")]
    pub encryption_spec: ::core::option::Option<EncryptionSpec>,
    #[prost(message, optional, tag = "38")]
    pub model_source_info: ::core::option::Option<ModelSourceInfo>,
    #[prost(message, optional, tag = "34")]
    pub original_model_info: ::core::option::Option<model::OriginalModelInfo>,
    #[prost(string, tag = "44")]
    pub metadata_artifact: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "50")]
    pub base_model_source: ::core::option::Option<model::BaseModelSource>,
    #[prost(bool, tag = "51")]
    pub satisfies_pzs: bool,
    #[prost(bool, tag = "52")]
    pub satisfies_pzi: bool,
    #[prost(message, repeated, tag = "57")]
    pub checkpoints: ::prost::alloc::vec::Vec<Checkpoint>,
}
/// Nested message and enum types in `Model`.
pub mod model {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ExportFormat {
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        #[prost(
            enumeration = "export_format::ExportableContent",
            repeated,
            packed = "false",
            tag = "2"
        )]
        pub exportable_contents: ::prost::alloc::vec::Vec<i32>,
    }
    /// Nested message and enum types in `ExportFormat`.
    pub mod export_format {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum ExportableContent {
            Unspecified = 0,
            Artifact = 1,
            Image = 2,
        }
        impl ExportableContent {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "EXPORTABLE_CONTENT_UNSPECIFIED",
                    Self::Artifact => "ARTIFACT",
                    Self::Image => "IMAGE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "EXPORTABLE_CONTENT_UNSPECIFIED" => Some(Self::Unspecified),
                    "ARTIFACT" => Some(Self::Artifact),
                    "IMAGE" => Some(Self::Image),
                    _ => None,
                }
            }
        }
    }
    impl ::prost::Name for ExportFormat {
        const NAME: &'static str = "ExportFormat";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.Model.ExportFormat".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.Model.ExportFormat".into()
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DataStats {
        #[prost(int64, tag = "1")]
        pub training_data_items_count: i64,
        #[prost(int64, tag = "2")]
        pub validation_data_items_count: i64,
        #[prost(int64, tag = "3")]
        pub test_data_items_count: i64,
        #[prost(int64, tag = "4")]
        pub training_annotations_count: i64,
        #[prost(int64, tag = "5")]
        pub validation_annotations_count: i64,
        #[prost(int64, tag = "6")]
        pub test_annotations_count: i64,
    }
    impl ::prost::Name for DataStats {
        const NAME: &'static str = "DataStats";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.Model.DataStats".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.Model.DataStats".into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct OriginalModelInfo {
        #[prost(string, tag = "1")]
        pub model: ::prost::alloc::string::String,
    }
    impl ::prost::Name for OriginalModelInfo {
        const NAME: &'static str = "OriginalModelInfo";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.Model.OriginalModelInfo".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.Model.OriginalModelInfo"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BaseModelSource {
        #[prost(oneof = "base_model_source::Source", tags = "1, 2")]
        pub source: ::core::option::Option<base_model_source::Source>,
    }
    /// Nested message and enum types in `BaseModelSource`.
    pub mod base_model_source {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Source {
            #[prost(message, tag = "1")]
            ModelGardenSource(super::super::ModelGardenSource),
            #[prost(message, tag = "2")]
            GenieSource(super::super::GenieSource),
        }
    }
    impl ::prost::Name for BaseModelSource {
        const NAME: &'static str = "BaseModelSource";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.Model.BaseModelSource".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.Model.BaseModelSource".into()
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DeploymentResourcesType {
        Unspecified = 0,
        DedicatedResources = 1,
        AutomaticResources = 2,
        SharedResources = 3,
    }
    impl DeploymentResourcesType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "DEPLOYMENT_RESOURCES_TYPE_UNSPECIFIED",
                Self::DedicatedResources => "DEDICATED_RESOURCES",
                Self::AutomaticResources => "AUTOMATIC_RESOURCES",
                Self::SharedResources => "SHARED_RESOURCES",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DEPLOYMENT_RESOURCES_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "DEDICATED_RESOURCES" => Some(Self::DedicatedResources),
                "AUTOMATIC_RESOURCES" => Some(Self::AutomaticResources),
                "SHARED_RESOURCES" => Some(Self::SharedResources),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for Model {
    const NAME: &'static str = "Model";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.Model".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.Model".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LargeModelReference {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for LargeModelReference {
    const NAME: &'static str = "LargeModelReference";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.LargeModelReference".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.LargeModelReference".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModelGardenSource {
    #[prost(string, tag = "1")]
    pub public_model_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub version_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub skip_hf_model_cache: bool,
}
impl ::prost::Name for ModelGardenSource {
    const NAME: &'static str = "ModelGardenSource";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ModelGardenSource".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ModelGardenSource".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenieSource {
    #[prost(string, tag = "1")]
    pub base_model_uri: ::prost::alloc::string::String,
}
impl ::prost::Name for GenieSource {
    const NAME: &'static str = "GenieSource";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GenieSource".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GenieSource".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PredictSchemata {
    #[prost(string, tag = "1")]
    pub instance_schema_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub parameters_schema_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub prediction_schema_uri: ::prost::alloc::string::String,
}
impl ::prost::Name for PredictSchemata {
    const NAME: &'static str = "PredictSchemata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.PredictSchemata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.PredictSchemata".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModelContainerSpec {
    #[prost(string, tag = "1")]
    pub image_uri: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub command: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "3")]
    pub args: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "4")]
    pub env: ::prost::alloc::vec::Vec<EnvVar>,
    #[prost(message, repeated, tag = "5")]
    pub ports: ::prost::alloc::vec::Vec<Port>,
    #[prost(string, tag = "6")]
    pub predict_route: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub health_route: ::prost::alloc::string::String,
    #[prost(string, tag = "15")]
    pub invoke_route_prefix: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "9")]
    pub grpc_ports: ::prost::alloc::vec::Vec<Port>,
    #[prost(message, optional, tag = "10")]
    pub deployment_timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(int64, tag = "11")]
    pub shared_memory_size_mb: i64,
    #[prost(message, optional, tag = "12")]
    pub startup_probe: ::core::option::Option<Probe>,
    #[prost(message, optional, tag = "13")]
    pub health_probe: ::core::option::Option<Probe>,
    #[prost(message, optional, tag = "14")]
    pub liveness_probe: ::core::option::Option<Probe>,
}
impl ::prost::Name for ModelContainerSpec {
    const NAME: &'static str = "ModelContainerSpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ModelContainerSpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ModelContainerSpec".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Port {
    #[prost(int32, tag = "3")]
    pub container_port: i32,
}
impl ::prost::Name for Port {
    const NAME: &'static str = "Port";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.Port".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.Port".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ModelSourceInfo {
    #[prost(enumeration = "model_source_info::ModelSourceType", tag = "1")]
    pub source_type: i32,
    #[prost(bool, tag = "2")]
    pub copy: bool,
}
/// Nested message and enum types in `ModelSourceInfo`.
pub mod model_source_info {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ModelSourceType {
        Unspecified = 0,
        Automl = 1,
        Custom = 2,
        Bqml = 3,
        ModelGarden = 4,
        Genie = 5,
        CustomTextEmbedding = 6,
        Marketplace = 7,
    }
    impl ModelSourceType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "MODEL_SOURCE_TYPE_UNSPECIFIED",
                Self::Automl => "AUTOML",
                Self::Custom => "CUSTOM",
                Self::Bqml => "BQML",
                Self::ModelGarden => "MODEL_GARDEN",
                Self::Genie => "GENIE",
                Self::CustomTextEmbedding => "CUSTOM_TEXT_EMBEDDING",
                Self::Marketplace => "MARKETPLACE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MODEL_SOURCE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "AUTOML" => Some(Self::Automl),
                "CUSTOM" => Some(Self::Custom),
                "BQML" => Some(Self::Bqml),
                "MODEL_GARDEN" => Some(Self::ModelGarden),
                "GENIE" => Some(Self::Genie),
                "CUSTOM_TEXT_EMBEDDING" => Some(Self::CustomTextEmbedding),
                "MARKETPLACE" => Some(Self::Marketplace),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for ModelSourceInfo {
    const NAME: &'static str = "ModelSourceInfo";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ModelSourceInfo".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ModelSourceInfo".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Probe {
    #[prost(int32, tag = "2")]
    pub period_seconds: i32,
    #[prost(int32, tag = "3")]
    pub timeout_seconds: i32,
    #[prost(int32, tag = "7")]
    pub failure_threshold: i32,
    #[prost(int32, tag = "8")]
    pub success_threshold: i32,
    #[prost(int32, tag = "9")]
    pub initial_delay_seconds: i32,
    #[prost(oneof = "probe::ProbeType", tags = "1, 4, 5, 6")]
    pub probe_type: ::core::option::Option<probe::ProbeType>,
}
/// Nested message and enum types in `Probe`.
pub mod probe {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ExecAction {
        #[prost(string, repeated, tag = "1")]
        pub command: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    impl ::prost::Name for ExecAction {
        const NAME: &'static str = "ExecAction";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.Probe.ExecAction".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.Probe.ExecAction".into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct HttpGetAction {
        #[prost(string, tag = "1")]
        pub path: ::prost::alloc::string::String,
        #[prost(int32, tag = "2")]
        pub port: i32,
        #[prost(string, tag = "3")]
        pub host: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub scheme: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "5")]
        pub http_headers: ::prost::alloc::vec::Vec<HttpHeader>,
    }
    impl ::prost::Name for HttpGetAction {
        const NAME: &'static str = "HttpGetAction";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.Probe.HttpGetAction".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.Probe.HttpGetAction".into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GrpcAction {
        #[prost(int32, tag = "1")]
        pub port: i32,
        #[prost(string, tag = "2")]
        pub service: ::prost::alloc::string::String,
    }
    impl ::prost::Name for GrpcAction {
        const NAME: &'static str = "GrpcAction";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.Probe.GrpcAction".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.Probe.GrpcAction".into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TcpSocketAction {
        #[prost(int32, tag = "1")]
        pub port: i32,
        #[prost(string, tag = "2")]
        pub host: ::prost::alloc::string::String,
    }
    impl ::prost::Name for TcpSocketAction {
        const NAME: &'static str = "TcpSocketAction";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.Probe.TcpSocketAction".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.Probe.TcpSocketAction".into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct HttpHeader {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub value: ::prost::alloc::string::String,
    }
    impl ::prost::Name for HttpHeader {
        const NAME: &'static str = "HttpHeader";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.Probe.HttpHeader".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.Probe.HttpHeader".into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ProbeType {
        #[prost(message, tag = "1")]
        Exec(ExecAction),
        #[prost(message, tag = "4")]
        HttpGet(HttpGetAction),
        #[prost(message, tag = "5")]
        Grpc(GrpcAction),
        #[prost(message, tag = "6")]
        TcpSocket(TcpSocketAction),
    }
}
impl ::prost::Name for Probe {
    const NAME: &'static str = "Probe";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.Probe".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.Probe".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Checkpoint {
    #[prost(string, tag = "1")]
    pub checkpoint_id: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub epoch: i64,
    #[prost(int64, tag = "3")]
    pub step: i64,
}
impl ::prost::Name for Checkpoint {
    const NAME: &'static str = "Checkpoint";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.Checkpoint".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.Checkpoint".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnmanagedContainerModel {
    #[prost(string, tag = "1")]
    pub artifact_uri: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub predict_schemata: ::core::option::Option<PredictSchemata>,
    #[prost(message, optional, tag = "3")]
    pub container_spec: ::core::option::Option<ModelContainerSpec>,
}
impl ::prost::Name for UnmanagedContainerModel {
    const NAME: &'static str = "UnmanagedContainerModel";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UnmanagedContainerModel".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UnmanagedContainerModel".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchPredictionJob {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub model: ::prost::alloc::string::String,
    #[prost(string, tag = "30")]
    pub model_version_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "28")]
    pub unmanaged_container_model: ::core::option::Option<UnmanagedContainerModel>,
    #[prost(message, optional, tag = "4")]
    pub input_config: ::core::option::Option<batch_prediction_job::InputConfig>,
    #[prost(message, optional, tag = "27")]
    pub instance_config: ::core::option::Option<batch_prediction_job::InstanceConfig>,
    #[prost(message, optional, tag = "5")]
    pub model_parameters: ::core::option::Option<::prost_types::Value>,
    #[prost(message, optional, tag = "6")]
    pub output_config: ::core::option::Option<batch_prediction_job::OutputConfig>,
    #[prost(message, optional, tag = "7")]
    pub dedicated_resources: ::core::option::Option<BatchDedicatedResources>,
    #[prost(string, tag = "29")]
    pub service_account: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "8")]
    pub manual_batch_tuning_parameters: ::core::option::Option<
        ManualBatchTuningParameters,
    >,
    #[prost(bool, tag = "23")]
    pub generate_explanation: bool,
    #[prost(message, optional, tag = "25")]
    pub explanation_spec: ::core::option::Option<ExplanationSpec>,
    #[prost(message, optional, tag = "9")]
    pub output_info: ::core::option::Option<batch_prediction_job::OutputInfo>,
    #[prost(enumeration = "JobState", tag = "10")]
    pub state: i32,
    #[prost(message, optional, tag = "11")]
    pub error: ::core::option::Option<super::super::super::rpc::Status>,
    #[prost(message, repeated, tag = "12")]
    pub partial_failures: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
    #[prost(message, optional, tag = "13")]
    pub resources_consumed: ::core::option::Option<ResourcesConsumed>,
    #[prost(message, optional, tag = "14")]
    pub completion_stats: ::core::option::Option<CompletionStats>,
    #[prost(message, optional, tag = "15")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "16")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "17")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "18")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "19")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "24")]
    pub encryption_spec: ::core::option::Option<EncryptionSpec>,
    #[prost(bool, tag = "34")]
    pub disable_container_logging: bool,
    #[prost(bool, tag = "36")]
    pub satisfies_pzs: bool,
    #[prost(bool, tag = "37")]
    pub satisfies_pzi: bool,
}
/// Nested message and enum types in `BatchPredictionJob`.
pub mod batch_prediction_job {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InputConfig {
        #[prost(string, tag = "1")]
        pub instances_format: ::prost::alloc::string::String,
        #[prost(oneof = "input_config::Source", tags = "2, 3")]
        pub source: ::core::option::Option<input_config::Source>,
    }
    /// Nested message and enum types in `InputConfig`.
    pub mod input_config {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Source {
            #[prost(message, tag = "2")]
            GcsSource(super::super::GcsSource),
            #[prost(message, tag = "3")]
            BigquerySource(super::super::BigQuerySource),
        }
    }
    impl ::prost::Name for InputConfig {
        const NAME: &'static str = "InputConfig";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.BatchPredictionJob.InputConfig".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.BatchPredictionJob.InputConfig"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InstanceConfig {
        #[prost(string, tag = "1")]
        pub instance_type: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub key_field: ::prost::alloc::string::String,
        #[prost(string, repeated, tag = "3")]
        pub included_fields: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "4")]
        pub excluded_fields: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    impl ::prost::Name for InstanceConfig {
        const NAME: &'static str = "InstanceConfig";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.BatchPredictionJob.InstanceConfig".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.BatchPredictionJob.InstanceConfig"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct OutputConfig {
        #[prost(string, tag = "1")]
        pub predictions_format: ::prost::alloc::string::String,
        #[prost(oneof = "output_config::Destination", tags = "2, 3")]
        pub destination: ::core::option::Option<output_config::Destination>,
    }
    /// Nested message and enum types in `OutputConfig`.
    pub mod output_config {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Destination {
            #[prost(message, tag = "2")]
            GcsDestination(super::super::GcsDestination),
            #[prost(message, tag = "3")]
            BigqueryDestination(super::super::BigQueryDestination),
        }
    }
    impl ::prost::Name for OutputConfig {
        const NAME: &'static str = "OutputConfig";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.BatchPredictionJob.OutputConfig".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.BatchPredictionJob.OutputConfig"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct OutputInfo {
        #[prost(string, tag = "4")]
        pub bigquery_output_table: ::prost::alloc::string::String,
        #[prost(oneof = "output_info::OutputLocation", tags = "1, 2")]
        pub output_location: ::core::option::Option<output_info::OutputLocation>,
    }
    /// Nested message and enum types in `OutputInfo`.
    pub mod output_info {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum OutputLocation {
            #[prost(string, tag = "1")]
            GcsOutputDirectory(::prost::alloc::string::String),
            #[prost(string, tag = "2")]
            BigqueryOutputDataset(::prost::alloc::string::String),
        }
    }
    impl ::prost::Name for OutputInfo {
        const NAME: &'static str = "OutputInfo";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.BatchPredictionJob.OutputInfo".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.BatchPredictionJob.OutputInfo"
                .into()
        }
    }
}
impl ::prost::Name for BatchPredictionJob {
    const NAME: &'static str = "BatchPredictionJob";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.BatchPredictionJob".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchPredictionJob".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Schema {
    #[prost(enumeration = "Type", tag = "1")]
    pub r#type: i32,
    #[prost(string, tag = "7")]
    pub format: ::prost::alloc::string::String,
    #[prost(string, tag = "24")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub description: ::prost::alloc::string::String,
    #[prost(bool, tag = "6")]
    pub nullable: bool,
    #[prost(message, optional, tag = "23")]
    pub default: ::core::option::Option<::prost_types::Value>,
    #[prost(message, optional, boxed, tag = "2")]
    pub items: ::core::option::Option<::prost::alloc::boxed::Box<Schema>>,
    #[prost(int64, tag = "21")]
    pub min_items: i64,
    #[prost(int64, tag = "22")]
    pub max_items: i64,
    #[prost(string, repeated, tag = "9")]
    pub r#enum: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "3")]
    pub properties: ::std::collections::HashMap<::prost::alloc::string::String, Schema>,
    #[prost(string, repeated, tag = "25")]
    pub property_ordering: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "5")]
    pub required: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int64, tag = "14")]
    pub min_properties: i64,
    #[prost(int64, tag = "15")]
    pub max_properties: i64,
    #[prost(double, tag = "16")]
    pub minimum: f64,
    #[prost(double, tag = "17")]
    pub maximum: f64,
    #[prost(int64, tag = "18")]
    pub min_length: i64,
    #[prost(int64, tag = "19")]
    pub max_length: i64,
    #[prost(string, tag = "20")]
    pub pattern: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub example: ::core::option::Option<::prost_types::Value>,
    #[prost(message, repeated, tag = "11")]
    pub any_of: ::prost::alloc::vec::Vec<Schema>,
    #[prost(message, optional, tag = "26")]
    pub additional_properties: ::core::option::Option<::prost_types::Value>,
    #[prost(string, tag = "27")]
    pub r#ref: ::prost::alloc::string::String,
    #[prost(map = "string, message", tag = "28")]
    pub defs: ::std::collections::HashMap<::prost::alloc::string::String, Schema>,
}
impl ::prost::Name for Schema {
    const NAME: &'static str = "Schema";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.Schema".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.Schema".into()
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Type {
    Unspecified = 0,
    String = 1,
    Number = 2,
    Integer = 3,
    Boolean = 4,
    Array = 5,
    Object = 6,
}
impl Type {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "TYPE_UNSPECIFIED",
            Self::String => "STRING",
            Self::Number => "NUMBER",
            Self::Integer => "INTEGER",
            Self::Boolean => "BOOLEAN",
            Self::Array => "ARRAY",
            Self::Object => "OBJECT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "STRING" => Some(Self::String),
            "NUMBER" => Some(Self::Number),
            "INTEGER" => Some(Self::Integer),
            "BOOLEAN" => Some(Self::Boolean),
            "ARRAY" => Some(Self::Array),
            "OBJECT" => Some(Self::Object),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Tool {
    #[prost(message, repeated, tag = "1")]
    pub function_declarations: ::prost::alloc::vec::Vec<FunctionDeclaration>,
    #[prost(message, optional, tag = "2")]
    pub retrieval: ::core::option::Option<Retrieval>,
    #[prost(message, optional, tag = "7")]
    pub google_search: ::core::option::Option<tool::GoogleSearch>,
    #[prost(message, optional, tag = "3")]
    pub google_search_retrieval: ::core::option::Option<GoogleSearchRetrieval>,
    #[prost(message, optional, tag = "5")]
    pub google_maps: ::core::option::Option<GoogleMaps>,
    #[prost(message, optional, tag = "6")]
    pub enterprise_web_search: ::core::option::Option<EnterpriseWebSearch>,
    #[prost(message, optional, tag = "4")]
    pub code_execution: ::core::option::Option<tool::CodeExecution>,
    #[prost(message, optional, tag = "8")]
    pub url_context: ::core::option::Option<UrlContext>,
    #[prost(message, optional, tag = "11")]
    pub computer_use: ::core::option::Option<tool::ComputerUse>,
}
/// Nested message and enum types in `Tool`.
pub mod tool {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GoogleSearch {
        #[prost(string, repeated, tag = "3")]
        pub exclude_domains: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    impl ::prost::Name for GoogleSearch {
        const NAME: &'static str = "GoogleSearch";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.Tool.GoogleSearch".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.Tool.GoogleSearch".into()
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct CodeExecution {}
    impl ::prost::Name for CodeExecution {
        const NAME: &'static str = "CodeExecution";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.Tool.CodeExecution".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.Tool.CodeExecution".into()
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ComputerUse {
        #[prost(enumeration = "computer_use::Environment", tag = "1")]
        pub environment: i32,
    }
    /// Nested message and enum types in `ComputerUse`.
    pub mod computer_use {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Environment {
            Unspecified = 0,
            Browser = 1,
        }
        impl Environment {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "ENVIRONMENT_UNSPECIFIED",
                    Self::Browser => "ENVIRONMENT_BROWSER",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "ENVIRONMENT_UNSPECIFIED" => Some(Self::Unspecified),
                    "ENVIRONMENT_BROWSER" => Some(Self::Browser),
                    _ => None,
                }
            }
        }
    }
    impl ::prost::Name for ComputerUse {
        const NAME: &'static str = "ComputerUse";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.Tool.ComputerUse".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.Tool.ComputerUse".into()
        }
    }
}
impl ::prost::Name for Tool {
    const NAME: &'static str = "Tool";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.Tool".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.Tool".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UrlContext {}
impl ::prost::Name for UrlContext {
    const NAME: &'static str = "UrlContext";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UrlContext".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UrlContext".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FunctionDeclaration {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub parameters: ::core::option::Option<Schema>,
    #[prost(message, optional, tag = "5")]
    pub parameters_json_schema: ::core::option::Option<::prost_types::Value>,
    #[prost(message, optional, tag = "4")]
    pub response: ::core::option::Option<Schema>,
    #[prost(message, optional, tag = "6")]
    pub response_json_schema: ::core::option::Option<::prost_types::Value>,
}
impl ::prost::Name for FunctionDeclaration {
    const NAME: &'static str = "FunctionDeclaration";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.FunctionDeclaration".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.FunctionDeclaration".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FunctionCall {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub args: ::core::option::Option<::prost_types::Struct>,
}
impl ::prost::Name for FunctionCall {
    const NAME: &'static str = "FunctionCall";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.FunctionCall".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.FunctionCall".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FunctionResponse {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub response: ::core::option::Option<::prost_types::Struct>,
}
impl ::prost::Name for FunctionResponse {
    const NAME: &'static str = "FunctionResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.FunctionResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.FunctionResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutableCode {
    #[prost(enumeration = "executable_code::Language", tag = "1")]
    pub language: i32,
    #[prost(string, tag = "2")]
    pub code: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ExecutableCode`.
pub mod executable_code {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Language {
        Unspecified = 0,
        Python = 1,
    }
    impl Language {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "LANGUAGE_UNSPECIFIED",
                Self::Python => "PYTHON",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LANGUAGE_UNSPECIFIED" => Some(Self::Unspecified),
                "PYTHON" => Some(Self::Python),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for ExecutableCode {
    const NAME: &'static str = "ExecutableCode";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ExecutableCode".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExecutableCode".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CodeExecutionResult {
    #[prost(enumeration = "code_execution_result::Outcome", tag = "1")]
    pub outcome: i32,
    #[prost(string, tag = "2")]
    pub output: ::prost::alloc::string::String,
}
/// Nested message and enum types in `CodeExecutionResult`.
pub mod code_execution_result {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Outcome {
        Unspecified = 0,
        Ok = 1,
        Failed = 2,
        DeadlineExceeded = 3,
    }
    impl Outcome {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "OUTCOME_UNSPECIFIED",
                Self::Ok => "OUTCOME_OK",
                Self::Failed => "OUTCOME_FAILED",
                Self::DeadlineExceeded => "OUTCOME_DEADLINE_EXCEEDED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OUTCOME_UNSPECIFIED" => Some(Self::Unspecified),
                "OUTCOME_OK" => Some(Self::Ok),
                "OUTCOME_FAILED" => Some(Self::Failed),
                "OUTCOME_DEADLINE_EXCEEDED" => Some(Self::DeadlineExceeded),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for CodeExecutionResult {
    const NAME: &'static str = "CodeExecutionResult";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CodeExecutionResult".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CodeExecutionResult".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Retrieval {
    #[deprecated]
    #[prost(bool, tag = "3")]
    pub disable_attribution: bool,
    #[prost(oneof = "retrieval::Source", tags = "2, 4")]
    pub source: ::core::option::Option<retrieval::Source>,
}
/// Nested message and enum types in `Retrieval`.
pub mod retrieval {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        #[prost(message, tag = "2")]
        VertexAiSearch(super::VertexAiSearch),
        #[prost(message, tag = "4")]
        VertexRagStore(super::VertexRagStore),
    }
}
impl ::prost::Name for Retrieval {
    const NAME: &'static str = "Retrieval";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.Retrieval".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.Retrieval".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VertexRagStore {
    #[prost(message, repeated, tag = "4")]
    pub rag_resources: ::prost::alloc::vec::Vec<vertex_rag_store::RagResource>,
    #[deprecated]
    #[prost(int32, optional, tag = "2")]
    pub similarity_top_k: ::core::option::Option<i32>,
    #[deprecated]
    #[prost(double, optional, tag = "3")]
    pub vector_distance_threshold: ::core::option::Option<f64>,
    #[prost(message, optional, tag = "6")]
    pub rag_retrieval_config: ::core::option::Option<RagRetrievalConfig>,
}
/// Nested message and enum types in `VertexRagStore`.
pub mod vertex_rag_store {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RagResource {
        #[prost(string, tag = "1")]
        pub rag_corpus: ::prost::alloc::string::String,
        #[prost(string, repeated, tag = "2")]
        pub rag_file_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    impl ::prost::Name for RagResource {
        const NAME: &'static str = "RagResource";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.VertexRagStore.RagResource".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.VertexRagStore.RagResource"
                .into()
        }
    }
}
impl ::prost::Name for VertexRagStore {
    const NAME: &'static str = "VertexRagStore";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.VertexRagStore".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.VertexRagStore".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VertexAiSearch {
    #[prost(string, tag = "1")]
    pub datastore: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub engine: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub max_results: i32,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "5")]
    pub data_store_specs: ::prost::alloc::vec::Vec<vertex_ai_search::DataStoreSpec>,
}
/// Nested message and enum types in `VertexAISearch`.
pub mod vertex_ai_search {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DataStoreSpec {
        #[prost(string, tag = "1")]
        pub data_store: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub filter: ::prost::alloc::string::String,
    }
    impl ::prost::Name for DataStoreSpec {
        const NAME: &'static str = "DataStoreSpec";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.VertexAISearch.DataStoreSpec".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.VertexAISearch.DataStoreSpec"
                .into()
        }
    }
}
impl ::prost::Name for VertexAiSearch {
    const NAME: &'static str = "VertexAISearch";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.VertexAISearch".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.VertexAISearch".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GoogleSearchRetrieval {
    #[prost(message, optional, tag = "2")]
    pub dynamic_retrieval_config: ::core::option::Option<DynamicRetrievalConfig>,
}
impl ::prost::Name for GoogleSearchRetrieval {
    const NAME: &'static str = "GoogleSearchRetrieval";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GoogleSearchRetrieval".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GoogleSearchRetrieval".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GoogleMaps {}
impl ::prost::Name for GoogleMaps {
    const NAME: &'static str = "GoogleMaps";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GoogleMaps".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GoogleMaps".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnterpriseWebSearch {
    #[prost(string, repeated, tag = "1")]
    pub exclude_domains: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for EnterpriseWebSearch {
    const NAME: &'static str = "EnterpriseWebSearch";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.EnterpriseWebSearch".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.EnterpriseWebSearch".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DynamicRetrievalConfig {
    #[prost(enumeration = "dynamic_retrieval_config::Mode", tag = "1")]
    pub mode: i32,
    #[prost(float, optional, tag = "2")]
    pub dynamic_threshold: ::core::option::Option<f32>,
}
/// Nested message and enum types in `DynamicRetrievalConfig`.
pub mod dynamic_retrieval_config {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Mode {
        Unspecified = 0,
        Dynamic = 1,
    }
    impl Mode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "MODE_UNSPECIFIED",
                Self::Dynamic => "MODE_DYNAMIC",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "MODE_DYNAMIC" => Some(Self::Dynamic),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for DynamicRetrievalConfig {
    const NAME: &'static str = "DynamicRetrievalConfig";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DynamicRetrievalConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DynamicRetrievalConfig".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToolConfig {
    #[prost(message, optional, tag = "1")]
    pub function_calling_config: ::core::option::Option<FunctionCallingConfig>,
    #[prost(message, optional, tag = "2")]
    pub retrieval_config: ::core::option::Option<RetrievalConfig>,
}
impl ::prost::Name for ToolConfig {
    const NAME: &'static str = "ToolConfig";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ToolConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolConfig".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FunctionCallingConfig {
    #[prost(enumeration = "function_calling_config::Mode", tag = "1")]
    pub mode: i32,
    #[prost(string, repeated, tag = "2")]
    pub allowed_function_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `FunctionCallingConfig`.
pub mod function_calling_config {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Mode {
        Unspecified = 0,
        Auto = 1,
        Any = 2,
        None = 3,
    }
    impl Mode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "MODE_UNSPECIFIED",
                Self::Auto => "AUTO",
                Self::Any => "ANY",
                Self::None => "NONE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "AUTO" => Some(Self::Auto),
                "ANY" => Some(Self::Any),
                "NONE" => Some(Self::None),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for FunctionCallingConfig {
    const NAME: &'static str = "FunctionCallingConfig";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.FunctionCallingConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.FunctionCallingConfig".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RetrievalConfig {
    #[prost(message, optional, tag = "1")]
    pub lat_lng: ::core::option::Option<super::super::super::r#type::LatLng>,
    #[prost(string, optional, tag = "2")]
    pub language_code: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for RetrievalConfig {
    const NAME: &'static str = "RetrievalConfig";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.RetrievalConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.RetrievalConfig".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RagRetrievalConfig {
    #[prost(int32, tag = "1")]
    pub top_k: i32,
    #[prost(message, optional, tag = "3")]
    pub filter: ::core::option::Option<rag_retrieval_config::Filter>,
    #[prost(message, optional, tag = "4")]
    pub ranking: ::core::option::Option<rag_retrieval_config::Ranking>,
}
/// Nested message and enum types in `RagRetrievalConfig`.
pub mod rag_retrieval_config {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Filter {
        #[prost(string, tag = "2")]
        pub metadata_filter: ::prost::alloc::string::String,
        #[prost(oneof = "filter::VectorDbThreshold", tags = "3, 4")]
        pub vector_db_threshold: ::core::option::Option<filter::VectorDbThreshold>,
    }
    /// Nested message and enum types in `Filter`.
    pub mod filter {
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum VectorDbThreshold {
            #[prost(double, tag = "3")]
            VectorDistanceThreshold(f64),
            #[prost(double, tag = "4")]
            VectorSimilarityThreshold(f64),
        }
    }
    impl ::prost::Name for Filter {
        const NAME: &'static str = "Filter";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.RagRetrievalConfig.Filter".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.RagRetrievalConfig.Filter"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Ranking {
        #[prost(oneof = "ranking::RankingConfig", tags = "1, 3")]
        pub ranking_config: ::core::option::Option<ranking::RankingConfig>,
    }
    /// Nested message and enum types in `Ranking`.
    pub mod ranking {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct RankService {
            #[prost(string, optional, tag = "1")]
            pub model_name: ::core::option::Option<::prost::alloc::string::String>,
        }
        impl ::prost::Name for RankService {
            const NAME: &'static str = "RankService";
            const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "google.cloud.aiplatform.v1.RagRetrievalConfig.Ranking.RankService"
                    .into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.cloud.aiplatform.v1.RagRetrievalConfig.Ranking.RankService"
                    .into()
            }
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct LlmRanker {
            #[prost(string, optional, tag = "1")]
            pub model_name: ::core::option::Option<::prost::alloc::string::String>,
        }
        impl ::prost::Name for LlmRanker {
            const NAME: &'static str = "LlmRanker";
            const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "google.cloud.aiplatform.v1.RagRetrievalConfig.Ranking.LlmRanker".into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.cloud.aiplatform.v1.RagRetrievalConfig.Ranking.LlmRanker"
                    .into()
            }
        }
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum RankingConfig {
            #[prost(message, tag = "1")]
            RankService(RankService),
            #[prost(message, tag = "3")]
            LlmRanker(LlmRanker),
        }
    }
    impl ::prost::Name for Ranking {
        const NAME: &'static str = "Ranking";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.RagRetrievalConfig.Ranking".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.RagRetrievalConfig.Ranking"
                .into()
        }
    }
}
impl ::prost::Name for RagRetrievalConfig {
    const NAME: &'static str = "RagRetrievalConfig";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.RagRetrievalConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.RagRetrievalConfig".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RagEmbeddingModelConfig {
    #[prost(oneof = "rag_embedding_model_config::ModelConfig", tags = "1")]
    pub model_config: ::core::option::Option<rag_embedding_model_config::ModelConfig>,
}
/// Nested message and enum types in `RagEmbeddingModelConfig`.
pub mod rag_embedding_model_config {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct VertexPredictionEndpoint {
        #[prost(string, tag = "1")]
        pub endpoint: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub model: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub model_version_id: ::prost::alloc::string::String,
    }
    impl ::prost::Name for VertexPredictionEndpoint {
        const NAME: &'static str = "VertexPredictionEndpoint";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.RagEmbeddingModelConfig.VertexPredictionEndpoint"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.RagEmbeddingModelConfig.VertexPredictionEndpoint"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ModelConfig {
        #[prost(message, tag = "1")]
        VertexPredictionEndpoint(VertexPredictionEndpoint),
    }
}
impl ::prost::Name for RagEmbeddingModelConfig {
    const NAME: &'static str = "RagEmbeddingModelConfig";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.RagEmbeddingModelConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.RagEmbeddingModelConfig".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RagVectorDbConfig {
    #[prost(message, optional, tag = "5")]
    pub api_auth: ::core::option::Option<ApiAuth>,
    #[prost(message, optional, tag = "7")]
    pub rag_embedding_model_config: ::core::option::Option<RagEmbeddingModelConfig>,
    #[prost(oneof = "rag_vector_db_config::VectorDb", tags = "1, 3, 6")]
    pub vector_db: ::core::option::Option<rag_vector_db_config::VectorDb>,
}
/// Nested message and enum types in `RagVectorDbConfig`.
pub mod rag_vector_db_config {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct RagManagedDb {
        #[prost(oneof = "rag_managed_db::RetrievalStrategy", tags = "1, 2")]
        pub retrieval_strategy: ::core::option::Option<
            rag_managed_db::RetrievalStrategy,
        >,
    }
    /// Nested message and enum types in `RagManagedDb`.
    pub mod rag_managed_db {
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Knn {}
        impl ::prost::Name for Knn {
            const NAME: &'static str = "KNN";
            const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "google.cloud.aiplatform.v1.RagVectorDbConfig.RagManagedDb.KNN".into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.cloud.aiplatform.v1.RagVectorDbConfig.RagManagedDb.KNN"
                    .into()
            }
        }
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Ann {
            #[prost(int32, tag = "1")]
            pub tree_depth: i32,
            #[prost(int32, tag = "2")]
            pub leaf_count: i32,
        }
        impl ::prost::Name for Ann {
            const NAME: &'static str = "ANN";
            const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "google.cloud.aiplatform.v1.RagVectorDbConfig.RagManagedDb.ANN".into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.cloud.aiplatform.v1.RagVectorDbConfig.RagManagedDb.ANN"
                    .into()
            }
        }
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum RetrievalStrategy {
            #[prost(message, tag = "1")]
            Knn(Knn),
            #[prost(message, tag = "2")]
            Ann(Ann),
        }
    }
    impl ::prost::Name for RagManagedDb {
        const NAME: &'static str = "RagManagedDb";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.RagVectorDbConfig.RagManagedDb".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.RagVectorDbConfig.RagManagedDb"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Pinecone {
        #[prost(string, tag = "1")]
        pub index_name: ::prost::alloc::string::String,
    }
    impl ::prost::Name for Pinecone {
        const NAME: &'static str = "Pinecone";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.RagVectorDbConfig.Pinecone".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.RagVectorDbConfig.Pinecone"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct VertexVectorSearch {
        #[prost(string, tag = "1")]
        pub index_endpoint: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub index: ::prost::alloc::string::String,
    }
    impl ::prost::Name for VertexVectorSearch {
        const NAME: &'static str = "VertexVectorSearch";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.RagVectorDbConfig.VertexVectorSearch".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.RagVectorDbConfig.VertexVectorSearch"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum VectorDb {
        #[prost(message, tag = "1")]
        RagManagedDb(RagManagedDb),
        #[prost(message, tag = "3")]
        Pinecone(Pinecone),
        #[prost(message, tag = "6")]
        VertexVectorSearch(VertexVectorSearch),
    }
}
impl ::prost::Name for RagVectorDbConfig {
    const NAME: &'static str = "RagVectorDbConfig";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.RagVectorDbConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.RagVectorDbConfig".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileStatus {
    #[prost(enumeration = "file_status::State", tag = "1")]
    pub state: i32,
    #[prost(string, tag = "2")]
    pub error_status: ::prost::alloc::string::String,
}
/// Nested message and enum types in `FileStatus`.
pub mod file_status {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Active = 1,
        Error = 2,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::Error => "ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "ERROR" => Some(Self::Error),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for FileStatus {
    const NAME: &'static str = "FileStatus";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.FileStatus".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.FileStatus".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VertexAiSearchConfig {
    #[prost(string, tag = "1")]
    pub serving_config: ::prost::alloc::string::String,
}
impl ::prost::Name for VertexAiSearchConfig {
    const NAME: &'static str = "VertexAiSearchConfig";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.VertexAiSearchConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.VertexAiSearchConfig".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CorpusStatus {
    #[prost(enumeration = "corpus_status::State", tag = "1")]
    pub state: i32,
    #[prost(string, tag = "2")]
    pub error_status: ::prost::alloc::string::String,
}
/// Nested message and enum types in `CorpusStatus`.
pub mod corpus_status {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unknown = 0,
        Initialized = 1,
        Active = 2,
        Error = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNKNOWN",
                Self::Initialized => "INITIALIZED",
                Self::Active => "ACTIVE",
                Self::Error => "ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "INITIALIZED" => Some(Self::Initialized),
                "ACTIVE" => Some(Self::Active),
                "ERROR" => Some(Self::Error),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for CorpusStatus {
    const NAME: &'static str = "CorpusStatus";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CorpusStatus".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CorpusStatus".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RagCorpus {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "5")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub corpus_status: ::core::option::Option<CorpusStatus>,
    #[prost(message, optional, tag = "12")]
    pub encryption_spec: ::core::option::Option<EncryptionSpec>,
    #[prost(oneof = "rag_corpus::BackendConfig", tags = "9, 10")]
    pub backend_config: ::core::option::Option<rag_corpus::BackendConfig>,
}
/// Nested message and enum types in `RagCorpus`.
pub mod rag_corpus {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum BackendConfig {
        #[prost(message, tag = "9")]
        VectorDbConfig(super::RagVectorDbConfig),
        #[prost(message, tag = "10")]
        VertexAiSearchConfig(super::VertexAiSearchConfig),
    }
}
impl ::prost::Name for RagCorpus {
    const NAME: &'static str = "RagCorpus";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.RagCorpus".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.RagCorpus".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RagFile {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "13")]
    pub file_status: ::core::option::Option<FileStatus>,
    #[prost(oneof = "rag_file::RagFileSource", tags = "8, 9, 10, 11, 12, 14")]
    pub rag_file_source: ::core::option::Option<rag_file::RagFileSource>,
}
/// Nested message and enum types in `RagFile`.
pub mod rag_file {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum RagFileSource {
        #[prost(message, tag = "8")]
        GcsSource(super::GcsSource),
        #[prost(message, tag = "9")]
        GoogleDriveSource(super::GoogleDriveSource),
        #[prost(message, tag = "10")]
        DirectUploadSource(super::DirectUploadSource),
        #[prost(message, tag = "11")]
        SlackSource(super::SlackSource),
        #[prost(message, tag = "12")]
        JiraSource(super::JiraSource),
        #[prost(message, tag = "14")]
        SharePointSources(super::SharePointSources),
    }
}
impl ::prost::Name for RagFile {
    const NAME: &'static str = "RagFile";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.RagFile".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.RagFile".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RagChunk {
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub page_span: ::core::option::Option<rag_chunk::PageSpan>,
}
/// Nested message and enum types in `RagChunk`.
pub mod rag_chunk {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct PageSpan {
        #[prost(int32, tag = "1")]
        pub first_page: i32,
        #[prost(int32, tag = "2")]
        pub last_page: i32,
    }
    impl ::prost::Name for PageSpan {
        const NAME: &'static str = "PageSpan";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.RagChunk.PageSpan".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.RagChunk.PageSpan".into()
        }
    }
}
impl ::prost::Name for RagChunk {
    const NAME: &'static str = "RagChunk";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.RagChunk".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.RagChunk".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RagFileChunkingConfig {
    #[prost(oneof = "rag_file_chunking_config::ChunkingConfig", tags = "3")]
    pub chunking_config: ::core::option::Option<
        rag_file_chunking_config::ChunkingConfig,
    >,
}
/// Nested message and enum types in `RagFileChunkingConfig`.
pub mod rag_file_chunking_config {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct FixedLengthChunking {
        #[prost(int32, tag = "1")]
        pub chunk_size: i32,
        #[prost(int32, tag = "2")]
        pub chunk_overlap: i32,
    }
    impl ::prost::Name for FixedLengthChunking {
        const NAME: &'static str = "FixedLengthChunking";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.RagFileChunkingConfig.FixedLengthChunking".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.RagFileChunkingConfig.FixedLengthChunking"
                .into()
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum ChunkingConfig {
        #[prost(message, tag = "3")]
        FixedLengthChunking(FixedLengthChunking),
    }
}
impl ::prost::Name for RagFileChunkingConfig {
    const NAME: &'static str = "RagFileChunkingConfig";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.RagFileChunkingConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.RagFileChunkingConfig".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RagFileTransformationConfig {
    #[prost(message, optional, tag = "1")]
    pub rag_file_chunking_config: ::core::option::Option<RagFileChunkingConfig>,
}
impl ::prost::Name for RagFileTransformationConfig {
    const NAME: &'static str = "RagFileTransformationConfig";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.RagFileTransformationConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.RagFileTransformationConfig"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RagFileParsingConfig {
    #[prost(oneof = "rag_file_parsing_config::Parser", tags = "4, 5")]
    pub parser: ::core::option::Option<rag_file_parsing_config::Parser>,
}
/// Nested message and enum types in `RagFileParsingConfig`.
pub mod rag_file_parsing_config {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LayoutParser {
        #[prost(string, tag = "1")]
        pub processor_name: ::prost::alloc::string::String,
        #[prost(int32, tag = "2")]
        pub max_parsing_requests_per_min: i32,
    }
    impl ::prost::Name for LayoutParser {
        const NAME: &'static str = "LayoutParser";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.RagFileParsingConfig.LayoutParser".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.RagFileParsingConfig.LayoutParser"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LlmParser {
        #[prost(string, tag = "1")]
        pub model_name: ::prost::alloc::string::String,
        #[prost(int32, tag = "2")]
        pub max_parsing_requests_per_min: i32,
        #[prost(string, tag = "3")]
        pub custom_parsing_prompt: ::prost::alloc::string::String,
    }
    impl ::prost::Name for LlmParser {
        const NAME: &'static str = "LlmParser";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.RagFileParsingConfig.LlmParser".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.RagFileParsingConfig.LlmParser"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Parser {
        #[prost(message, tag = "4")]
        LayoutParser(LayoutParser),
        #[prost(message, tag = "5")]
        LlmParser(LlmParser),
    }
}
impl ::prost::Name for RagFileParsingConfig {
    const NAME: &'static str = "RagFileParsingConfig";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.RagFileParsingConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.RagFileParsingConfig".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UploadRagFileConfig {
    #[prost(message, optional, tag = "3")]
    pub rag_file_transformation_config: ::core::option::Option<
        RagFileTransformationConfig,
    >,
}
impl ::prost::Name for UploadRagFileConfig {
    const NAME: &'static str = "UploadRagFileConfig";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UploadRagFileConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UploadRagFileConfig".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportRagFilesConfig {
    #[prost(message, optional, tag = "16")]
    pub rag_file_transformation_config: ::core::option::Option<
        RagFileTransformationConfig,
    >,
    #[prost(message, optional, tag = "8")]
    pub rag_file_parsing_config: ::core::option::Option<RagFileParsingConfig>,
    #[prost(int32, tag = "5")]
    pub max_embedding_requests_per_min: i32,
    #[prost(bool, tag = "19")]
    pub rebuild_ann_index: bool,
    #[prost(oneof = "import_rag_files_config::ImportSource", tags = "2, 3, 6, 7, 13")]
    pub import_source: ::core::option::Option<import_rag_files_config::ImportSource>,
    #[prost(oneof = "import_rag_files_config::PartialFailureSink", tags = "11, 12")]
    pub partial_failure_sink: ::core::option::Option<
        import_rag_files_config::PartialFailureSink,
    >,
    #[prost(oneof = "import_rag_files_config::ImportResultSink", tags = "14, 15")]
    pub import_result_sink: ::core::option::Option<
        import_rag_files_config::ImportResultSink,
    >,
}
/// Nested message and enum types in `ImportRagFilesConfig`.
pub mod import_rag_files_config {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ImportSource {
        #[prost(message, tag = "2")]
        GcsSource(super::GcsSource),
        #[prost(message, tag = "3")]
        GoogleDriveSource(super::GoogleDriveSource),
        #[prost(message, tag = "6")]
        SlackSource(super::SlackSource),
        #[prost(message, tag = "7")]
        JiraSource(super::JiraSource),
        #[prost(message, tag = "13")]
        SharePointSources(super::SharePointSources),
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum PartialFailureSink {
        #[prost(message, tag = "11")]
        PartialFailureGcsSink(super::GcsDestination),
        #[prost(message, tag = "12")]
        PartialFailureBigquerySink(super::BigQueryDestination),
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ImportResultSink {
        #[prost(message, tag = "14")]
        ImportResultGcsSink(super::GcsDestination),
        #[prost(message, tag = "15")]
        ImportResultBigquerySink(super::BigQueryDestination),
    }
}
impl ::prost::Name for ImportRagFilesConfig {
    const NAME: &'static str = "ImportRagFilesConfig";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ImportRagFilesConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ImportRagFilesConfig".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RagManagedDbConfig {
    #[prost(oneof = "rag_managed_db_config::Tier", tags = "4, 2, 3")]
    pub tier: ::core::option::Option<rag_managed_db_config::Tier>,
}
/// Nested message and enum types in `RagManagedDbConfig`.
pub mod rag_managed_db_config {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Scaled {}
    impl ::prost::Name for Scaled {
        const NAME: &'static str = "Scaled";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.RagManagedDbConfig.Scaled".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.RagManagedDbConfig.Scaled"
                .into()
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Basic {}
    impl ::prost::Name for Basic {
        const NAME: &'static str = "Basic";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.RagManagedDbConfig.Basic".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.RagManagedDbConfig.Basic"
                .into()
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Unprovisioned {}
    impl ::prost::Name for Unprovisioned {
        const NAME: &'static str = "Unprovisioned";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.RagManagedDbConfig.Unprovisioned".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.RagManagedDbConfig.Unprovisioned"
                .into()
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Tier {
        #[prost(message, tag = "4")]
        Scaled(Scaled),
        #[prost(message, tag = "2")]
        Basic(Basic),
        #[prost(message, tag = "3")]
        Unprovisioned(Unprovisioned),
    }
}
impl ::prost::Name for RagManagedDbConfig {
    const NAME: &'static str = "RagManagedDbConfig";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.RagManagedDbConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.RagManagedDbConfig".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RagEngineConfig {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub rag_managed_db_config: ::core::option::Option<RagManagedDbConfig>,
}
impl ::prost::Name for RagEngineConfig {
    const NAME: &'static str = "RagEngineConfig";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.RagEngineConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.RagEngineConfig".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Content {
    #[prost(string, tag = "1")]
    pub role: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub parts: ::prost::alloc::vec::Vec<Part>,
}
impl ::prost::Name for Content {
    const NAME: &'static str = "Content";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.Content".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.Content".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Part {
    #[prost(bool, tag = "10")]
    pub thought: bool,
    #[prost(bytes = "bytes", tag = "11")]
    pub thought_signature: ::prost::bytes::Bytes,
    #[prost(oneof = "part::Data", tags = "1, 2, 3, 5, 6, 8, 9")]
    pub data: ::core::option::Option<part::Data>,
    #[prost(oneof = "part::Metadata", tags = "4")]
    pub metadata: ::core::option::Option<part::Metadata>,
}
/// Nested message and enum types in `Part`.
pub mod part {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Data {
        #[prost(string, tag = "1")]
        Text(::prost::alloc::string::String),
        #[prost(message, tag = "2")]
        InlineData(super::Blob),
        #[prost(message, tag = "3")]
        FileData(super::FileData),
        #[prost(message, tag = "5")]
        FunctionCall(super::FunctionCall),
        #[prost(message, tag = "6")]
        FunctionResponse(super::FunctionResponse),
        #[prost(message, tag = "8")]
        ExecutableCode(super::ExecutableCode),
        #[prost(message, tag = "9")]
        CodeExecutionResult(super::CodeExecutionResult),
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Metadata {
        #[prost(message, tag = "4")]
        VideoMetadata(super::VideoMetadata),
    }
}
impl ::prost::Name for Part {
    const NAME: &'static str = "Part";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.Part".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.Part".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Blob {
    #[prost(string, tag = "1")]
    pub mime_type: ::prost::alloc::string::String,
    #[prost(bytes = "bytes", tag = "2")]
    pub data: ::prost::bytes::Bytes,
}
impl ::prost::Name for Blob {
    const NAME: &'static str = "Blob";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.Blob".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.Blob".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileData {
    #[prost(string, tag = "1")]
    pub mime_type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub file_uri: ::prost::alloc::string::String,
}
impl ::prost::Name for FileData {
    const NAME: &'static str = "FileData";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.FileData".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.FileData".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VideoMetadata {
    #[prost(message, optional, tag = "1")]
    pub start_offset: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "2")]
    pub end_offset: ::core::option::Option<::prost_types::Duration>,
}
impl ::prost::Name for VideoMetadata {
    const NAME: &'static str = "VideoMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.VideoMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.VideoMetadata".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerationConfig {
    #[prost(float, optional, tag = "1")]
    pub temperature: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "2")]
    pub top_p: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "3")]
    pub top_k: ::core::option::Option<f32>,
    #[prost(int32, optional, tag = "4")]
    pub candidate_count: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "5")]
    pub max_output_tokens: ::core::option::Option<i32>,
    #[prost(string, repeated, tag = "6")]
    pub stop_sequences: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "18")]
    pub response_logprobs: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "7")]
    pub logprobs: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "8")]
    pub presence_penalty: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "9")]
    pub frequency_penalty: ::core::option::Option<f32>,
    #[prost(int32, optional, tag = "12")]
    pub seed: ::core::option::Option<i32>,
    #[prost(string, tag = "13")]
    pub response_mime_type: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "16")]
    pub response_schema: ::core::option::Option<Schema>,
    #[prost(message, optional, tag = "28")]
    pub response_json_schema: ::core::option::Option<::prost_types::Value>,
    #[prost(message, optional, tag = "17")]
    pub routing_config: ::core::option::Option<generation_config::RoutingConfig>,
    #[prost(message, optional, tag = "25")]
    pub thinking_config: ::core::option::Option<generation_config::ThinkingConfig>,
}
/// Nested message and enum types in `GenerationConfig`.
pub mod generation_config {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RoutingConfig {
        #[prost(oneof = "routing_config::RoutingConfig", tags = "1, 2")]
        pub routing_config: ::core::option::Option<routing_config::RoutingConfig>,
    }
    /// Nested message and enum types in `RoutingConfig`.
    pub mod routing_config {
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct AutoRoutingMode {
            #[prost(
                enumeration = "auto_routing_mode::ModelRoutingPreference",
                optional,
                tag = "1"
            )]
            pub model_routing_preference: ::core::option::Option<i32>,
        }
        /// Nested message and enum types in `AutoRoutingMode`.
        pub mod auto_routing_mode {
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum ModelRoutingPreference {
                Unknown = 0,
                PrioritizeQuality = 1,
                Balanced = 2,
                PrioritizeCost = 3,
            }
            impl ModelRoutingPreference {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Unknown => "UNKNOWN",
                        Self::PrioritizeQuality => "PRIORITIZE_QUALITY",
                        Self::Balanced => "BALANCED",
                        Self::PrioritizeCost => "PRIORITIZE_COST",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "UNKNOWN" => Some(Self::Unknown),
                        "PRIORITIZE_QUALITY" => Some(Self::PrioritizeQuality),
                        "BALANCED" => Some(Self::Balanced),
                        "PRIORITIZE_COST" => Some(Self::PrioritizeCost),
                        _ => None,
                    }
                }
            }
        }
        impl ::prost::Name for AutoRoutingMode {
            const NAME: &'static str = "AutoRoutingMode";
            const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "google.cloud.aiplatform.v1.GenerationConfig.RoutingConfig.AutoRoutingMode"
                    .into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.cloud.aiplatform.v1.GenerationConfig.RoutingConfig.AutoRoutingMode"
                    .into()
            }
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct ManualRoutingMode {
            #[prost(string, optional, tag = "1")]
            pub model_name: ::core::option::Option<::prost::alloc::string::String>,
        }
        impl ::prost::Name for ManualRoutingMode {
            const NAME: &'static str = "ManualRoutingMode";
            const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "google.cloud.aiplatform.v1.GenerationConfig.RoutingConfig.ManualRoutingMode"
                    .into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.cloud.aiplatform.v1.GenerationConfig.RoutingConfig.ManualRoutingMode"
                    .into()
            }
        }
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum RoutingConfig {
            #[prost(message, tag = "1")]
            AutoMode(AutoRoutingMode),
            #[prost(message, tag = "2")]
            ManualMode(ManualRoutingMode),
        }
    }
    impl ::prost::Name for RoutingConfig {
        const NAME: &'static str = "RoutingConfig";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.GenerationConfig.RoutingConfig".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.GenerationConfig.RoutingConfig"
                .into()
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ThinkingConfig {
        #[prost(bool, optional, tag = "1")]
        pub include_thoughts: ::core::option::Option<bool>,
        #[prost(int32, optional, tag = "3")]
        pub thinking_budget: ::core::option::Option<i32>,
    }
    impl ::prost::Name for ThinkingConfig {
        const NAME: &'static str = "ThinkingConfig";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.GenerationConfig.ThinkingConfig".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.GenerationConfig.ThinkingConfig"
                .into()
        }
    }
}
impl ::prost::Name for GenerationConfig {
    const NAME: &'static str = "GenerationConfig";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GenerationConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GenerationConfig".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SafetySetting {
    #[prost(enumeration = "HarmCategory", tag = "1")]
    pub category: i32,
    #[prost(enumeration = "safety_setting::HarmBlockThreshold", tag = "2")]
    pub threshold: i32,
    #[prost(enumeration = "safety_setting::HarmBlockMethod", tag = "4")]
    pub method: i32,
}
/// Nested message and enum types in `SafetySetting`.
pub mod safety_setting {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum HarmBlockThreshold {
        Unspecified = 0,
        BlockLowAndAbove = 1,
        BlockMediumAndAbove = 2,
        BlockOnlyHigh = 3,
        BlockNone = 4,
        Off = 5,
    }
    impl HarmBlockThreshold {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "HARM_BLOCK_THRESHOLD_UNSPECIFIED",
                Self::BlockLowAndAbove => "BLOCK_LOW_AND_ABOVE",
                Self::BlockMediumAndAbove => "BLOCK_MEDIUM_AND_ABOVE",
                Self::BlockOnlyHigh => "BLOCK_ONLY_HIGH",
                Self::BlockNone => "BLOCK_NONE",
                Self::Off => "OFF",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "HARM_BLOCK_THRESHOLD_UNSPECIFIED" => Some(Self::Unspecified),
                "BLOCK_LOW_AND_ABOVE" => Some(Self::BlockLowAndAbove),
                "BLOCK_MEDIUM_AND_ABOVE" => Some(Self::BlockMediumAndAbove),
                "BLOCK_ONLY_HIGH" => Some(Self::BlockOnlyHigh),
                "BLOCK_NONE" => Some(Self::BlockNone),
                "OFF" => Some(Self::Off),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum HarmBlockMethod {
        Unspecified = 0,
        Severity = 1,
        Probability = 2,
    }
    impl HarmBlockMethod {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "HARM_BLOCK_METHOD_UNSPECIFIED",
                Self::Severity => "SEVERITY",
                Self::Probability => "PROBABILITY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "HARM_BLOCK_METHOD_UNSPECIFIED" => Some(Self::Unspecified),
                "SEVERITY" => Some(Self::Severity),
                "PROBABILITY" => Some(Self::Probability),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for SafetySetting {
    const NAME: &'static str = "SafetySetting";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SafetySetting".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SafetySetting".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SafetyRating {
    #[prost(enumeration = "HarmCategory", tag = "1")]
    pub category: i32,
    #[prost(enumeration = "safety_rating::HarmProbability", tag = "2")]
    pub probability: i32,
    #[prost(float, tag = "5")]
    pub probability_score: f32,
    #[prost(enumeration = "safety_rating::HarmSeverity", tag = "6")]
    pub severity: i32,
    #[prost(float, tag = "7")]
    pub severity_score: f32,
    #[prost(bool, tag = "3")]
    pub blocked: bool,
}
/// Nested message and enum types in `SafetyRating`.
pub mod safety_rating {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum HarmProbability {
        Unspecified = 0,
        Negligible = 1,
        Low = 2,
        Medium = 3,
        High = 4,
    }
    impl HarmProbability {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "HARM_PROBABILITY_UNSPECIFIED",
                Self::Negligible => "NEGLIGIBLE",
                Self::Low => "LOW",
                Self::Medium => "MEDIUM",
                Self::High => "HIGH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "HARM_PROBABILITY_UNSPECIFIED" => Some(Self::Unspecified),
                "NEGLIGIBLE" => Some(Self::Negligible),
                "LOW" => Some(Self::Low),
                "MEDIUM" => Some(Self::Medium),
                "HIGH" => Some(Self::High),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum HarmSeverity {
        Unspecified = 0,
        Negligible = 1,
        Low = 2,
        Medium = 3,
        High = 4,
    }
    impl HarmSeverity {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "HARM_SEVERITY_UNSPECIFIED",
                Self::Negligible => "HARM_SEVERITY_NEGLIGIBLE",
                Self::Low => "HARM_SEVERITY_LOW",
                Self::Medium => "HARM_SEVERITY_MEDIUM",
                Self::High => "HARM_SEVERITY_HIGH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "HARM_SEVERITY_UNSPECIFIED" => Some(Self::Unspecified),
                "HARM_SEVERITY_NEGLIGIBLE" => Some(Self::Negligible),
                "HARM_SEVERITY_LOW" => Some(Self::Low),
                "HARM_SEVERITY_MEDIUM" => Some(Self::Medium),
                "HARM_SEVERITY_HIGH" => Some(Self::High),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for SafetyRating {
    const NAME: &'static str = "SafetyRating";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SafetyRating".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SafetyRating".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CitationMetadata {
    #[prost(message, repeated, tag = "1")]
    pub citations: ::prost::alloc::vec::Vec<Citation>,
}
impl ::prost::Name for CitationMetadata {
    const NAME: &'static str = "CitationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CitationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CitationMetadata".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Citation {
    #[prost(int32, tag = "1")]
    pub start_index: i32,
    #[prost(int32, tag = "2")]
    pub end_index: i32,
    #[prost(string, tag = "3")]
    pub uri: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub license: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub publication_date: ::core::option::Option<super::super::super::r#type::Date>,
}
impl ::prost::Name for Citation {
    const NAME: &'static str = "Citation";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.Citation".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.Citation".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Candidate {
    #[prost(int32, tag = "1")]
    pub index: i32,
    #[prost(message, optional, tag = "2")]
    pub content: ::core::option::Option<Content>,
    #[prost(double, tag = "8")]
    pub score: f64,
    #[prost(double, tag = "9")]
    pub avg_logprobs: f64,
    #[prost(message, optional, tag = "10")]
    pub logprobs_result: ::core::option::Option<LogprobsResult>,
    #[prost(enumeration = "candidate::FinishReason", tag = "3")]
    pub finish_reason: i32,
    #[prost(message, repeated, tag = "4")]
    pub safety_ratings: ::prost::alloc::vec::Vec<SafetyRating>,
    #[prost(string, optional, tag = "5")]
    pub finish_message: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "6")]
    pub citation_metadata: ::core::option::Option<CitationMetadata>,
    #[prost(message, optional, tag = "7")]
    pub grounding_metadata: ::core::option::Option<GroundingMetadata>,
    #[prost(message, optional, tag = "11")]
    pub url_context_metadata: ::core::option::Option<UrlContextMetadata>,
}
/// Nested message and enum types in `Candidate`.
pub mod candidate {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FinishReason {
        Unspecified = 0,
        Stop = 1,
        MaxTokens = 2,
        Safety = 3,
        Recitation = 4,
        Other = 5,
        Blocklist = 6,
        ProhibitedContent = 7,
        Spii = 8,
        MalformedFunctionCall = 9,
        ModelArmor = 10,
    }
    impl FinishReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "FINISH_REASON_UNSPECIFIED",
                Self::Stop => "STOP",
                Self::MaxTokens => "MAX_TOKENS",
                Self::Safety => "SAFETY",
                Self::Recitation => "RECITATION",
                Self::Other => "OTHER",
                Self::Blocklist => "BLOCKLIST",
                Self::ProhibitedContent => "PROHIBITED_CONTENT",
                Self::Spii => "SPII",
                Self::MalformedFunctionCall => "MALFORMED_FUNCTION_CALL",
                Self::ModelArmor => "MODEL_ARMOR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FINISH_REASON_UNSPECIFIED" => Some(Self::Unspecified),
                "STOP" => Some(Self::Stop),
                "MAX_TOKENS" => Some(Self::MaxTokens),
                "SAFETY" => Some(Self::Safety),
                "RECITATION" => Some(Self::Recitation),
                "OTHER" => Some(Self::Other),
                "BLOCKLIST" => Some(Self::Blocklist),
                "PROHIBITED_CONTENT" => Some(Self::ProhibitedContent),
                "SPII" => Some(Self::Spii),
                "MALFORMED_FUNCTION_CALL" => Some(Self::MalformedFunctionCall),
                "MODEL_ARMOR" => Some(Self::ModelArmor),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for Candidate {
    const NAME: &'static str = "Candidate";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.Candidate".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.Candidate".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UrlContextMetadata {
    #[prost(message, repeated, tag = "1")]
    pub url_metadata: ::prost::alloc::vec::Vec<UrlMetadata>,
}
impl ::prost::Name for UrlContextMetadata {
    const NAME: &'static str = "UrlContextMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UrlContextMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UrlContextMetadata".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UrlMetadata {
    #[prost(string, tag = "1")]
    pub retrieved_url: ::prost::alloc::string::String,
    #[prost(enumeration = "url_metadata::UrlRetrievalStatus", tag = "2")]
    pub url_retrieval_status: i32,
}
/// Nested message and enum types in `UrlMetadata`.
pub mod url_metadata {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UrlRetrievalStatus {
        Unspecified = 0,
        Success = 1,
        Error = 2,
    }
    impl UrlRetrievalStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "URL_RETRIEVAL_STATUS_UNSPECIFIED",
                Self::Success => "URL_RETRIEVAL_STATUS_SUCCESS",
                Self::Error => "URL_RETRIEVAL_STATUS_ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "URL_RETRIEVAL_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "URL_RETRIEVAL_STATUS_SUCCESS" => Some(Self::Success),
                "URL_RETRIEVAL_STATUS_ERROR" => Some(Self::Error),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for UrlMetadata {
    const NAME: &'static str = "UrlMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UrlMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UrlMetadata".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LogprobsResult {
    #[prost(message, repeated, tag = "1")]
    pub top_candidates: ::prost::alloc::vec::Vec<logprobs_result::TopCandidates>,
    #[prost(message, repeated, tag = "2")]
    pub chosen_candidates: ::prost::alloc::vec::Vec<logprobs_result::Candidate>,
}
/// Nested message and enum types in `LogprobsResult`.
pub mod logprobs_result {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Candidate {
        #[prost(string, optional, tag = "1")]
        pub token: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(int32, optional, tag = "3")]
        pub token_id: ::core::option::Option<i32>,
        #[prost(float, optional, tag = "2")]
        pub log_probability: ::core::option::Option<f32>,
    }
    impl ::prost::Name for Candidate {
        const NAME: &'static str = "Candidate";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.LogprobsResult.Candidate".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.LogprobsResult.Candidate"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TopCandidates {
        #[prost(message, repeated, tag = "1")]
        pub candidates: ::prost::alloc::vec::Vec<Candidate>,
    }
    impl ::prost::Name for TopCandidates {
        const NAME: &'static str = "TopCandidates";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.LogprobsResult.TopCandidates".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.LogprobsResult.TopCandidates"
                .into()
        }
    }
}
impl ::prost::Name for LogprobsResult {
    const NAME: &'static str = "LogprobsResult";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.LogprobsResult".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.LogprobsResult".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Segment {
    #[prost(int32, tag = "1")]
    pub part_index: i32,
    #[prost(int32, tag = "2")]
    pub start_index: i32,
    #[prost(int32, tag = "3")]
    pub end_index: i32,
    #[prost(string, tag = "4")]
    pub text: ::prost::alloc::string::String,
}
impl ::prost::Name for Segment {
    const NAME: &'static str = "Segment";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.Segment".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.Segment".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroundingChunk {
    #[prost(oneof = "grounding_chunk::ChunkType", tags = "1, 2, 3")]
    pub chunk_type: ::core::option::Option<grounding_chunk::ChunkType>,
}
/// Nested message and enum types in `GroundingChunk`.
pub mod grounding_chunk {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Web {
        #[prost(string, optional, tag = "1")]
        pub uri: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag = "2")]
        pub title: ::core::option::Option<::prost::alloc::string::String>,
    }
    impl ::prost::Name for Web {
        const NAME: &'static str = "Web";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.GroundingChunk.Web".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.GroundingChunk.Web".into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RetrievedContext {
        #[prost(string, optional, tag = "1")]
        pub uri: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag = "2")]
        pub title: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag = "3")]
        pub text: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag = "6")]
        pub document_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(oneof = "retrieved_context::ContextDetails", tags = "4")]
        pub context_details: ::core::option::Option<retrieved_context::ContextDetails>,
    }
    /// Nested message and enum types in `RetrievedContext`.
    pub mod retrieved_context {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum ContextDetails {
            #[prost(message, tag = "4")]
            RagChunk(super::super::RagChunk),
        }
    }
    impl ::prost::Name for RetrievedContext {
        const NAME: &'static str = "RetrievedContext";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.GroundingChunk.RetrievedContext".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.GroundingChunk.RetrievedContext"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Maps {
        #[prost(string, optional, tag = "1")]
        pub uri: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag = "2")]
        pub title: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag = "3")]
        pub text: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag = "4")]
        pub place_id: ::core::option::Option<::prost::alloc::string::String>,
    }
    impl ::prost::Name for Maps {
        const NAME: &'static str = "Maps";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.GroundingChunk.Maps".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.GroundingChunk.Maps".into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ChunkType {
        #[prost(message, tag = "1")]
        Web(Web),
        #[prost(message, tag = "2")]
        RetrievedContext(RetrievedContext),
        #[prost(message, tag = "3")]
        Maps(Maps),
    }
}
impl ::prost::Name for GroundingChunk {
    const NAME: &'static str = "GroundingChunk";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GroundingChunk".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GroundingChunk".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroundingSupport {
    #[prost(message, optional, tag = "1")]
    pub segment: ::core::option::Option<Segment>,
    #[prost(int32, repeated, tag = "2")]
    pub grounding_chunk_indices: ::prost::alloc::vec::Vec<i32>,
    #[prost(float, repeated, tag = "3")]
    pub confidence_scores: ::prost::alloc::vec::Vec<f32>,
}
impl ::prost::Name for GroundingSupport {
    const NAME: &'static str = "GroundingSupport";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GroundingSupport".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GroundingSupport".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroundingMetadata {
    #[prost(string, repeated, tag = "1")]
    pub web_search_queries: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "4")]
    pub search_entry_point: ::core::option::Option<SearchEntryPoint>,
    #[prost(message, repeated, tag = "5")]
    pub grounding_chunks: ::prost::alloc::vec::Vec<GroundingChunk>,
    #[prost(message, repeated, tag = "6")]
    pub grounding_supports: ::prost::alloc::vec::Vec<GroundingSupport>,
    #[prost(message, optional, tag = "7")]
    pub retrieval_metadata: ::core::option::Option<RetrievalMetadata>,
    #[prost(string, optional, tag = "8")]
    pub google_maps_widget_context_token: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
}
impl ::prost::Name for GroundingMetadata {
    const NAME: &'static str = "GroundingMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GroundingMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GroundingMetadata".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchEntryPoint {
    #[prost(string, tag = "1")]
    pub rendered_content: ::prost::alloc::string::String,
    #[prost(bytes = "bytes", tag = "2")]
    pub sdk_blob: ::prost::bytes::Bytes,
}
impl ::prost::Name for SearchEntryPoint {
    const NAME: &'static str = "SearchEntryPoint";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SearchEntryPoint".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SearchEntryPoint".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RetrievalMetadata {
    #[prost(float, tag = "2")]
    pub google_search_dynamic_retrieval_score: f32,
}
impl ::prost::Name for RetrievalMetadata {
    const NAME: &'static str = "RetrievalMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.RetrievalMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.RetrievalMetadata".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModelArmorConfig {
    #[prost(string, tag = "1")]
    pub prompt_template_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub response_template_name: ::prost::alloc::string::String,
}
impl ::prost::Name for ModelArmorConfig {
    const NAME: &'static str = "ModelArmorConfig";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ModelArmorConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ModelArmorConfig".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ModalityTokenCount {
    #[prost(enumeration = "Modality", tag = "1")]
    pub modality: i32,
    #[prost(int32, tag = "2")]
    pub token_count: i32,
}
impl ::prost::Name for ModalityTokenCount {
    const NAME: &'static str = "ModalityTokenCount";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ModalityTokenCount".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ModalityTokenCount".into()
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HarmCategory {
    Unspecified = 0,
    HateSpeech = 1,
    DangerousContent = 2,
    Harassment = 3,
    SexuallyExplicit = 4,
    CivicIntegrity = 5,
}
impl HarmCategory {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "HARM_CATEGORY_UNSPECIFIED",
            Self::HateSpeech => "HARM_CATEGORY_HATE_SPEECH",
            Self::DangerousContent => "HARM_CATEGORY_DANGEROUS_CONTENT",
            Self::Harassment => "HARM_CATEGORY_HARASSMENT",
            Self::SexuallyExplicit => "HARM_CATEGORY_SEXUALLY_EXPLICIT",
            Self::CivicIntegrity => "HARM_CATEGORY_CIVIC_INTEGRITY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HARM_CATEGORY_UNSPECIFIED" => Some(Self::Unspecified),
            "HARM_CATEGORY_HATE_SPEECH" => Some(Self::HateSpeech),
            "HARM_CATEGORY_DANGEROUS_CONTENT" => Some(Self::DangerousContent),
            "HARM_CATEGORY_HARASSMENT" => Some(Self::Harassment),
            "HARM_CATEGORY_SEXUALLY_EXPLICIT" => Some(Self::SexuallyExplicit),
            "HARM_CATEGORY_CIVIC_INTEGRITY" => Some(Self::CivicIntegrity),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Modality {
    Unspecified = 0,
    Text = 1,
    Image = 2,
    Video = 3,
    Audio = 4,
    Document = 5,
}
impl Modality {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "MODALITY_UNSPECIFIED",
            Self::Text => "TEXT",
            Self::Image => "IMAGE",
            Self::Video => "VIDEO",
            Self::Audio => "AUDIO",
            Self::Document => "DOCUMENT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MODALITY_UNSPECIFIED" => Some(Self::Unspecified),
            "TEXT" => Some(Self::Text),
            "IMAGE" => Some(Self::Image),
            "VIDEO" => Some(Self::Video),
            "AUDIO" => Some(Self::Audio),
            "DOCUMENT" => Some(Self::Document),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CachedContent {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub model: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub system_instruction: ::core::option::Option<Content>,
    #[prost(message, repeated, tag = "4")]
    pub contents: ::prost::alloc::vec::Vec<Content>,
    #[prost(message, repeated, tag = "5")]
    pub tools: ::prost::alloc::vec::Vec<Tool>,
    #[prost(message, optional, tag = "6")]
    pub tool_config: ::core::option::Option<ToolConfig>,
    #[prost(message, optional, tag = "7")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "12")]
    pub usage_metadata: ::core::option::Option<cached_content::UsageMetadata>,
    #[prost(message, optional, tag = "13")]
    pub encryption_spec: ::core::option::Option<EncryptionSpec>,
    #[prost(oneof = "cached_content::Expiration", tags = "9, 10")]
    pub expiration: ::core::option::Option<cached_content::Expiration>,
}
/// Nested message and enum types in `CachedContent`.
pub mod cached_content {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UsageMetadata {
        #[prost(int32, tag = "1")]
        pub total_token_count: i32,
        #[prost(int32, tag = "2")]
        pub text_count: i32,
        #[prost(int32, tag = "3")]
        pub image_count: i32,
        #[prost(int32, tag = "4")]
        pub video_duration_seconds: i32,
        #[prost(int32, tag = "5")]
        pub audio_duration_seconds: i32,
    }
    impl ::prost::Name for UsageMetadata {
        const NAME: &'static str = "UsageMetadata";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.CachedContent.UsageMetadata".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.CachedContent.UsageMetadata"
                .into()
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Expiration {
        #[prost(message, tag = "9")]
        ExpireTime(::prost_types::Timestamp),
        #[prost(message, tag = "10")]
        Ttl(::prost_types::Duration),
    }
}
impl ::prost::Name for CachedContent {
    const NAME: &'static str = "CachedContent";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CachedContent".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CachedContent".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Context {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub etag: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "9")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "10")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "11")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, repeated, tag = "12")]
    pub parent_contexts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "13")]
    pub schema_title: ::prost::alloc::string::String,
    #[prost(string, tag = "14")]
    pub schema_version: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "15")]
    pub metadata: ::core::option::Option<::prost_types::Struct>,
    #[prost(string, tag = "16")]
    pub description: ::prost::alloc::string::String,
}
impl ::prost::Name for Context {
    const NAME: &'static str = "Context";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.Context".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.Context".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PscAutomationConfig {
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub network: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub ip_address: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub forwarding_rule: ::prost::alloc::string::String,
    #[prost(enumeration = "PscAutomationState", tag = "5")]
    pub state: i32,
    #[prost(string, tag = "6")]
    pub error_message: ::prost::alloc::string::String,
}
impl ::prost::Name for PscAutomationConfig {
    const NAME: &'static str = "PSCAutomationConfig";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.PSCAutomationConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.PSCAutomationConfig".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrivateServiceConnectConfig {
    #[prost(bool, tag = "1")]
    pub enable_private_service_connect: bool,
    #[prost(string, repeated, tag = "2")]
    pub project_allowlist: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "3")]
    pub psc_automation_configs: ::prost::alloc::vec::Vec<PscAutomationConfig>,
    #[prost(string, tag = "5")]
    pub service_attachment: ::prost::alloc::string::String,
}
impl ::prost::Name for PrivateServiceConnectConfig {
    const NAME: &'static str = "PrivateServiceConnectConfig";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.PrivateServiceConnectConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.PrivateServiceConnectConfig"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PscAutomatedEndpoints {
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub network: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub match_address: ::prost::alloc::string::String,
}
impl ::prost::Name for PscAutomatedEndpoints {
    const NAME: &'static str = "PscAutomatedEndpoints";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.PscAutomatedEndpoints".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.PscAutomatedEndpoints".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PscInterfaceConfig {
    #[prost(string, tag = "1")]
    pub network_attachment: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub dns_peering_configs: ::prost::alloc::vec::Vec<DnsPeeringConfig>,
}
impl ::prost::Name for PscInterfaceConfig {
    const NAME: &'static str = "PscInterfaceConfig";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.PscInterfaceConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.PscInterfaceConfig".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DnsPeeringConfig {
    #[prost(string, tag = "1")]
    pub domain: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub target_project: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub target_network: ::prost::alloc::string::String,
}
impl ::prost::Name for DnsPeeringConfig {
    const NAME: &'static str = "DnsPeeringConfig";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DnsPeeringConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DnsPeeringConfig".into()
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PscAutomationState {
    Unspecified = 0,
    Successful = 1,
    Failed = 2,
}
impl PscAutomationState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PSC_AUTOMATION_STATE_UNSPECIFIED",
            Self::Successful => "PSC_AUTOMATION_STATE_SUCCESSFUL",
            Self::Failed => "PSC_AUTOMATION_STATE_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PSC_AUTOMATION_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "PSC_AUTOMATION_STATE_SUCCESSFUL" => Some(Self::Successful),
            "PSC_AUTOMATION_STATE_FAILED" => Some(Self::Failed),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomJob {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub job_spec: ::core::option::Option<CustomJobSpec>,
    #[prost(enumeration = "JobState", tag = "5")]
    pub state: i32,
    #[prost(message, optional, tag = "6")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "10")]
    pub error: ::core::option::Option<super::super::super::rpc::Status>,
    #[prost(map = "string, string", tag = "11")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "12")]
    pub encryption_spec: ::core::option::Option<EncryptionSpec>,
    #[prost(map = "string, string", tag = "16")]
    pub web_access_uris: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(bool, tag = "18")]
    pub satisfies_pzs: bool,
    #[prost(bool, tag = "19")]
    pub satisfies_pzi: bool,
}
impl ::prost::Name for CustomJob {
    const NAME: &'static str = "CustomJob";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CustomJob".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CustomJob".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomJobSpec {
    #[prost(string, tag = "14")]
    pub persistent_resource_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "1")]
    pub worker_pool_specs: ::prost::alloc::vec::Vec<WorkerPoolSpec>,
    #[prost(message, optional, tag = "3")]
    pub scheduling: ::core::option::Option<Scheduling>,
    #[prost(string, tag = "4")]
    pub service_account: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub network: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "13")]
    pub reserved_ip_ranges: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "21")]
    pub psc_interface_config: ::core::option::Option<PscInterfaceConfig>,
    #[prost(message, optional, tag = "6")]
    pub base_output_directory: ::core::option::Option<GcsDestination>,
    #[prost(string, tag = "19")]
    pub protected_artifact_location_id: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub tensorboard: ::prost::alloc::string::String,
    #[prost(bool, tag = "10")]
    pub enable_web_access: bool,
    #[prost(bool, tag = "16")]
    pub enable_dashboard_access: bool,
    #[prost(string, tag = "17")]
    pub experiment: ::prost::alloc::string::String,
    #[prost(string, tag = "18")]
    pub experiment_run: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "20")]
    pub models: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for CustomJobSpec {
    const NAME: &'static str = "CustomJobSpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CustomJobSpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CustomJobSpec".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkerPoolSpec {
    #[prost(message, optional, tag = "1")]
    pub machine_spec: ::core::option::Option<MachineSpec>,
    #[prost(int64, tag = "2")]
    pub replica_count: i64,
    #[prost(message, repeated, tag = "4")]
    pub nfs_mounts: ::prost::alloc::vec::Vec<NfsMount>,
    #[prost(message, optional, tag = "5")]
    pub disk_spec: ::core::option::Option<DiskSpec>,
    #[prost(oneof = "worker_pool_spec::Task", tags = "6, 7")]
    pub task: ::core::option::Option<worker_pool_spec::Task>,
}
/// Nested message and enum types in `WorkerPoolSpec`.
pub mod worker_pool_spec {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Task {
        #[prost(message, tag = "6")]
        ContainerSpec(super::ContainerSpec),
        #[prost(message, tag = "7")]
        PythonPackageSpec(super::PythonPackageSpec),
    }
}
impl ::prost::Name for WorkerPoolSpec {
    const NAME: &'static str = "WorkerPoolSpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.WorkerPoolSpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.WorkerPoolSpec".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContainerSpec {
    #[prost(string, tag = "1")]
    pub image_uri: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub command: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "3")]
    pub args: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "4")]
    pub env: ::prost::alloc::vec::Vec<EnvVar>,
}
impl ::prost::Name for ContainerSpec {
    const NAME: &'static str = "ContainerSpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ContainerSpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ContainerSpec".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PythonPackageSpec {
    #[prost(string, tag = "1")]
    pub executor_image_uri: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub package_uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "3")]
    pub python_module: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "4")]
    pub args: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "5")]
    pub env: ::prost::alloc::vec::Vec<EnvVar>,
}
impl ::prost::Name for PythonPackageSpec {
    const NAME: &'static str = "PythonPackageSpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.PythonPackageSpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.PythonPackageSpec".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Scheduling {
    #[prost(message, optional, tag = "1")]
    pub timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(bool, tag = "3")]
    pub restart_job_on_worker_restart: bool,
    #[prost(enumeration = "scheduling::Strategy", tag = "4")]
    pub strategy: i32,
    #[prost(bool, tag = "5")]
    pub disable_retries: bool,
    #[prost(message, optional, tag = "6")]
    pub max_wait_duration: ::core::option::Option<::prost_types::Duration>,
}
/// Nested message and enum types in `Scheduling`.
pub mod scheduling {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Strategy {
        Unspecified = 0,
        OnDemand = 1,
        LowCost = 2,
        Standard = 3,
        Spot = 4,
        FlexStart = 6,
    }
    impl Strategy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STRATEGY_UNSPECIFIED",
                Self::OnDemand => "ON_DEMAND",
                Self::LowCost => "LOW_COST",
                Self::Standard => "STANDARD",
                Self::Spot => "SPOT",
                Self::FlexStart => "FLEX_START",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STRATEGY_UNSPECIFIED" => Some(Self::Unspecified),
                "ON_DEMAND" => Some(Self::OnDemand),
                "LOW_COST" => Some(Self::LowCost),
                "STANDARD" => Some(Self::Standard),
                "SPOT" => Some(Self::Spot),
                "FLEX_START" => Some(Self::FlexStart),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for Scheduling {
    const NAME: &'static str = "Scheduling";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.Scheduling".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.Scheduling".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateSyntheticDataRequest {
    #[prost(string, tag = "1")]
    pub location: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub count: i32,
    #[prost(message, repeated, tag = "4")]
    pub output_field_specs: ::prost::alloc::vec::Vec<OutputFieldSpec>,
    #[prost(message, repeated, tag = "5")]
    pub examples: ::prost::alloc::vec::Vec<SyntheticExample>,
    #[prost(oneof = "generate_synthetic_data_request::Strategy", tags = "3")]
    pub strategy: ::core::option::Option<generate_synthetic_data_request::Strategy>,
}
/// Nested message and enum types in `GenerateSyntheticDataRequest`.
pub mod generate_synthetic_data_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Strategy {
        #[prost(message, tag = "3")]
        TaskDescription(super::TaskDescriptionStrategy),
    }
}
impl ::prost::Name for GenerateSyntheticDataRequest {
    const NAME: &'static str = "GenerateSyntheticDataRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GenerateSyntheticDataRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GenerateSyntheticDataRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyntheticField {
    #[prost(string, tag = "1")]
    pub field_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub content: ::core::option::Option<Content>,
}
impl ::prost::Name for SyntheticField {
    const NAME: &'static str = "SyntheticField";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SyntheticField".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SyntheticField".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyntheticExample {
    #[prost(message, repeated, tag = "1")]
    pub fields: ::prost::alloc::vec::Vec<SyntheticField>,
}
impl ::prost::Name for SyntheticExample {
    const NAME: &'static str = "SyntheticExample";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SyntheticExample".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SyntheticExample".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OutputFieldSpec {
    #[prost(string, tag = "1")]
    pub field_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub guidance: ::prost::alloc::string::String,
    #[prost(enumeration = "output_field_spec::FieldType", tag = "3")]
    pub field_type: i32,
}
/// Nested message and enum types in `OutputFieldSpec`.
pub mod output_field_spec {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FieldType {
        Unspecified = 0,
        Content = 1,
        Text = 2,
        Image = 3,
        Audio = 4,
    }
    impl FieldType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "FIELD_TYPE_UNSPECIFIED",
                Self::Content => "CONTENT",
                Self::Text => "TEXT",
                Self::Image => "IMAGE",
                Self::Audio => "AUDIO",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FIELD_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "CONTENT" => Some(Self::Content),
                "TEXT" => Some(Self::Text),
                "IMAGE" => Some(Self::Image),
                "AUDIO" => Some(Self::Audio),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for OutputFieldSpec {
    const NAME: &'static str = "OutputFieldSpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.OutputFieldSpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.OutputFieldSpec".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskDescriptionStrategy {
    #[prost(string, tag = "1")]
    pub task_description: ::prost::alloc::string::String,
}
impl ::prost::Name for TaskDescriptionStrategy {
    const NAME: &'static str = "TaskDescriptionStrategy";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.TaskDescriptionStrategy".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.TaskDescriptionStrategy".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateSyntheticDataResponse {
    #[prost(message, repeated, tag = "1")]
    pub synthetic_examples: ::prost::alloc::vec::Vec<SyntheticExample>,
}
impl ::prost::Name for GenerateSyntheticDataResponse {
    const NAME: &'static str = "GenerateSyntheticDataResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GenerateSyntheticDataResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GenerateSyntheticDataResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataItem {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "3")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "4")]
    pub payload: ::core::option::Option<::prost_types::Value>,
    #[prost(string, tag = "7")]
    pub etag: ::prost::alloc::string::String,
    #[prost(bool, tag = "10")]
    pub satisfies_pzs: bool,
    #[prost(bool, tag = "11")]
    pub satisfies_pzi: bool,
}
impl ::prost::Name for DataItem {
    const NAME: &'static str = "DataItem";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DataItem".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DataItem".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataLabelingJob {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub datasets: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(map = "string, string", tag = "12")]
    pub annotation_labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(int32, tag = "4")]
    pub labeler_count: i32,
    #[prost(string, tag = "5")]
    pub instruction_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub inputs_schema_uri: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "7")]
    pub inputs: ::core::option::Option<::prost_types::Value>,
    #[prost(enumeration = "JobState", tag = "8")]
    pub state: i32,
    #[prost(int32, tag = "13")]
    pub labeling_progress: i32,
    #[prost(message, optional, tag = "14")]
    pub current_spend: ::core::option::Option<super::super::super::r#type::Money>,
    #[prost(message, optional, tag = "9")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "10")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "22")]
    pub error: ::core::option::Option<super::super::super::rpc::Status>,
    #[prost(map = "string, string", tag = "11")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, repeated, tag = "16")]
    pub specialist_pools: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "20")]
    pub encryption_spec: ::core::option::Option<EncryptionSpec>,
    #[prost(message, optional, tag = "21")]
    pub active_learning_config: ::core::option::Option<ActiveLearningConfig>,
}
impl ::prost::Name for DataLabelingJob {
    const NAME: &'static str = "DataLabelingJob";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DataLabelingJob".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DataLabelingJob".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ActiveLearningConfig {
    #[prost(message, optional, tag = "3")]
    pub sample_config: ::core::option::Option<SampleConfig>,
    #[prost(message, optional, tag = "4")]
    pub training_config: ::core::option::Option<TrainingConfig>,
    #[prost(oneof = "active_learning_config::HumanLabelingBudget", tags = "1, 2")]
    pub human_labeling_budget: ::core::option::Option<
        active_learning_config::HumanLabelingBudget,
    >,
}
/// Nested message and enum types in `ActiveLearningConfig`.
pub mod active_learning_config {
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum HumanLabelingBudget {
        #[prost(int64, tag = "1")]
        MaxDataItemCount(i64),
        #[prost(int32, tag = "2")]
        MaxDataItemPercentage(i32),
    }
}
impl ::prost::Name for ActiveLearningConfig {
    const NAME: &'static str = "ActiveLearningConfig";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ActiveLearningConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ActiveLearningConfig".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SampleConfig {
    #[prost(enumeration = "sample_config::SampleStrategy", tag = "5")]
    pub sample_strategy: i32,
    #[prost(oneof = "sample_config::InitialBatchSampleSize", tags = "1")]
    pub initial_batch_sample_size: ::core::option::Option<
        sample_config::InitialBatchSampleSize,
    >,
    #[prost(oneof = "sample_config::FollowingBatchSampleSize", tags = "3")]
    pub following_batch_sample_size: ::core::option::Option<
        sample_config::FollowingBatchSampleSize,
    >,
}
/// Nested message and enum types in `SampleConfig`.
pub mod sample_config {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SampleStrategy {
        Unspecified = 0,
        Uncertainty = 1,
    }
    impl SampleStrategy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SAMPLE_STRATEGY_UNSPECIFIED",
                Self::Uncertainty => "UNCERTAINTY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SAMPLE_STRATEGY_UNSPECIFIED" => Some(Self::Unspecified),
                "UNCERTAINTY" => Some(Self::Uncertainty),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum InitialBatchSampleSize {
        #[prost(int32, tag = "1")]
        InitialBatchSamplePercentage(i32),
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum FollowingBatchSampleSize {
        #[prost(int32, tag = "3")]
        FollowingBatchSamplePercentage(i32),
    }
}
impl ::prost::Name for SampleConfig {
    const NAME: &'static str = "SampleConfig";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SampleConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SampleConfig".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TrainingConfig {
    #[prost(int64, tag = "1")]
    pub timeout_training_milli_hours: i64,
}
impl ::prost::Name for TrainingConfig {
    const NAME: &'static str = "TrainingConfig";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.TrainingConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.TrainingConfig".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SavedQuery {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "12")]
    pub metadata: ::core::option::Option<::prost_types::Value>,
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "5")]
    pub annotation_filter: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub problem_type: ::prost::alloc::string::String,
    #[prost(int32, tag = "10")]
    pub annotation_spec_count: i32,
    #[prost(string, tag = "8")]
    pub etag: ::prost::alloc::string::String,
    #[prost(bool, tag = "9")]
    pub support_automl_training: bool,
}
impl ::prost::Name for SavedQuery {
    const NAME: &'static str = "SavedQuery";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SavedQuery".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SavedQuery".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Dataset {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "16")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub metadata_schema_uri: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "8")]
    pub metadata: ::core::option::Option<::prost_types::Value>,
    #[prost(int64, tag = "10")]
    pub data_item_count: i64,
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "5")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "6")]
    pub etag: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "7")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, repeated, tag = "9")]
    pub saved_queries: ::prost::alloc::vec::Vec<SavedQuery>,
    #[prost(message, optional, tag = "11")]
    pub encryption_spec: ::core::option::Option<EncryptionSpec>,
    #[prost(string, tag = "17")]
    pub metadata_artifact: ::prost::alloc::string::String,
    #[prost(string, tag = "18")]
    pub model_reference: ::prost::alloc::string::String,
    #[prost(bool, tag = "19")]
    pub satisfies_pzs: bool,
    #[prost(bool, tag = "20")]
    pub satisfies_pzi: bool,
}
impl ::prost::Name for Dataset {
    const NAME: &'static str = "Dataset";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.Dataset".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.Dataset".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportDataConfig {
    #[prost(map = "string, string", tag = "2")]
    pub data_item_labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(map = "string, string", tag = "3")]
    pub annotation_labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "4")]
    pub import_schema_uri: ::prost::alloc::string::String,
    #[prost(oneof = "import_data_config::Source", tags = "1")]
    pub source: ::core::option::Option<import_data_config::Source>,
}
/// Nested message and enum types in `ImportDataConfig`.
pub mod import_data_config {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        #[prost(message, tag = "1")]
        GcsSource(super::GcsSource),
    }
}
impl ::prost::Name for ImportDataConfig {
    const NAME: &'static str = "ImportDataConfig";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ImportDataConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ImportDataConfig".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportDataConfig {
    #[prost(string, tag = "2")]
    pub annotations_filter: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub saved_query_id: ::prost::alloc::string::String,
    #[prost(string, tag = "12")]
    pub annotation_schema_uri: ::prost::alloc::string::String,
    #[prost(enumeration = "export_data_config::ExportUse", tag = "4")]
    pub export_use: i32,
    #[prost(oneof = "export_data_config::Destination", tags = "1")]
    pub destination: ::core::option::Option<export_data_config::Destination>,
    #[prost(oneof = "export_data_config::Split", tags = "5, 7")]
    pub split: ::core::option::Option<export_data_config::Split>,
}
/// Nested message and enum types in `ExportDataConfig`.
pub mod export_data_config {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExportUse {
        Unspecified = 0,
        CustomCodeTraining = 6,
    }
    impl ExportUse {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "EXPORT_USE_UNSPECIFIED",
                Self::CustomCodeTraining => "CUSTOM_CODE_TRAINING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EXPORT_USE_UNSPECIFIED" => Some(Self::Unspecified),
                "CUSTOM_CODE_TRAINING" => Some(Self::CustomCodeTraining),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Destination {
        #[prost(message, tag = "1")]
        GcsDestination(super::GcsDestination),
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Split {
        #[prost(message, tag = "5")]
        FractionSplit(super::ExportFractionSplit),
        #[prost(message, tag = "7")]
        FilterSplit(super::ExportFilterSplit),
    }
}
impl ::prost::Name for ExportDataConfig {
    const NAME: &'static str = "ExportDataConfig";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ExportDataConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExportDataConfig".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExportFractionSplit {
    #[prost(double, tag = "1")]
    pub training_fraction: f64,
    #[prost(double, tag = "2")]
    pub validation_fraction: f64,
    #[prost(double, tag = "3")]
    pub test_fraction: f64,
}
impl ::prost::Name for ExportFractionSplit {
    const NAME: &'static str = "ExportFractionSplit";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ExportFractionSplit".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExportFractionSplit".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportFilterSplit {
    #[prost(string, tag = "1")]
    pub training_filter: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub validation_filter: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub test_filter: ::prost::alloc::string::String,
}
impl ::prost::Name for ExportFilterSplit {
    const NAME: &'static str = "ExportFilterSplit";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ExportFilterSplit".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExportFilterSplit".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatasetVersion {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "3")]
    pub etag: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub big_query_dataset_name: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "8")]
    pub metadata: ::core::option::Option<::prost_types::Value>,
    #[prost(string, tag = "9")]
    pub model_reference: ::prost::alloc::string::String,
    #[prost(bool, tag = "10")]
    pub satisfies_pzs: bool,
    #[prost(bool, tag = "11")]
    pub satisfies_pzi: bool,
}
impl ::prost::Name for DatasetVersion {
    const NAME: &'static str = "DatasetVersion";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DatasetVersion".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DatasetVersion".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenericOperationMetadata {
    #[prost(message, repeated, tag = "1")]
    pub partial_failures: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
impl ::prost::Name for GenericOperationMetadata {
    const NAME: &'static str = "GenericOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GenericOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GenericOperationMetadata".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for DeleteOperationMetadata {
    const NAME: &'static str = "DeleteOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeleteOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteOperationMetadata".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDatasetRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub dataset: ::core::option::Option<Dataset>,
}
impl ::prost::Name for CreateDatasetRequest {
    const NAME: &'static str = "CreateDatasetRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateDatasetRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateDatasetRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDatasetOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for CreateDatasetOperationMetadata {
    const NAME: &'static str = "CreateDatasetOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateDatasetOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateDatasetOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDatasetRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for GetDatasetRequest {
    const NAME: &'static str = "GetDatasetRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetDatasetRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetDatasetRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDatasetRequest {
    #[prost(message, optional, tag = "1")]
    pub dataset: ::core::option::Option<Dataset>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for UpdateDatasetRequest {
    const NAME: &'static str = "UpdateDatasetRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdateDatasetRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateDatasetRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDatasetVersionRequest {
    #[prost(message, optional, tag = "1")]
    pub dataset_version: ::core::option::Option<DatasetVersion>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for UpdateDatasetVersionRequest {
    const NAME: &'static str = "UpdateDatasetVersionRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdateDatasetVersionRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateDatasetVersionRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDatasetsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(string, tag = "6")]
    pub order_by: ::prost::alloc::string::String,
}
impl ::prost::Name for ListDatasetsRequest {
    const NAME: &'static str = "ListDatasetsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListDatasetsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListDatasetsRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDatasetsResponse {
    #[prost(message, repeated, tag = "1")]
    pub datasets: ::prost::alloc::vec::Vec<Dataset>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListDatasetsResponse {
    const NAME: &'static str = "ListDatasetsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListDatasetsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListDatasetsResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDatasetRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for DeleteDatasetRequest {
    const NAME: &'static str = "DeleteDatasetRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeleteDatasetRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteDatasetRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportDataRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub import_configs: ::prost::alloc::vec::Vec<ImportDataConfig>,
}
impl ::prost::Name for ImportDataRequest {
    const NAME: &'static str = "ImportDataRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ImportDataRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ImportDataRequest".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ImportDataResponse {}
impl ::prost::Name for ImportDataResponse {
    const NAME: &'static str = "ImportDataResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ImportDataResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ImportDataResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportDataOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for ImportDataOperationMetadata {
    const NAME: &'static str = "ImportDataOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ImportDataOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ImportDataOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportDataRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub export_config: ::core::option::Option<ExportDataConfig>,
}
impl ::prost::Name for ExportDataRequest {
    const NAME: &'static str = "ExportDataRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ExportDataRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExportDataRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportDataResponse {
    #[prost(string, repeated, tag = "1")]
    pub exported_files: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    pub data_stats: ::core::option::Option<model::DataStats>,
}
impl ::prost::Name for ExportDataResponse {
    const NAME: &'static str = "ExportDataResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ExportDataResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExportDataResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportDataOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
    #[prost(string, tag = "2")]
    pub gcs_output_directory: ::prost::alloc::string::String,
}
impl ::prost::Name for ExportDataOperationMetadata {
    const NAME: &'static str = "ExportDataOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ExportDataOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExportDataOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDatasetVersionRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub dataset_version: ::core::option::Option<DatasetVersion>,
}
impl ::prost::Name for CreateDatasetVersionRequest {
    const NAME: &'static str = "CreateDatasetVersionRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateDatasetVersionRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateDatasetVersionRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDatasetVersionOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for CreateDatasetVersionOperationMetadata {
    const NAME: &'static str = "CreateDatasetVersionOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateDatasetVersionOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateDatasetVersionOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDatasetVersionRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for DeleteDatasetVersionRequest {
    const NAME: &'static str = "DeleteDatasetVersionRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeleteDatasetVersionRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteDatasetVersionRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDatasetVersionRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for GetDatasetVersionRequest {
    const NAME: &'static str = "GetDatasetVersionRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetDatasetVersionRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetDatasetVersionRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDatasetVersionsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(string, tag = "6")]
    pub order_by: ::prost::alloc::string::String,
}
impl ::prost::Name for ListDatasetVersionsRequest {
    const NAME: &'static str = "ListDatasetVersionsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListDatasetVersionsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListDatasetVersionsRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDatasetVersionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub dataset_versions: ::prost::alloc::vec::Vec<DatasetVersion>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListDatasetVersionsResponse {
    const NAME: &'static str = "ListDatasetVersionsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListDatasetVersionsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListDatasetVersionsResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestoreDatasetVersionRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for RestoreDatasetVersionRequest {
    const NAME: &'static str = "RestoreDatasetVersionRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.RestoreDatasetVersionRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.RestoreDatasetVersionRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestoreDatasetVersionOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for RestoreDatasetVersionOperationMetadata {
    const NAME: &'static str = "RestoreDatasetVersionOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.RestoreDatasetVersionOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.RestoreDatasetVersionOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDataItemsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(string, tag = "6")]
    pub order_by: ::prost::alloc::string::String,
}
impl ::prost::Name for ListDataItemsRequest {
    const NAME: &'static str = "ListDataItemsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListDataItemsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListDataItemsRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDataItemsResponse {
    #[prost(message, repeated, tag = "1")]
    pub data_items: ::prost::alloc::vec::Vec<DataItem>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListDataItemsResponse {
    const NAME: &'static str = "ListDataItemsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListDataItemsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListDataItemsResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchDataItemsRequest {
    #[prost(string, tag = "1")]
    pub dataset: ::prost::alloc::string::String,
    #[deprecated]
    #[prost(string, tag = "2")]
    pub saved_query: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub data_labeling_job: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub data_item_filter: ::prost::alloc::string::String,
    #[deprecated]
    #[prost(string, tag = "5")]
    pub annotations_filter: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "11")]
    pub annotation_filters: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "6")]
    pub field_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(int32, tag = "7")]
    pub annotations_limit: i32,
    #[prost(int32, tag = "8")]
    pub page_size: i32,
    #[deprecated]
    #[prost(string, tag = "9")]
    pub order_by: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(oneof = "search_data_items_request::Order", tags = "12, 13")]
    pub order: ::core::option::Option<search_data_items_request::Order>,
}
/// Nested message and enum types in `SearchDataItemsRequest`.
pub mod search_data_items_request {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct OrderByAnnotation {
        #[prost(string, tag = "1")]
        pub saved_query: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub order_by: ::prost::alloc::string::String,
    }
    impl ::prost::Name for OrderByAnnotation {
        const NAME: &'static str = "OrderByAnnotation";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.SearchDataItemsRequest.OrderByAnnotation".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.SearchDataItemsRequest.OrderByAnnotation"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Order {
        #[prost(string, tag = "12")]
        OrderByDataItem(::prost::alloc::string::String),
        #[prost(message, tag = "13")]
        OrderByAnnotation(OrderByAnnotation),
    }
}
impl ::prost::Name for SearchDataItemsRequest {
    const NAME: &'static str = "SearchDataItemsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SearchDataItemsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SearchDataItemsRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchDataItemsResponse {
    #[prost(message, repeated, tag = "1")]
    pub data_item_views: ::prost::alloc::vec::Vec<DataItemView>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for SearchDataItemsResponse {
    const NAME: &'static str = "SearchDataItemsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SearchDataItemsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SearchDataItemsResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataItemView {
    #[prost(message, optional, tag = "1")]
    pub data_item: ::core::option::Option<DataItem>,
    #[prost(message, repeated, tag = "2")]
    pub annotations: ::prost::alloc::vec::Vec<Annotation>,
    #[prost(bool, tag = "3")]
    pub has_truncated_annotations: bool,
}
impl ::prost::Name for DataItemView {
    const NAME: &'static str = "DataItemView";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DataItemView".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DataItemView".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSavedQueriesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(string, tag = "6")]
    pub order_by: ::prost::alloc::string::String,
}
impl ::prost::Name for ListSavedQueriesRequest {
    const NAME: &'static str = "ListSavedQueriesRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListSavedQueriesRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListSavedQueriesRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSavedQueriesResponse {
    #[prost(message, repeated, tag = "1")]
    pub saved_queries: ::prost::alloc::vec::Vec<SavedQuery>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListSavedQueriesResponse {
    const NAME: &'static str = "ListSavedQueriesResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListSavedQueriesResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListSavedQueriesResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSavedQueryRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for DeleteSavedQueryRequest {
    const NAME: &'static str = "DeleteSavedQueryRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeleteSavedQueryRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteSavedQueryRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAnnotationSpecRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for GetAnnotationSpecRequest {
    const NAME: &'static str = "GetAnnotationSpecRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetAnnotationSpecRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetAnnotationSpecRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAnnotationsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(string, tag = "6")]
    pub order_by: ::prost::alloc::string::String,
}
impl ::prost::Name for ListAnnotationsRequest {
    const NAME: &'static str = "ListAnnotationsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListAnnotationsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListAnnotationsRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAnnotationsResponse {
    #[prost(message, repeated, tag = "1")]
    pub annotations: ::prost::alloc::vec::Vec<Annotation>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListAnnotationsResponse {
    const NAME: &'static str = "ListAnnotationsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListAnnotationsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListAnnotationsResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployedIndexRef {
    #[prost(string, tag = "1")]
    pub index_endpoint: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub deployed_index_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub display_name: ::prost::alloc::string::String,
}
impl ::prost::Name for DeployedIndexRef {
    const NAME: &'static str = "DeployedIndexRef";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeployedIndexRef".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeployedIndexRef".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeploymentResourcePool {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub dedicated_resources: ::core::option::Option<DedicatedResources>,
    #[prost(message, optional, tag = "5")]
    pub encryption_spec: ::core::option::Option<EncryptionSpec>,
    #[prost(string, tag = "6")]
    pub service_account: ::prost::alloc::string::String,
    #[prost(bool, tag = "7")]
    pub disable_container_logging: bool,
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(bool, tag = "8")]
    pub satisfies_pzs: bool,
    #[prost(bool, tag = "9")]
    pub satisfies_pzi: bool,
}
impl ::prost::Name for DeploymentResourcePool {
    const NAME: &'static str = "DeploymentResourcePool";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeploymentResourcePool".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeploymentResourcePool".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Endpoint {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "4")]
    pub deployed_models: ::prost::alloc::vec::Vec<DeployedModel>,
    #[prost(map = "string, int32", tag = "5")]
    pub traffic_split: ::std::collections::HashMap<::prost::alloc::string::String, i32>,
    #[prost(string, tag = "6")]
    pub etag: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "7")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "8")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "10")]
    pub encryption_spec: ::core::option::Option<EncryptionSpec>,
    #[prost(string, tag = "13")]
    pub network: ::prost::alloc::string::String,
    #[deprecated]
    #[prost(bool, tag = "17")]
    pub enable_private_service_connect: bool,
    #[prost(message, optional, tag = "21")]
    pub private_service_connect_config: ::core::option::Option<
        PrivateServiceConnectConfig,
    >,
    #[prost(string, tag = "14")]
    pub model_deployment_monitoring_job: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "18")]
    pub predict_request_response_logging_config: ::core::option::Option<
        PredictRequestResponseLoggingConfig,
    >,
    #[prost(bool, tag = "24")]
    pub dedicated_endpoint_enabled: bool,
    #[prost(string, tag = "25")]
    pub dedicated_endpoint_dns: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "23")]
    pub client_connection_config: ::core::option::Option<ClientConnectionConfig>,
    #[prost(bool, tag = "27")]
    pub satisfies_pzs: bool,
    #[prost(bool, tag = "28")]
    pub satisfies_pzi: bool,
    #[prost(message, optional, tag = "29")]
    pub gen_ai_advanced_features_config: ::core::option::Option<
        GenAiAdvancedFeaturesConfig,
    >,
    #[prost(bool, tag = "30")]
    pub private_model_server_enabled: bool,
}
impl ::prost::Name for Endpoint {
    const NAME: &'static str = "Endpoint";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.Endpoint".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.Endpoint".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployedModel {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub model: ::prost::alloc::string::String,
    #[prost(string, tag = "18")]
    pub model_version_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub explanation_spec: ::core::option::Option<ExplanationSpec>,
    #[prost(bool, tag = "19")]
    pub disable_explanations: bool,
    #[prost(string, tag = "11")]
    pub service_account: ::prost::alloc::string::String,
    #[prost(bool, tag = "15")]
    pub disable_container_logging: bool,
    #[prost(bool, tag = "13")]
    pub enable_access_logging: bool,
    #[prost(message, optional, tag = "14")]
    pub private_endpoints: ::core::option::Option<PrivateEndpoints>,
    #[prost(message, optional, tag = "23")]
    pub faster_deployment_config: ::core::option::Option<FasterDeploymentConfig>,
    #[prost(message, optional, tag = "26")]
    pub status: ::core::option::Option<deployed_model::Status>,
    #[prost(map = "string, string", tag = "28")]
    pub system_labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "29")]
    pub checkpoint_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "30")]
    pub speculative_decoding_spec: ::core::option::Option<SpeculativeDecodingSpec>,
    #[prost(oneof = "deployed_model::PredictionResources", tags = "7, 8, 17")]
    pub prediction_resources: ::core::option::Option<
        deployed_model::PredictionResources,
    >,
}
/// Nested message and enum types in `DeployedModel`.
pub mod deployed_model {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Status {
        #[prost(string, tag = "1")]
        pub message: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub last_update_time: ::core::option::Option<::prost_types::Timestamp>,
        #[prost(int32, tag = "3")]
        pub available_replica_count: i32,
    }
    impl ::prost::Name for Status {
        const NAME: &'static str = "Status";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.DeployedModel.Status".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.DeployedModel.Status".into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum PredictionResources {
        #[prost(message, tag = "7")]
        DedicatedResources(super::DedicatedResources),
        #[prost(message, tag = "8")]
        AutomaticResources(super::AutomaticResources),
        #[prost(string, tag = "17")]
        SharedResources(::prost::alloc::string::String),
    }
}
impl ::prost::Name for DeployedModel {
    const NAME: &'static str = "DeployedModel";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeployedModel".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeployedModel".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrivateEndpoints {
    #[prost(string, tag = "1")]
    pub predict_http_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub explain_http_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub health_http_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub service_attachment: ::prost::alloc::string::String,
}
impl ::prost::Name for PrivateEndpoints {
    const NAME: &'static str = "PrivateEndpoints";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.PrivateEndpoints".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.PrivateEndpoints".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PredictRequestResponseLoggingConfig {
    #[prost(bool, tag = "1")]
    pub enabled: bool,
    #[prost(double, tag = "2")]
    pub sampling_rate: f64,
    #[prost(message, optional, tag = "3")]
    pub bigquery_destination: ::core::option::Option<BigQueryDestination>,
}
impl ::prost::Name for PredictRequestResponseLoggingConfig {
    const NAME: &'static str = "PredictRequestResponseLoggingConfig";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.PredictRequestResponseLoggingConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.PredictRequestResponseLoggingConfig"
            .into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ClientConnectionConfig {
    #[prost(message, optional, tag = "1")]
    pub inference_timeout: ::core::option::Option<::prost_types::Duration>,
}
impl ::prost::Name for ClientConnectionConfig {
    const NAME: &'static str = "ClientConnectionConfig";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ClientConnectionConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ClientConnectionConfig".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FasterDeploymentConfig {
    #[prost(bool, tag = "2")]
    pub fast_tryout_enabled: bool,
}
impl ::prost::Name for FasterDeploymentConfig {
    const NAME: &'static str = "FasterDeploymentConfig";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.FasterDeploymentConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.FasterDeploymentConfig".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GenAiAdvancedFeaturesConfig {
    #[prost(message, optional, tag = "1")]
    pub rag_config: ::core::option::Option<gen_ai_advanced_features_config::RagConfig>,
}
/// Nested message and enum types in `GenAiAdvancedFeaturesConfig`.
pub mod gen_ai_advanced_features_config {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct RagConfig {
        #[prost(bool, tag = "1")]
        pub enable_rag: bool,
    }
    impl ::prost::Name for RagConfig {
        const NAME: &'static str = "RagConfig";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.GenAiAdvancedFeaturesConfig.RagConfig".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.GenAiAdvancedFeaturesConfig.RagConfig"
                .into()
        }
    }
}
impl ::prost::Name for GenAiAdvancedFeaturesConfig {
    const NAME: &'static str = "GenAiAdvancedFeaturesConfig";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GenAiAdvancedFeaturesConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GenAiAdvancedFeaturesConfig"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpeculativeDecodingSpec {
    #[prost(int32, tag = "1")]
    pub speculative_token_count: i32,
    #[prost(oneof = "speculative_decoding_spec::Speculation", tags = "2, 3")]
    pub speculation: ::core::option::Option<speculative_decoding_spec::Speculation>,
}
/// Nested message and enum types in `SpeculativeDecodingSpec`.
pub mod speculative_decoding_spec {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DraftModelSpeculation {
        #[prost(string, tag = "1")]
        pub draft_model: ::prost::alloc::string::String,
    }
    impl ::prost::Name for DraftModelSpeculation {
        const NAME: &'static str = "DraftModelSpeculation";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.SpeculativeDecodingSpec.DraftModelSpeculation"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.SpeculativeDecodingSpec.DraftModelSpeculation"
                .into()
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct NgramSpeculation {
        #[prost(int32, tag = "1")]
        pub ngram_size: i32,
    }
    impl ::prost::Name for NgramSpeculation {
        const NAME: &'static str = "NgramSpeculation";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.SpeculativeDecodingSpec.NgramSpeculation".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.SpeculativeDecodingSpec.NgramSpeculation"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Speculation {
        #[prost(message, tag = "2")]
        DraftModelSpeculation(DraftModelSpeculation),
        #[prost(message, tag = "3")]
        NgramSpeculation(NgramSpeculation),
    }
}
impl ::prost::Name for SpeculativeDecodingSpec {
    const NAME: &'static str = "SpeculativeDecodingSpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SpeculativeDecodingSpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SpeculativeDecodingSpec".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDeploymentResourcePoolRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub deployment_resource_pool: ::core::option::Option<DeploymentResourcePool>,
    #[prost(string, tag = "3")]
    pub deployment_resource_pool_id: ::prost::alloc::string::String,
}
impl ::prost::Name for CreateDeploymentResourcePoolRequest {
    const NAME: &'static str = "CreateDeploymentResourcePoolRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateDeploymentResourcePoolRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateDeploymentResourcePoolRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDeploymentResourcePoolOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for CreateDeploymentResourcePoolOperationMetadata {
    const NAME: &'static str = "CreateDeploymentResourcePoolOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateDeploymentResourcePoolOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateDeploymentResourcePoolOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDeploymentResourcePoolRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for GetDeploymentResourcePoolRequest {
    const NAME: &'static str = "GetDeploymentResourcePoolRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetDeploymentResourcePoolRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetDeploymentResourcePoolRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDeploymentResourcePoolsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListDeploymentResourcePoolsRequest {
    const NAME: &'static str = "ListDeploymentResourcePoolsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListDeploymentResourcePoolsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListDeploymentResourcePoolsRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDeploymentResourcePoolsResponse {
    #[prost(message, repeated, tag = "1")]
    pub deployment_resource_pools: ::prost::alloc::vec::Vec<DeploymentResourcePool>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListDeploymentResourcePoolsResponse {
    const NAME: &'static str = "ListDeploymentResourcePoolsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListDeploymentResourcePoolsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListDeploymentResourcePoolsResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDeploymentResourcePoolRequest {
    #[prost(message, optional, tag = "1")]
    pub deployment_resource_pool: ::core::option::Option<DeploymentResourcePool>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for UpdateDeploymentResourcePoolRequest {
    const NAME: &'static str = "UpdateDeploymentResourcePoolRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdateDeploymentResourcePoolRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateDeploymentResourcePoolRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDeploymentResourcePoolOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for UpdateDeploymentResourcePoolOperationMetadata {
    const NAME: &'static str = "UpdateDeploymentResourcePoolOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdateDeploymentResourcePoolOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateDeploymentResourcePoolOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDeploymentResourcePoolRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for DeleteDeploymentResourcePoolRequest {
    const NAME: &'static str = "DeleteDeploymentResourcePoolRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeleteDeploymentResourcePoolRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteDeploymentResourcePoolRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryDeployedModelsRequest {
    #[prost(string, tag = "1")]
    pub deployment_resource_pool: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for QueryDeployedModelsRequest {
    const NAME: &'static str = "QueryDeployedModelsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.QueryDeployedModelsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.QueryDeployedModelsRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryDeployedModelsResponse {
    #[deprecated]
    #[prost(message, repeated, tag = "1")]
    pub deployed_models: ::prost::alloc::vec::Vec<DeployedModel>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub deployed_model_refs: ::prost::alloc::vec::Vec<DeployedModelRef>,
    #[prost(int32, tag = "4")]
    pub total_deployed_model_count: i32,
    #[prost(int32, tag = "5")]
    pub total_endpoint_count: i32,
}
impl ::prost::Name for QueryDeployedModelsResponse {
    const NAME: &'static str = "QueryDeployedModelsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.QueryDeployedModelsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.QueryDeployedModelsResponse"
            .into()
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DeploymentStage {
    Unspecified = 0,
    StartingDeployment = 5,
    PreparingModel = 6,
    CreatingServingCluster = 7,
    AddingNodesToCluster = 8,
    GettingContainerImage = 9,
    StartingModelServer = 3,
    FinishingUp = 4,
    DeploymentTerminated = 10,
}
impl DeploymentStage {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "DEPLOYMENT_STAGE_UNSPECIFIED",
            Self::StartingDeployment => "STARTING_DEPLOYMENT",
            Self::PreparingModel => "PREPARING_MODEL",
            Self::CreatingServingCluster => "CREATING_SERVING_CLUSTER",
            Self::AddingNodesToCluster => "ADDING_NODES_TO_CLUSTER",
            Self::GettingContainerImage => "GETTING_CONTAINER_IMAGE",
            Self::StartingModelServer => "STARTING_MODEL_SERVER",
            Self::FinishingUp => "FINISHING_UP",
            Self::DeploymentTerminated => "DEPLOYMENT_TERMINATED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DEPLOYMENT_STAGE_UNSPECIFIED" => Some(Self::Unspecified),
            "STARTING_DEPLOYMENT" => Some(Self::StartingDeployment),
            "PREPARING_MODEL" => Some(Self::PreparingModel),
            "CREATING_SERVING_CLUSTER" => Some(Self::CreatingServingCluster),
            "ADDING_NODES_TO_CLUSTER" => Some(Self::AddingNodesToCluster),
            "GETTING_CONTAINER_IMAGE" => Some(Self::GettingContainerImage),
            "STARTING_MODEL_SERVER" => Some(Self::StartingModelServer),
            "FINISHING_UP" => Some(Self::FinishingUp),
            "DEPLOYMENT_TERMINATED" => Some(Self::DeploymentTerminated),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateEndpointRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub endpoint: ::core::option::Option<Endpoint>,
    #[prost(string, tag = "4")]
    pub endpoint_id: ::prost::alloc::string::String,
}
impl ::prost::Name for CreateEndpointRequest {
    const NAME: &'static str = "CreateEndpointRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateEndpointRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateEndpointRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateEndpointOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
    #[prost(enumeration = "DeploymentStage", tag = "2")]
    pub deployment_stage: i32,
}
impl ::prost::Name for CreateEndpointOperationMetadata {
    const NAME: &'static str = "CreateEndpointOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateEndpointOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateEndpointOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEndpointRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for GetEndpointRequest {
    const NAME: &'static str = "GetEndpointRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetEndpointRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetEndpointRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEndpointsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(string, tag = "6")]
    pub order_by: ::prost::alloc::string::String,
}
impl ::prost::Name for ListEndpointsRequest {
    const NAME: &'static str = "ListEndpointsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListEndpointsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListEndpointsRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEndpointsResponse {
    #[prost(message, repeated, tag = "1")]
    pub endpoints: ::prost::alloc::vec::Vec<Endpoint>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListEndpointsResponse {
    const NAME: &'static str = "ListEndpointsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListEndpointsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListEndpointsResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateEndpointRequest {
    #[prost(message, optional, tag = "1")]
    pub endpoint: ::core::option::Option<Endpoint>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for UpdateEndpointRequest {
    const NAME: &'static str = "UpdateEndpointRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdateEndpointRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateEndpointRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateEndpointLongRunningRequest {
    #[prost(message, optional, tag = "1")]
    pub endpoint: ::core::option::Option<Endpoint>,
}
impl ::prost::Name for UpdateEndpointLongRunningRequest {
    const NAME: &'static str = "UpdateEndpointLongRunningRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdateEndpointLongRunningRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateEndpointLongRunningRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateEndpointOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for UpdateEndpointOperationMetadata {
    const NAME: &'static str = "UpdateEndpointOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdateEndpointOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateEndpointOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteEndpointRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for DeleteEndpointRequest {
    const NAME: &'static str = "DeleteEndpointRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeleteEndpointRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteEndpointRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployModelRequest {
    #[prost(string, tag = "1")]
    pub endpoint: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub deployed_model: ::core::option::Option<DeployedModel>,
    #[prost(map = "string, int32", tag = "3")]
    pub traffic_split: ::std::collections::HashMap<::prost::alloc::string::String, i32>,
}
impl ::prost::Name for DeployModelRequest {
    const NAME: &'static str = "DeployModelRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeployModelRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeployModelRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployModelResponse {
    #[prost(message, optional, tag = "1")]
    pub deployed_model: ::core::option::Option<DeployedModel>,
}
impl ::prost::Name for DeployModelResponse {
    const NAME: &'static str = "DeployModelResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeployModelResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeployModelResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployModelOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
    #[prost(enumeration = "DeploymentStage", tag = "2")]
    pub deployment_stage: i32,
}
impl ::prost::Name for DeployModelOperationMetadata {
    const NAME: &'static str = "DeployModelOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeployModelOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeployModelOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UndeployModelRequest {
    #[prost(string, tag = "1")]
    pub endpoint: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub deployed_model_id: ::prost::alloc::string::String,
    #[prost(map = "string, int32", tag = "3")]
    pub traffic_split: ::std::collections::HashMap<::prost::alloc::string::String, i32>,
}
impl ::prost::Name for UndeployModelRequest {
    const NAME: &'static str = "UndeployModelRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UndeployModelRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UndeployModelRequest".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UndeployModelResponse {}
impl ::prost::Name for UndeployModelResponse {
    const NAME: &'static str = "UndeployModelResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UndeployModelResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UndeployModelResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UndeployModelOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for UndeployModelOperationMetadata {
    const NAME: &'static str = "UndeployModelOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UndeployModelOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UndeployModelOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateDeployedModelRequest {
    #[prost(string, tag = "1")]
    pub endpoint: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub deployed_model: ::core::option::Option<DeployedModel>,
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for MutateDeployedModelRequest {
    const NAME: &'static str = "MutateDeployedModelRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.MutateDeployedModelRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.MutateDeployedModelRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateDeployedModelResponse {
    #[prost(message, optional, tag = "1")]
    pub deployed_model: ::core::option::Option<DeployedModel>,
}
impl ::prost::Name for MutateDeployedModelResponse {
    const NAME: &'static str = "MutateDeployedModelResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.MutateDeployedModelResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.MutateDeployedModelResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateDeployedModelOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for MutateDeployedModelOperationMetadata {
    const NAME: &'static str = "MutateDeployedModelOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.MutateDeployedModelOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.MutateDeployedModelOperationMetadata"
            .into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeaturestoreMonitoringConfig {
    #[prost(message, optional, tag = "1")]
    pub snapshot_analysis: ::core::option::Option<
        featurestore_monitoring_config::SnapshotAnalysis,
    >,
    #[prost(message, optional, tag = "2")]
    pub import_features_analysis: ::core::option::Option<
        featurestore_monitoring_config::ImportFeaturesAnalysis,
    >,
    #[prost(message, optional, tag = "3")]
    pub numerical_threshold_config: ::core::option::Option<
        featurestore_monitoring_config::ThresholdConfig,
    >,
    #[prost(message, optional, tag = "4")]
    pub categorical_threshold_config: ::core::option::Option<
        featurestore_monitoring_config::ThresholdConfig,
    >,
}
/// Nested message and enum types in `FeaturestoreMonitoringConfig`.
pub mod featurestore_monitoring_config {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SnapshotAnalysis {
        #[prost(bool, tag = "1")]
        pub disabled: bool,
        #[prost(int32, tag = "3")]
        pub monitoring_interval_days: i32,
        #[prost(int32, tag = "4")]
        pub staleness_days: i32,
    }
    impl ::prost::Name for SnapshotAnalysis {
        const NAME: &'static str = "SnapshotAnalysis";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.FeaturestoreMonitoringConfig.SnapshotAnalysis"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeaturestoreMonitoringConfig.SnapshotAnalysis"
                .into()
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ImportFeaturesAnalysis {
        #[prost(enumeration = "import_features_analysis::State", tag = "1")]
        pub state: i32,
        #[prost(enumeration = "import_features_analysis::Baseline", tag = "2")]
        pub anomaly_detection_baseline: i32,
    }
    /// Nested message and enum types in `ImportFeaturesAnalysis`.
    pub mod import_features_analysis {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum State {
            Unspecified = 0,
            Default = 1,
            Enabled = 2,
            Disabled = 3,
        }
        impl State {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "STATE_UNSPECIFIED",
                    Self::Default => "DEFAULT",
                    Self::Enabled => "ENABLED",
                    Self::Disabled => "DISABLED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                    "DEFAULT" => Some(Self::Default),
                    "ENABLED" => Some(Self::Enabled),
                    "DISABLED" => Some(Self::Disabled),
                    _ => None,
                }
            }
        }
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Baseline {
            Unspecified = 0,
            LatestStats = 1,
            MostRecentSnapshotStats = 2,
            PreviousImportFeaturesStats = 3,
        }
        impl Baseline {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "BASELINE_UNSPECIFIED",
                    Self::LatestStats => "LATEST_STATS",
                    Self::MostRecentSnapshotStats => "MOST_RECENT_SNAPSHOT_STATS",
                    Self::PreviousImportFeaturesStats => "PREVIOUS_IMPORT_FEATURES_STATS",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "BASELINE_UNSPECIFIED" => Some(Self::Unspecified),
                    "LATEST_STATS" => Some(Self::LatestStats),
                    "MOST_RECENT_SNAPSHOT_STATS" => Some(Self::MostRecentSnapshotStats),
                    "PREVIOUS_IMPORT_FEATURES_STATS" => {
                        Some(Self::PreviousImportFeaturesStats)
                    }
                    _ => None,
                }
            }
        }
    }
    impl ::prost::Name for ImportFeaturesAnalysis {
        const NAME: &'static str = "ImportFeaturesAnalysis";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.FeaturestoreMonitoringConfig.ImportFeaturesAnalysis"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeaturestoreMonitoringConfig.ImportFeaturesAnalysis"
                .into()
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ThresholdConfig {
        #[prost(oneof = "threshold_config::Threshold", tags = "1")]
        pub threshold: ::core::option::Option<threshold_config::Threshold>,
    }
    /// Nested message and enum types in `ThresholdConfig`.
    pub mod threshold_config {
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum Threshold {
            #[prost(double, tag = "1")]
            Value(f64),
        }
    }
    impl ::prost::Name for ThresholdConfig {
        const NAME: &'static str = "ThresholdConfig";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.FeaturestoreMonitoringConfig.ThresholdConfig"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeaturestoreMonitoringConfig.ThresholdConfig"
                .into()
        }
    }
}
impl ::prost::Name for FeaturestoreMonitoringConfig {
    const NAME: &'static str = "FeaturestoreMonitoringConfig";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.FeaturestoreMonitoringConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.FeaturestoreMonitoringConfig"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityType {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "6")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "7")]
    pub etag: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "8")]
    pub monitoring_config: ::core::option::Option<FeaturestoreMonitoringConfig>,
    #[prost(int32, tag = "10")]
    pub offline_storage_ttl_days: i32,
    #[prost(bool, tag = "11")]
    pub satisfies_pzs: bool,
    #[prost(bool, tag = "12")]
    pub satisfies_pzi: bool,
}
impl ::prost::Name for EntityType {
    const NAME: &'static str = "EntityType";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.EntityType".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.EntityType".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EvaluatedAnnotation {
    #[prost(enumeration = "evaluated_annotation::EvaluatedAnnotationType", tag = "1")]
    pub r#type: i32,
    #[prost(message, repeated, tag = "2")]
    pub predictions: ::prost::alloc::vec::Vec<::prost_types::Value>,
    #[prost(message, repeated, tag = "3")]
    pub ground_truths: ::prost::alloc::vec::Vec<::prost_types::Value>,
    #[prost(message, optional, tag = "5")]
    pub data_item_payload: ::core::option::Option<::prost_types::Value>,
    #[prost(string, tag = "6")]
    pub evaluated_data_item_view_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "8")]
    pub explanations: ::prost::alloc::vec::Vec<EvaluatedAnnotationExplanation>,
    #[prost(message, repeated, tag = "9")]
    pub error_analysis_annotations: ::prost::alloc::vec::Vec<ErrorAnalysisAnnotation>,
}
/// Nested message and enum types in `EvaluatedAnnotation`.
pub mod evaluated_annotation {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EvaluatedAnnotationType {
        Unspecified = 0,
        TruePositive = 1,
        FalsePositive = 2,
        FalseNegative = 3,
    }
    impl EvaluatedAnnotationType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "EVALUATED_ANNOTATION_TYPE_UNSPECIFIED",
                Self::TruePositive => "TRUE_POSITIVE",
                Self::FalsePositive => "FALSE_POSITIVE",
                Self::FalseNegative => "FALSE_NEGATIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EVALUATED_ANNOTATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "TRUE_POSITIVE" => Some(Self::TruePositive),
                "FALSE_POSITIVE" => Some(Self::FalsePositive),
                "FALSE_NEGATIVE" => Some(Self::FalseNegative),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for EvaluatedAnnotation {
    const NAME: &'static str = "EvaluatedAnnotation";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.EvaluatedAnnotation".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.EvaluatedAnnotation".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EvaluatedAnnotationExplanation {
    #[prost(string, tag = "1")]
    pub explanation_type: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub explanation: ::core::option::Option<Explanation>,
}
impl ::prost::Name for EvaluatedAnnotationExplanation {
    const NAME: &'static str = "EvaluatedAnnotationExplanation";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.EvaluatedAnnotationExplanation".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.EvaluatedAnnotationExplanation"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorAnalysisAnnotation {
    #[prost(message, repeated, tag = "1")]
    pub attributed_items: ::prost::alloc::vec::Vec<
        error_analysis_annotation::AttributedItem,
    >,
    #[prost(enumeration = "error_analysis_annotation::QueryType", tag = "2")]
    pub query_type: i32,
    #[prost(double, tag = "3")]
    pub outlier_score: f64,
    #[prost(double, tag = "4")]
    pub outlier_threshold: f64,
}
/// Nested message and enum types in `ErrorAnalysisAnnotation`.
pub mod error_analysis_annotation {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AttributedItem {
        #[prost(string, tag = "1")]
        pub annotation_resource_name: ::prost::alloc::string::String,
        #[prost(double, tag = "2")]
        pub distance: f64,
    }
    impl ::prost::Name for AttributedItem {
        const NAME: &'static str = "AttributedItem";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.ErrorAnalysisAnnotation.AttributedItem".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.ErrorAnalysisAnnotation.AttributedItem"
                .into()
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum QueryType {
        Unspecified = 0,
        AllSimilar = 1,
        SameClassSimilar = 2,
        SameClassDissimilar = 3,
    }
    impl QueryType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "QUERY_TYPE_UNSPECIFIED",
                Self::AllSimilar => "ALL_SIMILAR",
                Self::SameClassSimilar => "SAME_CLASS_SIMILAR",
                Self::SameClassDissimilar => "SAME_CLASS_DISSIMILAR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "QUERY_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "ALL_SIMILAR" => Some(Self::AllSimilar),
                "SAME_CLASS_SIMILAR" => Some(Self::SameClassSimilar),
                "SAME_CLASS_DISSIMILAR" => Some(Self::SameClassDissimilar),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for ErrorAnalysisAnnotation {
    const NAME: &'static str = "ErrorAnalysisAnnotation";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ErrorAnalysisAnnotation".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ErrorAnalysisAnnotation".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EvaluateInstancesRequest {
    #[prost(string, tag = "1")]
    pub location: ::prost::alloc::string::String,
    #[prost(
        oneof = "evaluate_instances_request::MetricInputs",
        tags = "2, 3, 4, 5, 6, 8, 9, 12, 7, 23, 14, 15, 10, 24, 16, 17, 18, 28, 29, 19, 20, 21, 22, 31, 32"
    )]
    pub metric_inputs: ::core::option::Option<evaluate_instances_request::MetricInputs>,
}
/// Nested message and enum types in `EvaluateInstancesRequest`.
pub mod evaluate_instances_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum MetricInputs {
        #[prost(message, tag = "2")]
        ExactMatchInput(super::ExactMatchInput),
        #[prost(message, tag = "3")]
        BleuInput(super::BleuInput),
        #[prost(message, tag = "4")]
        RougeInput(super::RougeInput),
        #[prost(message, tag = "5")]
        FluencyInput(super::FluencyInput),
        #[prost(message, tag = "6")]
        CoherenceInput(super::CoherenceInput),
        #[prost(message, tag = "8")]
        SafetyInput(super::SafetyInput),
        #[prost(message, tag = "9")]
        GroundednessInput(super::GroundednessInput),
        #[prost(message, tag = "12")]
        FulfillmentInput(super::FulfillmentInput),
        #[prost(message, tag = "7")]
        SummarizationQualityInput(super::SummarizationQualityInput),
        #[prost(message, tag = "23")]
        PairwiseSummarizationQualityInput(super::PairwiseSummarizationQualityInput),
        #[prost(message, tag = "14")]
        SummarizationHelpfulnessInput(super::SummarizationHelpfulnessInput),
        #[prost(message, tag = "15")]
        SummarizationVerbosityInput(super::SummarizationVerbosityInput),
        #[prost(message, tag = "10")]
        QuestionAnsweringQualityInput(super::QuestionAnsweringQualityInput),
        #[prost(message, tag = "24")]
        PairwiseQuestionAnsweringQualityInput(
            super::PairwiseQuestionAnsweringQualityInput,
        ),
        #[prost(message, tag = "16")]
        QuestionAnsweringRelevanceInput(super::QuestionAnsweringRelevanceInput),
        #[prost(message, tag = "17")]
        QuestionAnsweringHelpfulnessInput(super::QuestionAnsweringHelpfulnessInput),
        #[prost(message, tag = "18")]
        QuestionAnsweringCorrectnessInput(super::QuestionAnsweringCorrectnessInput),
        #[prost(message, tag = "28")]
        PointwiseMetricInput(super::PointwiseMetricInput),
        #[prost(message, tag = "29")]
        PairwiseMetricInput(super::PairwiseMetricInput),
        #[prost(message, tag = "19")]
        ToolCallValidInput(super::ToolCallValidInput),
        #[prost(message, tag = "20")]
        ToolNameMatchInput(super::ToolNameMatchInput),
        #[prost(message, tag = "21")]
        ToolParameterKeyMatchInput(super::ToolParameterKeyMatchInput),
        #[prost(message, tag = "22")]
        ToolParameterKvMatchInput(super::ToolParameterKvMatchInput),
        #[prost(message, tag = "31")]
        CometInput(super::CometInput),
        #[prost(message, tag = "32")]
        MetricxInput(super::MetricxInput),
    }
}
impl ::prost::Name for EvaluateInstancesRequest {
    const NAME: &'static str = "EvaluateInstancesRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.EvaluateInstancesRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.EvaluateInstancesRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EvaluateInstancesResponse {
    #[prost(
        oneof = "evaluate_instances_response::EvaluationResults",
        tags = "1, 2, 3, 4, 5, 7, 8, 11, 6, 22, 13, 14, 9, 23, 15, 16, 17, 27, 28, 18, 19, 20, 21, 29, 30"
    )]
    pub evaluation_results: ::core::option::Option<
        evaluate_instances_response::EvaluationResults,
    >,
}
/// Nested message and enum types in `EvaluateInstancesResponse`.
pub mod evaluate_instances_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum EvaluationResults {
        #[prost(message, tag = "1")]
        ExactMatchResults(super::ExactMatchResults),
        #[prost(message, tag = "2")]
        BleuResults(super::BleuResults),
        #[prost(message, tag = "3")]
        RougeResults(super::RougeResults),
        #[prost(message, tag = "4")]
        FluencyResult(super::FluencyResult),
        #[prost(message, tag = "5")]
        CoherenceResult(super::CoherenceResult),
        #[prost(message, tag = "7")]
        SafetyResult(super::SafetyResult),
        #[prost(message, tag = "8")]
        GroundednessResult(super::GroundednessResult),
        #[prost(message, tag = "11")]
        FulfillmentResult(super::FulfillmentResult),
        #[prost(message, tag = "6")]
        SummarizationQualityResult(super::SummarizationQualityResult),
        #[prost(message, tag = "22")]
        PairwiseSummarizationQualityResult(super::PairwiseSummarizationQualityResult),
        #[prost(message, tag = "13")]
        SummarizationHelpfulnessResult(super::SummarizationHelpfulnessResult),
        #[prost(message, tag = "14")]
        SummarizationVerbosityResult(super::SummarizationVerbosityResult),
        #[prost(message, tag = "9")]
        QuestionAnsweringQualityResult(super::QuestionAnsweringQualityResult),
        #[prost(message, tag = "23")]
        PairwiseQuestionAnsweringQualityResult(
            super::PairwiseQuestionAnsweringQualityResult,
        ),
        #[prost(message, tag = "15")]
        QuestionAnsweringRelevanceResult(super::QuestionAnsweringRelevanceResult),
        #[prost(message, tag = "16")]
        QuestionAnsweringHelpfulnessResult(super::QuestionAnsweringHelpfulnessResult),
        #[prost(message, tag = "17")]
        QuestionAnsweringCorrectnessResult(super::QuestionAnsweringCorrectnessResult),
        #[prost(message, tag = "27")]
        PointwiseMetricResult(super::PointwiseMetricResult),
        #[prost(message, tag = "28")]
        PairwiseMetricResult(super::PairwiseMetricResult),
        #[prost(message, tag = "18")]
        ToolCallValidResults(super::ToolCallValidResults),
        #[prost(message, tag = "19")]
        ToolNameMatchResults(super::ToolNameMatchResults),
        #[prost(message, tag = "20")]
        ToolParameterKeyMatchResults(super::ToolParameterKeyMatchResults),
        #[prost(message, tag = "21")]
        ToolParameterKvMatchResults(super::ToolParameterKvMatchResults),
        #[prost(message, tag = "29")]
        CometResult(super::CometResult),
        #[prost(message, tag = "30")]
        MetricxResult(super::MetricxResult),
    }
}
impl ::prost::Name for EvaluateInstancesResponse {
    const NAME: &'static str = "EvaluateInstancesResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.EvaluateInstancesResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.EvaluateInstancesResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExactMatchInput {
    #[prost(message, optional, tag = "1")]
    pub metric_spec: ::core::option::Option<ExactMatchSpec>,
    #[prost(message, repeated, tag = "2")]
    pub instances: ::prost::alloc::vec::Vec<ExactMatchInstance>,
}
impl ::prost::Name for ExactMatchInput {
    const NAME: &'static str = "ExactMatchInput";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ExactMatchInput".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExactMatchInput".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExactMatchInstance {
    #[prost(string, optional, tag = "1")]
    pub prediction: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub reference: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for ExactMatchInstance {
    const NAME: &'static str = "ExactMatchInstance";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ExactMatchInstance".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExactMatchInstance".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExactMatchSpec {}
impl ::prost::Name for ExactMatchSpec {
    const NAME: &'static str = "ExactMatchSpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ExactMatchSpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExactMatchSpec".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExactMatchResults {
    #[prost(message, repeated, tag = "1")]
    pub exact_match_metric_values: ::prost::alloc::vec::Vec<ExactMatchMetricValue>,
}
impl ::prost::Name for ExactMatchResults {
    const NAME: &'static str = "ExactMatchResults";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ExactMatchResults".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExactMatchResults".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExactMatchMetricValue {
    #[prost(float, optional, tag = "1")]
    pub score: ::core::option::Option<f32>,
}
impl ::prost::Name for ExactMatchMetricValue {
    const NAME: &'static str = "ExactMatchMetricValue";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ExactMatchMetricValue".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExactMatchMetricValue".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BleuInput {
    #[prost(message, optional, tag = "1")]
    pub metric_spec: ::core::option::Option<BleuSpec>,
    #[prost(message, repeated, tag = "2")]
    pub instances: ::prost::alloc::vec::Vec<BleuInstance>,
}
impl ::prost::Name for BleuInput {
    const NAME: &'static str = "BleuInput";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.BleuInput".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.BleuInput".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BleuInstance {
    #[prost(string, optional, tag = "1")]
    pub prediction: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub reference: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for BleuInstance {
    const NAME: &'static str = "BleuInstance";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.BleuInstance".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.BleuInstance".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BleuSpec {
    #[prost(bool, tag = "1")]
    pub use_effective_order: bool,
}
impl ::prost::Name for BleuSpec {
    const NAME: &'static str = "BleuSpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.BleuSpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.BleuSpec".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BleuResults {
    #[prost(message, repeated, tag = "1")]
    pub bleu_metric_values: ::prost::alloc::vec::Vec<BleuMetricValue>,
}
impl ::prost::Name for BleuResults {
    const NAME: &'static str = "BleuResults";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.BleuResults".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.BleuResults".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BleuMetricValue {
    #[prost(float, optional, tag = "1")]
    pub score: ::core::option::Option<f32>,
}
impl ::prost::Name for BleuMetricValue {
    const NAME: &'static str = "BleuMetricValue";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.BleuMetricValue".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.BleuMetricValue".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RougeInput {
    #[prost(message, optional, tag = "1")]
    pub metric_spec: ::core::option::Option<RougeSpec>,
    #[prost(message, repeated, tag = "2")]
    pub instances: ::prost::alloc::vec::Vec<RougeInstance>,
}
impl ::prost::Name for RougeInput {
    const NAME: &'static str = "RougeInput";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.RougeInput".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.RougeInput".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RougeInstance {
    #[prost(string, optional, tag = "1")]
    pub prediction: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub reference: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for RougeInstance {
    const NAME: &'static str = "RougeInstance";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.RougeInstance".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.RougeInstance".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RougeSpec {
    #[prost(string, tag = "1")]
    pub rouge_type: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub use_stemmer: bool,
    #[prost(bool, tag = "3")]
    pub split_summaries: bool,
}
impl ::prost::Name for RougeSpec {
    const NAME: &'static str = "RougeSpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.RougeSpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.RougeSpec".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RougeResults {
    #[prost(message, repeated, tag = "1")]
    pub rouge_metric_values: ::prost::alloc::vec::Vec<RougeMetricValue>,
}
impl ::prost::Name for RougeResults {
    const NAME: &'static str = "RougeResults";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.RougeResults".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.RougeResults".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RougeMetricValue {
    #[prost(float, optional, tag = "1")]
    pub score: ::core::option::Option<f32>,
}
impl ::prost::Name for RougeMetricValue {
    const NAME: &'static str = "RougeMetricValue";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.RougeMetricValue".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.RougeMetricValue".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CoherenceInput {
    #[prost(message, optional, tag = "1")]
    pub metric_spec: ::core::option::Option<CoherenceSpec>,
    #[prost(message, optional, tag = "2")]
    pub instance: ::core::option::Option<CoherenceInstance>,
}
impl ::prost::Name for CoherenceInput {
    const NAME: &'static str = "CoherenceInput";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CoherenceInput".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CoherenceInput".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CoherenceInstance {
    #[prost(string, optional, tag = "1")]
    pub prediction: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for CoherenceInstance {
    const NAME: &'static str = "CoherenceInstance";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CoherenceInstance".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CoherenceInstance".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CoherenceSpec {
    #[prost(int32, tag = "1")]
    pub version: i32,
}
impl ::prost::Name for CoherenceSpec {
    const NAME: &'static str = "CoherenceSpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CoherenceSpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CoherenceSpec".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CoherenceResult {
    #[prost(float, optional, tag = "1")]
    pub score: ::core::option::Option<f32>,
    #[prost(string, tag = "2")]
    pub explanation: ::prost::alloc::string::String,
    #[prost(float, optional, tag = "3")]
    pub confidence: ::core::option::Option<f32>,
}
impl ::prost::Name for CoherenceResult {
    const NAME: &'static str = "CoherenceResult";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CoherenceResult".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CoherenceResult".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FluencyInput {
    #[prost(message, optional, tag = "1")]
    pub metric_spec: ::core::option::Option<FluencySpec>,
    #[prost(message, optional, tag = "2")]
    pub instance: ::core::option::Option<FluencyInstance>,
}
impl ::prost::Name for FluencyInput {
    const NAME: &'static str = "FluencyInput";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.FluencyInput".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.FluencyInput".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FluencyInstance {
    #[prost(string, optional, tag = "1")]
    pub prediction: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for FluencyInstance {
    const NAME: &'static str = "FluencyInstance";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.FluencyInstance".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.FluencyInstance".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FluencySpec {
    #[prost(int32, tag = "1")]
    pub version: i32,
}
impl ::prost::Name for FluencySpec {
    const NAME: &'static str = "FluencySpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.FluencySpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.FluencySpec".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FluencyResult {
    #[prost(float, optional, tag = "1")]
    pub score: ::core::option::Option<f32>,
    #[prost(string, tag = "2")]
    pub explanation: ::prost::alloc::string::String,
    #[prost(float, optional, tag = "3")]
    pub confidence: ::core::option::Option<f32>,
}
impl ::prost::Name for FluencyResult {
    const NAME: &'static str = "FluencyResult";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.FluencyResult".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.FluencyResult".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SafetyInput {
    #[prost(message, optional, tag = "1")]
    pub metric_spec: ::core::option::Option<SafetySpec>,
    #[prost(message, optional, tag = "2")]
    pub instance: ::core::option::Option<SafetyInstance>,
}
impl ::prost::Name for SafetyInput {
    const NAME: &'static str = "SafetyInput";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SafetyInput".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SafetyInput".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SafetyInstance {
    #[prost(string, optional, tag = "1")]
    pub prediction: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for SafetyInstance {
    const NAME: &'static str = "SafetyInstance";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SafetyInstance".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SafetyInstance".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SafetySpec {
    #[prost(int32, tag = "1")]
    pub version: i32,
}
impl ::prost::Name for SafetySpec {
    const NAME: &'static str = "SafetySpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SafetySpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SafetySpec".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SafetyResult {
    #[prost(float, optional, tag = "1")]
    pub score: ::core::option::Option<f32>,
    #[prost(string, tag = "2")]
    pub explanation: ::prost::alloc::string::String,
    #[prost(float, optional, tag = "3")]
    pub confidence: ::core::option::Option<f32>,
}
impl ::prost::Name for SafetyResult {
    const NAME: &'static str = "SafetyResult";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SafetyResult".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SafetyResult".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroundednessInput {
    #[prost(message, optional, tag = "1")]
    pub metric_spec: ::core::option::Option<GroundednessSpec>,
    #[prost(message, optional, tag = "2")]
    pub instance: ::core::option::Option<GroundednessInstance>,
}
impl ::prost::Name for GroundednessInput {
    const NAME: &'static str = "GroundednessInput";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GroundednessInput".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GroundednessInput".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroundednessInstance {
    #[prost(string, optional, tag = "1")]
    pub prediction: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub context: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for GroundednessInstance {
    const NAME: &'static str = "GroundednessInstance";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GroundednessInstance".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GroundednessInstance".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GroundednessSpec {
    #[prost(int32, tag = "1")]
    pub version: i32,
}
impl ::prost::Name for GroundednessSpec {
    const NAME: &'static str = "GroundednessSpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GroundednessSpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GroundednessSpec".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroundednessResult {
    #[prost(float, optional, tag = "1")]
    pub score: ::core::option::Option<f32>,
    #[prost(string, tag = "2")]
    pub explanation: ::prost::alloc::string::String,
    #[prost(float, optional, tag = "3")]
    pub confidence: ::core::option::Option<f32>,
}
impl ::prost::Name for GroundednessResult {
    const NAME: &'static str = "GroundednessResult";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GroundednessResult".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GroundednessResult".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FulfillmentInput {
    #[prost(message, optional, tag = "1")]
    pub metric_spec: ::core::option::Option<FulfillmentSpec>,
    #[prost(message, optional, tag = "2")]
    pub instance: ::core::option::Option<FulfillmentInstance>,
}
impl ::prost::Name for FulfillmentInput {
    const NAME: &'static str = "FulfillmentInput";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.FulfillmentInput".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.FulfillmentInput".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FulfillmentInstance {
    #[prost(string, optional, tag = "1")]
    pub prediction: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub instruction: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for FulfillmentInstance {
    const NAME: &'static str = "FulfillmentInstance";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.FulfillmentInstance".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.FulfillmentInstance".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FulfillmentSpec {
    #[prost(int32, tag = "1")]
    pub version: i32,
}
impl ::prost::Name for FulfillmentSpec {
    const NAME: &'static str = "FulfillmentSpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.FulfillmentSpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.FulfillmentSpec".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FulfillmentResult {
    #[prost(float, optional, tag = "1")]
    pub score: ::core::option::Option<f32>,
    #[prost(string, tag = "2")]
    pub explanation: ::prost::alloc::string::String,
    #[prost(float, optional, tag = "3")]
    pub confidence: ::core::option::Option<f32>,
}
impl ::prost::Name for FulfillmentResult {
    const NAME: &'static str = "FulfillmentResult";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.FulfillmentResult".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.FulfillmentResult".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SummarizationQualityInput {
    #[prost(message, optional, tag = "1")]
    pub metric_spec: ::core::option::Option<SummarizationQualitySpec>,
    #[prost(message, optional, tag = "2")]
    pub instance: ::core::option::Option<SummarizationQualityInstance>,
}
impl ::prost::Name for SummarizationQualityInput {
    const NAME: &'static str = "SummarizationQualityInput";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SummarizationQualityInput".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SummarizationQualityInput".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SummarizationQualityInstance {
    #[prost(string, optional, tag = "1")]
    pub prediction: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub reference: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub context: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub instruction: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for SummarizationQualityInstance {
    const NAME: &'static str = "SummarizationQualityInstance";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SummarizationQualityInstance".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SummarizationQualityInstance"
            .into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SummarizationQualitySpec {
    #[prost(bool, tag = "1")]
    pub use_reference: bool,
    #[prost(int32, tag = "2")]
    pub version: i32,
}
impl ::prost::Name for SummarizationQualitySpec {
    const NAME: &'static str = "SummarizationQualitySpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SummarizationQualitySpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SummarizationQualitySpec".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SummarizationQualityResult {
    #[prost(float, optional, tag = "1")]
    pub score: ::core::option::Option<f32>,
    #[prost(string, tag = "2")]
    pub explanation: ::prost::alloc::string::String,
    #[prost(float, optional, tag = "3")]
    pub confidence: ::core::option::Option<f32>,
}
impl ::prost::Name for SummarizationQualityResult {
    const NAME: &'static str = "SummarizationQualityResult";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SummarizationQualityResult".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SummarizationQualityResult"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PairwiseSummarizationQualityInput {
    #[prost(message, optional, tag = "1")]
    pub metric_spec: ::core::option::Option<PairwiseSummarizationQualitySpec>,
    #[prost(message, optional, tag = "2")]
    pub instance: ::core::option::Option<PairwiseSummarizationQualityInstance>,
}
impl ::prost::Name for PairwiseSummarizationQualityInput {
    const NAME: &'static str = "PairwiseSummarizationQualityInput";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.PairwiseSummarizationQualityInput".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.PairwiseSummarizationQualityInput"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PairwiseSummarizationQualityInstance {
    #[prost(string, optional, tag = "1")]
    pub prediction: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub baseline_prediction: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub reference: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub context: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "5")]
    pub instruction: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for PairwiseSummarizationQualityInstance {
    const NAME: &'static str = "PairwiseSummarizationQualityInstance";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.PairwiseSummarizationQualityInstance".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.PairwiseSummarizationQualityInstance"
            .into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PairwiseSummarizationQualitySpec {
    #[prost(bool, tag = "1")]
    pub use_reference: bool,
    #[prost(int32, tag = "2")]
    pub version: i32,
}
impl ::prost::Name for PairwiseSummarizationQualitySpec {
    const NAME: &'static str = "PairwiseSummarizationQualitySpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.PairwiseSummarizationQualitySpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.PairwiseSummarizationQualitySpec"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PairwiseSummarizationQualityResult {
    #[prost(enumeration = "PairwiseChoice", tag = "1")]
    pub pairwise_choice: i32,
    #[prost(string, tag = "2")]
    pub explanation: ::prost::alloc::string::String,
    #[prost(float, optional, tag = "3")]
    pub confidence: ::core::option::Option<f32>,
}
impl ::prost::Name for PairwiseSummarizationQualityResult {
    const NAME: &'static str = "PairwiseSummarizationQualityResult";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.PairwiseSummarizationQualityResult".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.PairwiseSummarizationQualityResult"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SummarizationHelpfulnessInput {
    #[prost(message, optional, tag = "1")]
    pub metric_spec: ::core::option::Option<SummarizationHelpfulnessSpec>,
    #[prost(message, optional, tag = "2")]
    pub instance: ::core::option::Option<SummarizationHelpfulnessInstance>,
}
impl ::prost::Name for SummarizationHelpfulnessInput {
    const NAME: &'static str = "SummarizationHelpfulnessInput";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SummarizationHelpfulnessInput".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SummarizationHelpfulnessInput"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SummarizationHelpfulnessInstance {
    #[prost(string, optional, tag = "1")]
    pub prediction: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub reference: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub context: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub instruction: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for SummarizationHelpfulnessInstance {
    const NAME: &'static str = "SummarizationHelpfulnessInstance";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SummarizationHelpfulnessInstance".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SummarizationHelpfulnessInstance"
            .into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SummarizationHelpfulnessSpec {
    #[prost(bool, tag = "1")]
    pub use_reference: bool,
    #[prost(int32, tag = "2")]
    pub version: i32,
}
impl ::prost::Name for SummarizationHelpfulnessSpec {
    const NAME: &'static str = "SummarizationHelpfulnessSpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SummarizationHelpfulnessSpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SummarizationHelpfulnessSpec"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SummarizationHelpfulnessResult {
    #[prost(float, optional, tag = "1")]
    pub score: ::core::option::Option<f32>,
    #[prost(string, tag = "2")]
    pub explanation: ::prost::alloc::string::String,
    #[prost(float, optional, tag = "3")]
    pub confidence: ::core::option::Option<f32>,
}
impl ::prost::Name for SummarizationHelpfulnessResult {
    const NAME: &'static str = "SummarizationHelpfulnessResult";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SummarizationHelpfulnessResult".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SummarizationHelpfulnessResult"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SummarizationVerbosityInput {
    #[prost(message, optional, tag = "1")]
    pub metric_spec: ::core::option::Option<SummarizationVerbositySpec>,
    #[prost(message, optional, tag = "2")]
    pub instance: ::core::option::Option<SummarizationVerbosityInstance>,
}
impl ::prost::Name for SummarizationVerbosityInput {
    const NAME: &'static str = "SummarizationVerbosityInput";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SummarizationVerbosityInput".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SummarizationVerbosityInput"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SummarizationVerbosityInstance {
    #[prost(string, optional, tag = "1")]
    pub prediction: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub reference: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub context: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub instruction: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for SummarizationVerbosityInstance {
    const NAME: &'static str = "SummarizationVerbosityInstance";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SummarizationVerbosityInstance".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SummarizationVerbosityInstance"
            .into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SummarizationVerbositySpec {
    #[prost(bool, tag = "1")]
    pub use_reference: bool,
    #[prost(int32, tag = "2")]
    pub version: i32,
}
impl ::prost::Name for SummarizationVerbositySpec {
    const NAME: &'static str = "SummarizationVerbositySpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SummarizationVerbositySpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SummarizationVerbositySpec"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SummarizationVerbosityResult {
    #[prost(float, optional, tag = "1")]
    pub score: ::core::option::Option<f32>,
    #[prost(string, tag = "2")]
    pub explanation: ::prost::alloc::string::String,
    #[prost(float, optional, tag = "3")]
    pub confidence: ::core::option::Option<f32>,
}
impl ::prost::Name for SummarizationVerbosityResult {
    const NAME: &'static str = "SummarizationVerbosityResult";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SummarizationVerbosityResult".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SummarizationVerbosityResult"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuestionAnsweringQualityInput {
    #[prost(message, optional, tag = "1")]
    pub metric_spec: ::core::option::Option<QuestionAnsweringQualitySpec>,
    #[prost(message, optional, tag = "2")]
    pub instance: ::core::option::Option<QuestionAnsweringQualityInstance>,
}
impl ::prost::Name for QuestionAnsweringQualityInput {
    const NAME: &'static str = "QuestionAnsweringQualityInput";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.QuestionAnsweringQualityInput".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringQualityInput"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuestionAnsweringQualityInstance {
    #[prost(string, optional, tag = "1")]
    pub prediction: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub reference: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub context: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub instruction: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for QuestionAnsweringQualityInstance {
    const NAME: &'static str = "QuestionAnsweringQualityInstance";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.QuestionAnsweringQualityInstance".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringQualityInstance"
            .into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QuestionAnsweringQualitySpec {
    #[prost(bool, tag = "1")]
    pub use_reference: bool,
    #[prost(int32, tag = "2")]
    pub version: i32,
}
impl ::prost::Name for QuestionAnsweringQualitySpec {
    const NAME: &'static str = "QuestionAnsweringQualitySpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.QuestionAnsweringQualitySpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringQualitySpec"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuestionAnsweringQualityResult {
    #[prost(float, optional, tag = "1")]
    pub score: ::core::option::Option<f32>,
    #[prost(string, tag = "2")]
    pub explanation: ::prost::alloc::string::String,
    #[prost(float, optional, tag = "3")]
    pub confidence: ::core::option::Option<f32>,
}
impl ::prost::Name for QuestionAnsweringQualityResult {
    const NAME: &'static str = "QuestionAnsweringQualityResult";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.QuestionAnsweringQualityResult".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringQualityResult"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PairwiseQuestionAnsweringQualityInput {
    #[prost(message, optional, tag = "1")]
    pub metric_spec: ::core::option::Option<PairwiseQuestionAnsweringQualitySpec>,
    #[prost(message, optional, tag = "2")]
    pub instance: ::core::option::Option<PairwiseQuestionAnsweringQualityInstance>,
}
impl ::prost::Name for PairwiseQuestionAnsweringQualityInput {
    const NAME: &'static str = "PairwiseQuestionAnsweringQualityInput";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.PairwiseQuestionAnsweringQualityInput".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.PairwiseQuestionAnsweringQualityInput"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PairwiseQuestionAnsweringQualityInstance {
    #[prost(string, optional, tag = "1")]
    pub prediction: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub baseline_prediction: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub reference: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub context: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "5")]
    pub instruction: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for PairwiseQuestionAnsweringQualityInstance {
    const NAME: &'static str = "PairwiseQuestionAnsweringQualityInstance";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.PairwiseQuestionAnsweringQualityInstance".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.PairwiseQuestionAnsweringQualityInstance"
            .into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PairwiseQuestionAnsweringQualitySpec {
    #[prost(bool, tag = "1")]
    pub use_reference: bool,
    #[prost(int32, tag = "2")]
    pub version: i32,
}
impl ::prost::Name for PairwiseQuestionAnsweringQualitySpec {
    const NAME: &'static str = "PairwiseQuestionAnsweringQualitySpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.PairwiseQuestionAnsweringQualitySpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.PairwiseQuestionAnsweringQualitySpec"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PairwiseQuestionAnsweringQualityResult {
    #[prost(enumeration = "PairwiseChoice", tag = "1")]
    pub pairwise_choice: i32,
    #[prost(string, tag = "2")]
    pub explanation: ::prost::alloc::string::String,
    #[prost(float, optional, tag = "3")]
    pub confidence: ::core::option::Option<f32>,
}
impl ::prost::Name for PairwiseQuestionAnsweringQualityResult {
    const NAME: &'static str = "PairwiseQuestionAnsweringQualityResult";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.PairwiseQuestionAnsweringQualityResult".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.PairwiseQuestionAnsweringQualityResult"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuestionAnsweringRelevanceInput {
    #[prost(message, optional, tag = "1")]
    pub metric_spec: ::core::option::Option<QuestionAnsweringRelevanceSpec>,
    #[prost(message, optional, tag = "2")]
    pub instance: ::core::option::Option<QuestionAnsweringRelevanceInstance>,
}
impl ::prost::Name for QuestionAnsweringRelevanceInput {
    const NAME: &'static str = "QuestionAnsweringRelevanceInput";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.QuestionAnsweringRelevanceInput".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringRelevanceInput"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuestionAnsweringRelevanceInstance {
    #[prost(string, optional, tag = "1")]
    pub prediction: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub reference: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub context: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub instruction: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for QuestionAnsweringRelevanceInstance {
    const NAME: &'static str = "QuestionAnsweringRelevanceInstance";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.QuestionAnsweringRelevanceInstance".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringRelevanceInstance"
            .into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QuestionAnsweringRelevanceSpec {
    #[prost(bool, tag = "1")]
    pub use_reference: bool,
    #[prost(int32, tag = "2")]
    pub version: i32,
}
impl ::prost::Name for QuestionAnsweringRelevanceSpec {
    const NAME: &'static str = "QuestionAnsweringRelevanceSpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.QuestionAnsweringRelevanceSpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringRelevanceSpec"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuestionAnsweringRelevanceResult {
    #[prost(float, optional, tag = "1")]
    pub score: ::core::option::Option<f32>,
    #[prost(string, tag = "2")]
    pub explanation: ::prost::alloc::string::String,
    #[prost(float, optional, tag = "3")]
    pub confidence: ::core::option::Option<f32>,
}
impl ::prost::Name for QuestionAnsweringRelevanceResult {
    const NAME: &'static str = "QuestionAnsweringRelevanceResult";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.QuestionAnsweringRelevanceResult".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringRelevanceResult"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuestionAnsweringHelpfulnessInput {
    #[prost(message, optional, tag = "1")]
    pub metric_spec: ::core::option::Option<QuestionAnsweringHelpfulnessSpec>,
    #[prost(message, optional, tag = "2")]
    pub instance: ::core::option::Option<QuestionAnsweringHelpfulnessInstance>,
}
impl ::prost::Name for QuestionAnsweringHelpfulnessInput {
    const NAME: &'static str = "QuestionAnsweringHelpfulnessInput";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.QuestionAnsweringHelpfulnessInput".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringHelpfulnessInput"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuestionAnsweringHelpfulnessInstance {
    #[prost(string, optional, tag = "1")]
    pub prediction: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub reference: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub context: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub instruction: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for QuestionAnsweringHelpfulnessInstance {
    const NAME: &'static str = "QuestionAnsweringHelpfulnessInstance";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.QuestionAnsweringHelpfulnessInstance".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringHelpfulnessInstance"
            .into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QuestionAnsweringHelpfulnessSpec {
    #[prost(bool, tag = "1")]
    pub use_reference: bool,
    #[prost(int32, tag = "2")]
    pub version: i32,
}
impl ::prost::Name for QuestionAnsweringHelpfulnessSpec {
    const NAME: &'static str = "QuestionAnsweringHelpfulnessSpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.QuestionAnsweringHelpfulnessSpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringHelpfulnessSpec"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuestionAnsweringHelpfulnessResult {
    #[prost(float, optional, tag = "1")]
    pub score: ::core::option::Option<f32>,
    #[prost(string, tag = "2")]
    pub explanation: ::prost::alloc::string::String,
    #[prost(float, optional, tag = "3")]
    pub confidence: ::core::option::Option<f32>,
}
impl ::prost::Name for QuestionAnsweringHelpfulnessResult {
    const NAME: &'static str = "QuestionAnsweringHelpfulnessResult";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.QuestionAnsweringHelpfulnessResult".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringHelpfulnessResult"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuestionAnsweringCorrectnessInput {
    #[prost(message, optional, tag = "1")]
    pub metric_spec: ::core::option::Option<QuestionAnsweringCorrectnessSpec>,
    #[prost(message, optional, tag = "2")]
    pub instance: ::core::option::Option<QuestionAnsweringCorrectnessInstance>,
}
impl ::prost::Name for QuestionAnsweringCorrectnessInput {
    const NAME: &'static str = "QuestionAnsweringCorrectnessInput";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.QuestionAnsweringCorrectnessInput".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringCorrectnessInput"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuestionAnsweringCorrectnessInstance {
    #[prost(string, optional, tag = "1")]
    pub prediction: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub reference: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub context: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub instruction: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for QuestionAnsweringCorrectnessInstance {
    const NAME: &'static str = "QuestionAnsweringCorrectnessInstance";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.QuestionAnsweringCorrectnessInstance".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringCorrectnessInstance"
            .into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QuestionAnsweringCorrectnessSpec {
    #[prost(bool, tag = "1")]
    pub use_reference: bool,
    #[prost(int32, tag = "2")]
    pub version: i32,
}
impl ::prost::Name for QuestionAnsweringCorrectnessSpec {
    const NAME: &'static str = "QuestionAnsweringCorrectnessSpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.QuestionAnsweringCorrectnessSpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringCorrectnessSpec"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuestionAnsweringCorrectnessResult {
    #[prost(float, optional, tag = "1")]
    pub score: ::core::option::Option<f32>,
    #[prost(string, tag = "2")]
    pub explanation: ::prost::alloc::string::String,
    #[prost(float, optional, tag = "3")]
    pub confidence: ::core::option::Option<f32>,
}
impl ::prost::Name for QuestionAnsweringCorrectnessResult {
    const NAME: &'static str = "QuestionAnsweringCorrectnessResult";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.QuestionAnsweringCorrectnessResult".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.QuestionAnsweringCorrectnessResult"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PointwiseMetricInput {
    #[prost(message, optional, tag = "1")]
    pub metric_spec: ::core::option::Option<PointwiseMetricSpec>,
    #[prost(message, optional, tag = "2")]
    pub instance: ::core::option::Option<PointwiseMetricInstance>,
}
impl ::prost::Name for PointwiseMetricInput {
    const NAME: &'static str = "PointwiseMetricInput";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.PointwiseMetricInput".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.PointwiseMetricInput".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PointwiseMetricInstance {
    #[prost(oneof = "pointwise_metric_instance::Instance", tags = "1")]
    pub instance: ::core::option::Option<pointwise_metric_instance::Instance>,
}
/// Nested message and enum types in `PointwiseMetricInstance`.
pub mod pointwise_metric_instance {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Instance {
        #[prost(string, tag = "1")]
        JsonInstance(::prost::alloc::string::String),
    }
}
impl ::prost::Name for PointwiseMetricInstance {
    const NAME: &'static str = "PointwiseMetricInstance";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.PointwiseMetricInstance".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.PointwiseMetricInstance".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PointwiseMetricSpec {
    #[prost(string, optional, tag = "1")]
    pub metric_prompt_template: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for PointwiseMetricSpec {
    const NAME: &'static str = "PointwiseMetricSpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.PointwiseMetricSpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.PointwiseMetricSpec".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PointwiseMetricResult {
    #[prost(float, optional, tag = "1")]
    pub score: ::core::option::Option<f32>,
    #[prost(string, tag = "2")]
    pub explanation: ::prost::alloc::string::String,
}
impl ::prost::Name for PointwiseMetricResult {
    const NAME: &'static str = "PointwiseMetricResult";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.PointwiseMetricResult".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.PointwiseMetricResult".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PairwiseMetricInput {
    #[prost(message, optional, tag = "1")]
    pub metric_spec: ::core::option::Option<PairwiseMetricSpec>,
    #[prost(message, optional, tag = "2")]
    pub instance: ::core::option::Option<PairwiseMetricInstance>,
}
impl ::prost::Name for PairwiseMetricInput {
    const NAME: &'static str = "PairwiseMetricInput";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.PairwiseMetricInput".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.PairwiseMetricInput".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PairwiseMetricInstance {
    #[prost(oneof = "pairwise_metric_instance::Instance", tags = "1")]
    pub instance: ::core::option::Option<pairwise_metric_instance::Instance>,
}
/// Nested message and enum types in `PairwiseMetricInstance`.
pub mod pairwise_metric_instance {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Instance {
        #[prost(string, tag = "1")]
        JsonInstance(::prost::alloc::string::String),
    }
}
impl ::prost::Name for PairwiseMetricInstance {
    const NAME: &'static str = "PairwiseMetricInstance";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.PairwiseMetricInstance".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.PairwiseMetricInstance".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PairwiseMetricSpec {
    #[prost(string, optional, tag = "1")]
    pub metric_prompt_template: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for PairwiseMetricSpec {
    const NAME: &'static str = "PairwiseMetricSpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.PairwiseMetricSpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.PairwiseMetricSpec".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PairwiseMetricResult {
    #[prost(enumeration = "PairwiseChoice", tag = "1")]
    pub pairwise_choice: i32,
    #[prost(string, tag = "2")]
    pub explanation: ::prost::alloc::string::String,
}
impl ::prost::Name for PairwiseMetricResult {
    const NAME: &'static str = "PairwiseMetricResult";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.PairwiseMetricResult".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.PairwiseMetricResult".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToolCallValidInput {
    #[prost(message, optional, tag = "1")]
    pub metric_spec: ::core::option::Option<ToolCallValidSpec>,
    #[prost(message, repeated, tag = "2")]
    pub instances: ::prost::alloc::vec::Vec<ToolCallValidInstance>,
}
impl ::prost::Name for ToolCallValidInput {
    const NAME: &'static str = "ToolCallValidInput";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ToolCallValidInput".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolCallValidInput".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ToolCallValidSpec {}
impl ::prost::Name for ToolCallValidSpec {
    const NAME: &'static str = "ToolCallValidSpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ToolCallValidSpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolCallValidSpec".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToolCallValidInstance {
    #[prost(string, optional, tag = "1")]
    pub prediction: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub reference: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for ToolCallValidInstance {
    const NAME: &'static str = "ToolCallValidInstance";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ToolCallValidInstance".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolCallValidInstance".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToolCallValidResults {
    #[prost(message, repeated, tag = "1")]
    pub tool_call_valid_metric_values: ::prost::alloc::vec::Vec<
        ToolCallValidMetricValue,
    >,
}
impl ::prost::Name for ToolCallValidResults {
    const NAME: &'static str = "ToolCallValidResults";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ToolCallValidResults".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolCallValidResults".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ToolCallValidMetricValue {
    #[prost(float, optional, tag = "1")]
    pub score: ::core::option::Option<f32>,
}
impl ::prost::Name for ToolCallValidMetricValue {
    const NAME: &'static str = "ToolCallValidMetricValue";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ToolCallValidMetricValue".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolCallValidMetricValue".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToolNameMatchInput {
    #[prost(message, optional, tag = "1")]
    pub metric_spec: ::core::option::Option<ToolNameMatchSpec>,
    #[prost(message, repeated, tag = "2")]
    pub instances: ::prost::alloc::vec::Vec<ToolNameMatchInstance>,
}
impl ::prost::Name for ToolNameMatchInput {
    const NAME: &'static str = "ToolNameMatchInput";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ToolNameMatchInput".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolNameMatchInput".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ToolNameMatchSpec {}
impl ::prost::Name for ToolNameMatchSpec {
    const NAME: &'static str = "ToolNameMatchSpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ToolNameMatchSpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolNameMatchSpec".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToolNameMatchInstance {
    #[prost(string, optional, tag = "1")]
    pub prediction: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub reference: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for ToolNameMatchInstance {
    const NAME: &'static str = "ToolNameMatchInstance";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ToolNameMatchInstance".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolNameMatchInstance".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToolNameMatchResults {
    #[prost(message, repeated, tag = "1")]
    pub tool_name_match_metric_values: ::prost::alloc::vec::Vec<
        ToolNameMatchMetricValue,
    >,
}
impl ::prost::Name for ToolNameMatchResults {
    const NAME: &'static str = "ToolNameMatchResults";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ToolNameMatchResults".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolNameMatchResults".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ToolNameMatchMetricValue {
    #[prost(float, optional, tag = "1")]
    pub score: ::core::option::Option<f32>,
}
impl ::prost::Name for ToolNameMatchMetricValue {
    const NAME: &'static str = "ToolNameMatchMetricValue";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ToolNameMatchMetricValue".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolNameMatchMetricValue".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToolParameterKeyMatchInput {
    #[prost(message, optional, tag = "1")]
    pub metric_spec: ::core::option::Option<ToolParameterKeyMatchSpec>,
    #[prost(message, repeated, tag = "2")]
    pub instances: ::prost::alloc::vec::Vec<ToolParameterKeyMatchInstance>,
}
impl ::prost::Name for ToolParameterKeyMatchInput {
    const NAME: &'static str = "ToolParameterKeyMatchInput";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ToolParameterKeyMatchInput".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolParameterKeyMatchInput"
            .into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ToolParameterKeyMatchSpec {}
impl ::prost::Name for ToolParameterKeyMatchSpec {
    const NAME: &'static str = "ToolParameterKeyMatchSpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ToolParameterKeyMatchSpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolParameterKeyMatchSpec".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToolParameterKeyMatchInstance {
    #[prost(string, optional, tag = "1")]
    pub prediction: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub reference: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for ToolParameterKeyMatchInstance {
    const NAME: &'static str = "ToolParameterKeyMatchInstance";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ToolParameterKeyMatchInstance".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolParameterKeyMatchInstance"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToolParameterKeyMatchResults {
    #[prost(message, repeated, tag = "1")]
    pub tool_parameter_key_match_metric_values: ::prost::alloc::vec::Vec<
        ToolParameterKeyMatchMetricValue,
    >,
}
impl ::prost::Name for ToolParameterKeyMatchResults {
    const NAME: &'static str = "ToolParameterKeyMatchResults";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ToolParameterKeyMatchResults".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolParameterKeyMatchResults"
            .into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ToolParameterKeyMatchMetricValue {
    #[prost(float, optional, tag = "1")]
    pub score: ::core::option::Option<f32>,
}
impl ::prost::Name for ToolParameterKeyMatchMetricValue {
    const NAME: &'static str = "ToolParameterKeyMatchMetricValue";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ToolParameterKeyMatchMetricValue".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolParameterKeyMatchMetricValue"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToolParameterKvMatchInput {
    #[prost(message, optional, tag = "1")]
    pub metric_spec: ::core::option::Option<ToolParameterKvMatchSpec>,
    #[prost(message, repeated, tag = "2")]
    pub instances: ::prost::alloc::vec::Vec<ToolParameterKvMatchInstance>,
}
impl ::prost::Name for ToolParameterKvMatchInput {
    const NAME: &'static str = "ToolParameterKVMatchInput";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ToolParameterKVMatchInput".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolParameterKVMatchInput".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ToolParameterKvMatchSpec {
    #[prost(bool, tag = "1")]
    pub use_strict_string_match: bool,
}
impl ::prost::Name for ToolParameterKvMatchSpec {
    const NAME: &'static str = "ToolParameterKVMatchSpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ToolParameterKVMatchSpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolParameterKVMatchSpec".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToolParameterKvMatchInstance {
    #[prost(string, optional, tag = "1")]
    pub prediction: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub reference: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for ToolParameterKvMatchInstance {
    const NAME: &'static str = "ToolParameterKVMatchInstance";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ToolParameterKVMatchInstance".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolParameterKVMatchInstance"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToolParameterKvMatchResults {
    #[prost(message, repeated, tag = "1")]
    pub tool_parameter_kv_match_metric_values: ::prost::alloc::vec::Vec<
        ToolParameterKvMatchMetricValue,
    >,
}
impl ::prost::Name for ToolParameterKvMatchResults {
    const NAME: &'static str = "ToolParameterKVMatchResults";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ToolParameterKVMatchResults".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolParameterKVMatchResults"
            .into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ToolParameterKvMatchMetricValue {
    #[prost(float, optional, tag = "1")]
    pub score: ::core::option::Option<f32>,
}
impl ::prost::Name for ToolParameterKvMatchMetricValue {
    const NAME: &'static str = "ToolParameterKVMatchMetricValue";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ToolParameterKVMatchMetricValue".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ToolParameterKVMatchMetricValue"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CometInput {
    #[prost(message, optional, tag = "1")]
    pub metric_spec: ::core::option::Option<CometSpec>,
    #[prost(message, optional, tag = "2")]
    pub instance: ::core::option::Option<CometInstance>,
}
impl ::prost::Name for CometInput {
    const NAME: &'static str = "CometInput";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CometInput".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CometInput".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CometSpec {
    #[prost(enumeration = "comet_spec::CometVersion", optional, tag = "1")]
    pub version: ::core::option::Option<i32>,
    #[prost(string, tag = "2")]
    pub source_language: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub target_language: ::prost::alloc::string::String,
}
/// Nested message and enum types in `CometSpec`.
pub mod comet_spec {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CometVersion {
        Unspecified = 0,
        Comet22SrcRef = 2,
    }
    impl CometVersion {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "COMET_VERSION_UNSPECIFIED",
                Self::Comet22SrcRef => "COMET_22_SRC_REF",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COMET_VERSION_UNSPECIFIED" => Some(Self::Unspecified),
                "COMET_22_SRC_REF" => Some(Self::Comet22SrcRef),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for CometSpec {
    const NAME: &'static str = "CometSpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CometSpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CometSpec".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CometInstance {
    #[prost(string, optional, tag = "1")]
    pub prediction: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub reference: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub source: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for CometInstance {
    const NAME: &'static str = "CometInstance";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CometInstance".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CometInstance".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CometResult {
    #[prost(float, optional, tag = "1")]
    pub score: ::core::option::Option<f32>,
}
impl ::prost::Name for CometResult {
    const NAME: &'static str = "CometResult";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CometResult".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CometResult".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetricxInput {
    #[prost(message, optional, tag = "1")]
    pub metric_spec: ::core::option::Option<MetricxSpec>,
    #[prost(message, optional, tag = "2")]
    pub instance: ::core::option::Option<MetricxInstance>,
}
impl ::prost::Name for MetricxInput {
    const NAME: &'static str = "MetricxInput";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.MetricxInput".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.MetricxInput".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetricxSpec {
    #[prost(enumeration = "metricx_spec::MetricxVersion", optional, tag = "1")]
    pub version: ::core::option::Option<i32>,
    #[prost(string, tag = "2")]
    pub source_language: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub target_language: ::prost::alloc::string::String,
}
/// Nested message and enum types in `MetricxSpec`.
pub mod metricx_spec {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MetricxVersion {
        Unspecified = 0,
        Metricx24Ref = 1,
        Metricx24Src = 2,
        Metricx24SrcRef = 3,
    }
    impl MetricxVersion {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "METRICX_VERSION_UNSPECIFIED",
                Self::Metricx24Ref => "METRICX_24_REF",
                Self::Metricx24Src => "METRICX_24_SRC",
                Self::Metricx24SrcRef => "METRICX_24_SRC_REF",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "METRICX_VERSION_UNSPECIFIED" => Some(Self::Unspecified),
                "METRICX_24_REF" => Some(Self::Metricx24Ref),
                "METRICX_24_SRC" => Some(Self::Metricx24Src),
                "METRICX_24_SRC_REF" => Some(Self::Metricx24SrcRef),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for MetricxSpec {
    const NAME: &'static str = "MetricxSpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.MetricxSpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.MetricxSpec".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetricxInstance {
    #[prost(string, optional, tag = "1")]
    pub prediction: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub reference: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub source: ::core::option::Option<::prost::alloc::string::String>,
}
impl ::prost::Name for MetricxInstance {
    const NAME: &'static str = "MetricxInstance";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.MetricxInstance".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.MetricxInstance".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MetricxResult {
    #[prost(float, optional, tag = "1")]
    pub score: ::core::option::Option<f32>,
}
impl ::prost::Name for MetricxResult {
    const NAME: &'static str = "MetricxResult";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.MetricxResult".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.MetricxResult".into()
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PairwiseChoice {
    Unspecified = 0,
    Baseline = 1,
    Candidate = 2,
    Tie = 3,
}
impl PairwiseChoice {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PAIRWISE_CHOICE_UNSPECIFIED",
            Self::Baseline => "BASELINE",
            Self::Candidate => "CANDIDATE",
            Self::Tie => "TIE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PAIRWISE_CHOICE_UNSPECIFIED" => Some(Self::Unspecified),
            "BASELINE" => Some(Self::Baseline),
            "CANDIDATE" => Some(Self::Candidate),
            "TIE" => Some(Self::Tie),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Event {
    #[prost(string, tag = "1")]
    pub artifact: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub execution: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub event_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration = "event::Type", tag = "4")]
    pub r#type: i32,
    #[prost(map = "string, string", tag = "5")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Nested message and enum types in `Event`.
pub mod event {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unspecified = 0,
        Input = 1,
        Output = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_UNSPECIFIED",
                Self::Input => "INPUT",
                Self::Output => "OUTPUT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "INPUT" => Some(Self::Input),
                "OUTPUT" => Some(Self::Output),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for Event {
    const NAME: &'static str = "Event";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.Event".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.Event".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Execution {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(enumeration = "execution::State", tag = "6")]
    pub state: i32,
    #[prost(string, tag = "9")]
    pub etag: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "10")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "11")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "12")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "13")]
    pub schema_title: ::prost::alloc::string::String,
    #[prost(string, tag = "14")]
    pub schema_version: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "15")]
    pub metadata: ::core::option::Option<::prost_types::Struct>,
    #[prost(string, tag = "16")]
    pub description: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Execution`.
pub mod execution {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        New = 1,
        Running = 2,
        Complete = 3,
        Failed = 4,
        Cached = 5,
        Cancelled = 6,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::New => "NEW",
                Self::Running => "RUNNING",
                Self::Complete => "COMPLETE",
                Self::Failed => "FAILED",
                Self::Cached => "CACHED",
                Self::Cancelled => "CANCELLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "NEW" => Some(Self::New),
                "RUNNING" => Some(Self::Running),
                "COMPLETE" => Some(Self::Complete),
                "FAILED" => Some(Self::Failed),
                "CACHED" => Some(Self::Cached),
                "CANCELLED" => Some(Self::Cancelled),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for Execution {
    const NAME: &'static str = "Execution";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.Execution".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.Execution".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeatureStatsAnomaly {
    #[prost(double, tag = "1")]
    pub score: f64,
    #[prost(string, tag = "3")]
    pub stats_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub anomaly_uri: ::prost::alloc::string::String,
    #[prost(double, tag = "5")]
    pub distribution_deviation: f64,
    #[prost(double, tag = "9")]
    pub anomaly_detection_threshold: f64,
    #[prost(message, optional, tag = "7")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
}
impl ::prost::Name for FeatureStatsAnomaly {
    const NAME: &'static str = "FeatureStatsAnomaly";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.FeatureStatsAnomaly".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.FeatureStatsAnomaly".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Feature {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    #[prost(enumeration = "feature::ValueType", tag = "3")]
    pub value_type: i32,
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "5")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "6")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "7")]
    pub etag: ::prost::alloc::string::String,
    #[prost(bool, tag = "12")]
    pub disable_monitoring: bool,
    #[prost(message, repeated, tag = "11")]
    pub monitoring_stats_anomalies: ::prost::alloc::vec::Vec<
        feature::MonitoringStatsAnomaly,
    >,
    #[prost(string, tag = "106")]
    pub version_column_name: ::prost::alloc::string::String,
    #[prost(string, tag = "107")]
    pub point_of_contact: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Feature`.
pub mod feature {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MonitoringStatsAnomaly {
        #[prost(enumeration = "monitoring_stats_anomaly::Objective", tag = "1")]
        pub objective: i32,
        #[prost(message, optional, tag = "2")]
        pub feature_stats_anomaly: ::core::option::Option<super::FeatureStatsAnomaly>,
    }
    /// Nested message and enum types in `MonitoringStatsAnomaly`.
    pub mod monitoring_stats_anomaly {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Objective {
            Unspecified = 0,
            ImportFeatureAnalysis = 1,
            SnapshotAnalysis = 2,
        }
        impl Objective {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "OBJECTIVE_UNSPECIFIED",
                    Self::ImportFeatureAnalysis => "IMPORT_FEATURE_ANALYSIS",
                    Self::SnapshotAnalysis => "SNAPSHOT_ANALYSIS",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "OBJECTIVE_UNSPECIFIED" => Some(Self::Unspecified),
                    "IMPORT_FEATURE_ANALYSIS" => Some(Self::ImportFeatureAnalysis),
                    "SNAPSHOT_ANALYSIS" => Some(Self::SnapshotAnalysis),
                    _ => None,
                }
            }
        }
    }
    impl ::prost::Name for MonitoringStatsAnomaly {
        const NAME: &'static str = "MonitoringStatsAnomaly";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.Feature.MonitoringStatsAnomaly".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.Feature.MonitoringStatsAnomaly"
                .into()
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ValueType {
        Unspecified = 0,
        Bool = 1,
        BoolArray = 2,
        Double = 3,
        DoubleArray = 4,
        Int64 = 9,
        Int64Array = 10,
        String = 11,
        StringArray = 12,
        Bytes = 13,
        Struct = 14,
    }
    impl ValueType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "VALUE_TYPE_UNSPECIFIED",
                Self::Bool => "BOOL",
                Self::BoolArray => "BOOL_ARRAY",
                Self::Double => "DOUBLE",
                Self::DoubleArray => "DOUBLE_ARRAY",
                Self::Int64 => "INT64",
                Self::Int64Array => "INT64_ARRAY",
                Self::String => "STRING",
                Self::StringArray => "STRING_ARRAY",
                Self::Bytes => "BYTES",
                Self::Struct => "STRUCT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "VALUE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "BOOL" => Some(Self::Bool),
                "BOOL_ARRAY" => Some(Self::BoolArray),
                "DOUBLE" => Some(Self::Double),
                "DOUBLE_ARRAY" => Some(Self::DoubleArray),
                "INT64" => Some(Self::Int64),
                "INT64_ARRAY" => Some(Self::Int64Array),
                "STRING" => Some(Self::String),
                "STRING_ARRAY" => Some(Self::StringArray),
                "BYTES" => Some(Self::Bytes),
                "STRUCT" => Some(Self::Struct),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for Feature {
    const NAME: &'static str = "Feature";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.Feature".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.Feature".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeatureGroup {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "4")]
    pub etag: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "5")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "6")]
    pub description: ::prost::alloc::string::String,
    #[prost(oneof = "feature_group::Source", tags = "7")]
    pub source: ::core::option::Option<feature_group::Source>,
}
/// Nested message and enum types in `FeatureGroup`.
pub mod feature_group {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BigQuery {
        #[prost(message, optional, tag = "1")]
        pub big_query_source: ::core::option::Option<super::BigQuerySource>,
        #[prost(string, repeated, tag = "2")]
        pub entity_id_columns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(bool, tag = "3")]
        pub static_data_source: bool,
        #[prost(message, optional, tag = "4")]
        pub time_series: ::core::option::Option<big_query::TimeSeries>,
        #[prost(bool, tag = "5")]
        pub dense: bool,
    }
    /// Nested message and enum types in `BigQuery`.
    pub mod big_query {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct TimeSeries {
            #[prost(string, tag = "1")]
            pub timestamp_column: ::prost::alloc::string::String,
        }
        impl ::prost::Name for TimeSeries {
            const NAME: &'static str = "TimeSeries";
            const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "google.cloud.aiplatform.v1.FeatureGroup.BigQuery.TimeSeries".into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.cloud.aiplatform.v1.FeatureGroup.BigQuery.TimeSeries"
                    .into()
            }
        }
    }
    impl ::prost::Name for BigQuery {
        const NAME: &'static str = "BigQuery";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.FeatureGroup.BigQuery".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeatureGroup.BigQuery".into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        #[prost(message, tag = "7")]
        BigQuery(BigQuery),
    }
}
impl ::prost::Name for FeatureGroup {
    const NAME: &'static str = "FeatureGroup";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.FeatureGroup".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.FeatureGroup".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeatureOnlineStore {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "5")]
    pub etag: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "6")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(enumeration = "feature_online_store::State", tag = "7")]
    pub state: i32,
    #[prost(message, optional, tag = "10")]
    pub dedicated_serving_endpoint: ::core::option::Option<
        feature_online_store::DedicatedServingEndpoint,
    >,
    #[prost(message, optional, tag = "13")]
    pub encryption_spec: ::core::option::Option<EncryptionSpec>,
    #[prost(bool, tag = "15")]
    pub satisfies_pzs: bool,
    #[prost(bool, tag = "16")]
    pub satisfies_pzi: bool,
    #[prost(oneof = "feature_online_store::StorageType", tags = "8, 12")]
    pub storage_type: ::core::option::Option<feature_online_store::StorageType>,
}
/// Nested message and enum types in `FeatureOnlineStore`.
pub mod feature_online_store {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Bigtable {
        #[prost(message, optional, tag = "1")]
        pub auto_scaling: ::core::option::Option<bigtable::AutoScaling>,
    }
    /// Nested message and enum types in `Bigtable`.
    pub mod bigtable {
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct AutoScaling {
            #[prost(int32, tag = "1")]
            pub min_node_count: i32,
            #[prost(int32, tag = "2")]
            pub max_node_count: i32,
            #[prost(int32, tag = "3")]
            pub cpu_utilization_target: i32,
        }
        impl ::prost::Name for AutoScaling {
            const NAME: &'static str = "AutoScaling";
            const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "google.cloud.aiplatform.v1.FeatureOnlineStore.Bigtable.AutoScaling"
                    .into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.cloud.aiplatform.v1.FeatureOnlineStore.Bigtable.AutoScaling"
                    .into()
            }
        }
    }
    impl ::prost::Name for Bigtable {
        const NAME: &'static str = "Bigtable";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.FeatureOnlineStore.Bigtable".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeatureOnlineStore.Bigtable"
                .into()
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Optimized {}
    impl ::prost::Name for Optimized {
        const NAME: &'static str = "Optimized";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.FeatureOnlineStore.Optimized".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeatureOnlineStore.Optimized"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DedicatedServingEndpoint {
        #[prost(string, tag = "2")]
        pub public_endpoint_domain_name: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "3")]
        pub private_service_connect_config: ::core::option::Option<
            super::PrivateServiceConnectConfig,
        >,
        #[prost(string, tag = "4")]
        pub service_attachment: ::prost::alloc::string::String,
    }
    impl ::prost::Name for DedicatedServingEndpoint {
        const NAME: &'static str = "DedicatedServingEndpoint";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.FeatureOnlineStore.DedicatedServingEndpoint"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeatureOnlineStore.DedicatedServingEndpoint"
                .into()
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Stable = 1,
        Updating = 2,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Stable => "STABLE",
                Self::Updating => "UPDATING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "STABLE" => Some(Self::Stable),
                "UPDATING" => Some(Self::Updating),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum StorageType {
        #[prost(message, tag = "8")]
        Bigtable(Bigtable),
        #[prost(message, tag = "12")]
        Optimized(Optimized),
    }
}
impl ::prost::Name for FeatureOnlineStore {
    const NAME: &'static str = "FeatureOnlineStore";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.FeatureOnlineStore".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.FeatureOnlineStore".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeatureView {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "4")]
    pub etag: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "5")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "7")]
    pub sync_config: ::core::option::Option<feature_view::SyncConfig>,
    #[prost(message, optional, tag = "15")]
    pub index_config: ::core::option::Option<feature_view::IndexConfig>,
    #[prost(message, optional, tag = "16")]
    pub optimized_config: ::core::option::Option<feature_view::OptimizedConfig>,
    #[prost(enumeration = "feature_view::ServiceAgentType", tag = "14")]
    pub service_agent_type: i32,
    #[prost(string, tag = "13")]
    pub service_account_email: ::prost::alloc::string::String,
    #[prost(bool, tag = "19")]
    pub satisfies_pzs: bool,
    #[prost(bool, tag = "20")]
    pub satisfies_pzi: bool,
    #[prost(oneof = "feature_view::Source", tags = "6, 9, 18")]
    pub source: ::core::option::Option<feature_view::Source>,
}
/// Nested message and enum types in `FeatureView`.
pub mod feature_view {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BigQuerySource {
        #[prost(string, tag = "1")]
        pub uri: ::prost::alloc::string::String,
        #[prost(string, repeated, tag = "2")]
        pub entity_id_columns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    impl ::prost::Name for BigQuerySource {
        const NAME: &'static str = "BigQuerySource";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.FeatureView.BigQuerySource".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeatureView.BigQuerySource"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SyncConfig {
        #[prost(string, tag = "1")]
        pub cron: ::prost::alloc::string::String,
        #[prost(bool, tag = "2")]
        pub continuous: bool,
    }
    impl ::prost::Name for SyncConfig {
        const NAME: &'static str = "SyncConfig";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.FeatureView.SyncConfig".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeatureView.SyncConfig"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IndexConfig {
        #[prost(string, tag = "1")]
        pub embedding_column: ::prost::alloc::string::String,
        #[prost(string, repeated, tag = "2")]
        pub filter_columns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, tag = "3")]
        pub crowding_column: ::prost::alloc::string::String,
        #[prost(int32, optional, tag = "4")]
        pub embedding_dimension: ::core::option::Option<i32>,
        #[prost(enumeration = "index_config::DistanceMeasureType", tag = "5")]
        pub distance_measure_type: i32,
        #[prost(oneof = "index_config::AlgorithmConfig", tags = "6, 7")]
        pub algorithm_config: ::core::option::Option<index_config::AlgorithmConfig>,
    }
    /// Nested message and enum types in `IndexConfig`.
    pub mod index_config {
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct BruteForceConfig {}
        impl ::prost::Name for BruteForceConfig {
            const NAME: &'static str = "BruteForceConfig";
            const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "google.cloud.aiplatform.v1.FeatureView.IndexConfig.BruteForceConfig"
                    .into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.cloud.aiplatform.v1.FeatureView.IndexConfig.BruteForceConfig"
                    .into()
            }
        }
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct TreeAhConfig {
            #[prost(int64, optional, tag = "1")]
            pub leaf_node_embedding_count: ::core::option::Option<i64>,
        }
        impl ::prost::Name for TreeAhConfig {
            const NAME: &'static str = "TreeAHConfig";
            const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "google.cloud.aiplatform.v1.FeatureView.IndexConfig.TreeAHConfig".into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.cloud.aiplatform.v1.FeatureView.IndexConfig.TreeAHConfig"
                    .into()
            }
        }
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum DistanceMeasureType {
            Unspecified = 0,
            SquaredL2Distance = 1,
            CosineDistance = 2,
            DotProductDistance = 3,
        }
        impl DistanceMeasureType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "DISTANCE_MEASURE_TYPE_UNSPECIFIED",
                    Self::SquaredL2Distance => "SQUARED_L2_DISTANCE",
                    Self::CosineDistance => "COSINE_DISTANCE",
                    Self::DotProductDistance => "DOT_PRODUCT_DISTANCE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "DISTANCE_MEASURE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "SQUARED_L2_DISTANCE" => Some(Self::SquaredL2Distance),
                    "COSINE_DISTANCE" => Some(Self::CosineDistance),
                    "DOT_PRODUCT_DISTANCE" => Some(Self::DotProductDistance),
                    _ => None,
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum AlgorithmConfig {
            #[prost(message, tag = "6")]
            TreeAhConfig(TreeAhConfig),
            #[prost(message, tag = "7")]
            BruteForceConfig(BruteForceConfig),
        }
    }
    impl ::prost::Name for IndexConfig {
        const NAME: &'static str = "IndexConfig";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.FeatureView.IndexConfig".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeatureView.IndexConfig"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FeatureRegistrySource {
        #[prost(message, repeated, tag = "1")]
        pub feature_groups: ::prost::alloc::vec::Vec<
            feature_registry_source::FeatureGroup,
        >,
        #[prost(int64, optional, tag = "2")]
        pub project_number: ::core::option::Option<i64>,
    }
    /// Nested message and enum types in `FeatureRegistrySource`.
    pub mod feature_registry_source {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct FeatureGroup {
            #[prost(string, tag = "1")]
            pub feature_group_id: ::prost::alloc::string::String,
            #[prost(string, repeated, tag = "2")]
            pub feature_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
        impl ::prost::Name for FeatureGroup {
            const NAME: &'static str = "FeatureGroup";
            const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "google.cloud.aiplatform.v1.FeatureView.FeatureRegistrySource.FeatureGroup"
                    .into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.cloud.aiplatform.v1.FeatureView.FeatureRegistrySource.FeatureGroup"
                    .into()
            }
        }
    }
    impl ::prost::Name for FeatureRegistrySource {
        const NAME: &'static str = "FeatureRegistrySource";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.FeatureView.FeatureRegistrySource".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeatureView.FeatureRegistrySource"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct VertexRagSource {
        #[prost(string, tag = "1")]
        pub uri: ::prost::alloc::string::String,
        #[prost(int64, tag = "2")]
        pub rag_corpus_id: i64,
    }
    impl ::prost::Name for VertexRagSource {
        const NAME: &'static str = "VertexRagSource";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.FeatureView.VertexRagSource".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeatureView.VertexRagSource"
                .into()
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct OptimizedConfig {
        #[prost(message, optional, tag = "7")]
        pub automatic_resources: ::core::option::Option<super::AutomaticResources>,
    }
    impl ::prost::Name for OptimizedConfig {
        const NAME: &'static str = "OptimizedConfig";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.FeatureView.OptimizedConfig".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeatureView.OptimizedConfig"
                .into()
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ServiceAgentType {
        Unspecified = 0,
        Project = 1,
        FeatureView = 2,
    }
    impl ServiceAgentType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SERVICE_AGENT_TYPE_UNSPECIFIED",
                Self::Project => "SERVICE_AGENT_TYPE_PROJECT",
                Self::FeatureView => "SERVICE_AGENT_TYPE_FEATURE_VIEW",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SERVICE_AGENT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "SERVICE_AGENT_TYPE_PROJECT" => Some(Self::Project),
                "SERVICE_AGENT_TYPE_FEATURE_VIEW" => Some(Self::FeatureView),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        #[prost(message, tag = "6")]
        BigQuerySource(BigQuerySource),
        #[prost(message, tag = "9")]
        FeatureRegistrySource(FeatureRegistrySource),
        #[prost(message, tag = "18")]
        VertexRagSource(VertexRagSource),
    }
}
impl ::prost::Name for FeatureView {
    const NAME: &'static str = "FeatureView";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.FeatureView".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.FeatureView".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeatureViewSync {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "5")]
    pub run_time: ::core::option::Option<super::super::super::r#type::Interval>,
    #[prost(message, optional, tag = "4")]
    pub final_status: ::core::option::Option<super::super::super::rpc::Status>,
    #[prost(message, optional, tag = "6")]
    pub sync_summary: ::core::option::Option<feature_view_sync::SyncSummary>,
    #[prost(bool, tag = "7")]
    pub satisfies_pzs: bool,
    #[prost(bool, tag = "8")]
    pub satisfies_pzi: bool,
}
/// Nested message and enum types in `FeatureViewSync`.
pub mod feature_view_sync {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SyncSummary {
        #[prost(int64, tag = "1")]
        pub row_synced: i64,
        #[prost(int64, tag = "2")]
        pub total_slot: i64,
        #[prost(message, optional, tag = "5")]
        pub system_watermark_time: ::core::option::Option<::prost_types::Timestamp>,
    }
    impl ::prost::Name for SyncSummary {
        const NAME: &'static str = "SyncSummary";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.FeatureViewSync.SyncSummary".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeatureViewSync.SyncSummary"
                .into()
        }
    }
}
impl ::prost::Name for FeatureViewSync {
    const NAME: &'static str = "FeatureViewSync";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.FeatureViewSync".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.FeatureViewSync".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateFeatureOnlineStoreRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub feature_online_store: ::core::option::Option<FeatureOnlineStore>,
    #[prost(string, tag = "3")]
    pub feature_online_store_id: ::prost::alloc::string::String,
}
impl ::prost::Name for CreateFeatureOnlineStoreRequest {
    const NAME: &'static str = "CreateFeatureOnlineStoreRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateFeatureOnlineStoreRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateFeatureOnlineStoreRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFeatureOnlineStoreRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for GetFeatureOnlineStoreRequest {
    const NAME: &'static str = "GetFeatureOnlineStoreRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetFeatureOnlineStoreRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetFeatureOnlineStoreRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFeatureOnlineStoresRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
impl ::prost::Name for ListFeatureOnlineStoresRequest {
    const NAME: &'static str = "ListFeatureOnlineStoresRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListFeatureOnlineStoresRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListFeatureOnlineStoresRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFeatureOnlineStoresResponse {
    #[prost(message, repeated, tag = "1")]
    pub feature_online_stores: ::prost::alloc::vec::Vec<FeatureOnlineStore>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListFeatureOnlineStoresResponse {
    const NAME: &'static str = "ListFeatureOnlineStoresResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListFeatureOnlineStoresResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListFeatureOnlineStoresResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFeatureOnlineStoreRequest {
    #[prost(message, optional, tag = "1")]
    pub feature_online_store: ::core::option::Option<FeatureOnlineStore>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for UpdateFeatureOnlineStoreRequest {
    const NAME: &'static str = "UpdateFeatureOnlineStoreRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdateFeatureOnlineStoreRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateFeatureOnlineStoreRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteFeatureOnlineStoreRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub force: bool,
}
impl ::prost::Name for DeleteFeatureOnlineStoreRequest {
    const NAME: &'static str = "DeleteFeatureOnlineStoreRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeleteFeatureOnlineStoreRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteFeatureOnlineStoreRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateFeatureViewRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub feature_view: ::core::option::Option<FeatureView>,
    #[prost(string, tag = "3")]
    pub feature_view_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub run_sync_immediately: bool,
}
impl ::prost::Name for CreateFeatureViewRequest {
    const NAME: &'static str = "CreateFeatureViewRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateFeatureViewRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateFeatureViewRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFeatureViewRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for GetFeatureViewRequest {
    const NAME: &'static str = "GetFeatureViewRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetFeatureViewRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetFeatureViewRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFeatureViewsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
impl ::prost::Name for ListFeatureViewsRequest {
    const NAME: &'static str = "ListFeatureViewsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListFeatureViewsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListFeatureViewsRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFeatureViewsResponse {
    #[prost(message, repeated, tag = "1")]
    pub feature_views: ::prost::alloc::vec::Vec<FeatureView>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListFeatureViewsResponse {
    const NAME: &'static str = "ListFeatureViewsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListFeatureViewsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListFeatureViewsResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFeatureViewRequest {
    #[prost(message, optional, tag = "1")]
    pub feature_view: ::core::option::Option<FeatureView>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for UpdateFeatureViewRequest {
    const NAME: &'static str = "UpdateFeatureViewRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdateFeatureViewRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateFeatureViewRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteFeatureViewRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for DeleteFeatureViewRequest {
    const NAME: &'static str = "DeleteFeatureViewRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeleteFeatureViewRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteFeatureViewRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateFeatureOnlineStoreOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for CreateFeatureOnlineStoreOperationMetadata {
    const NAME: &'static str = "CreateFeatureOnlineStoreOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateFeatureOnlineStoreOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateFeatureOnlineStoreOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFeatureOnlineStoreOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for UpdateFeatureOnlineStoreOperationMetadata {
    const NAME: &'static str = "UpdateFeatureOnlineStoreOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdateFeatureOnlineStoreOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateFeatureOnlineStoreOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateFeatureViewOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for CreateFeatureViewOperationMetadata {
    const NAME: &'static str = "CreateFeatureViewOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateFeatureViewOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateFeatureViewOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFeatureViewOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for UpdateFeatureViewOperationMetadata {
    const NAME: &'static str = "UpdateFeatureViewOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdateFeatureViewOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateFeatureViewOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncFeatureViewRequest {
    #[prost(string, tag = "1")]
    pub feature_view: ::prost::alloc::string::String,
}
impl ::prost::Name for SyncFeatureViewRequest {
    const NAME: &'static str = "SyncFeatureViewRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SyncFeatureViewRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SyncFeatureViewRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncFeatureViewResponse {
    #[prost(string, tag = "1")]
    pub feature_view_sync: ::prost::alloc::string::String,
}
impl ::prost::Name for SyncFeatureViewResponse {
    const NAME: &'static str = "SyncFeatureViewResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SyncFeatureViewResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SyncFeatureViewResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFeatureViewSyncRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for GetFeatureViewSyncRequest {
    const NAME: &'static str = "GetFeatureViewSyncRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetFeatureViewSyncRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetFeatureViewSyncRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFeatureViewSyncsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
impl ::prost::Name for ListFeatureViewSyncsRequest {
    const NAME: &'static str = "ListFeatureViewSyncsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListFeatureViewSyncsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListFeatureViewSyncsRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFeatureViewSyncsResponse {
    #[prost(message, repeated, tag = "1")]
    pub feature_view_syncs: ::prost::alloc::vec::Vec<FeatureViewSync>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListFeatureViewSyncsResponse {
    const NAME: &'static str = "ListFeatureViewSyncsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListFeatureViewSyncsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListFeatureViewSyncsResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IdMatcher {
    #[prost(string, repeated, tag = "1")]
    pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for IdMatcher {
    const NAME: &'static str = "IdMatcher";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.IdMatcher".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.IdMatcher".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeatureSelector {
    #[prost(message, optional, tag = "1")]
    pub id_matcher: ::core::option::Option<IdMatcher>,
}
impl ::prost::Name for FeatureSelector {
    const NAME: &'static str = "FeatureSelector";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.FeatureSelector".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.FeatureSelector".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BoolArray {
    #[prost(bool, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<bool>,
}
impl ::prost::Name for BoolArray {
    const NAME: &'static str = "BoolArray";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.BoolArray".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.BoolArray".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DoubleArray {
    #[prost(double, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<f64>,
}
impl ::prost::Name for DoubleArray {
    const NAME: &'static str = "DoubleArray";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DoubleArray".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DoubleArray".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Int64Array {
    #[prost(int64, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<i64>,
}
impl ::prost::Name for Int64Array {
    const NAME: &'static str = "Int64Array";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.Int64Array".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.Int64Array".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StringArray {
    #[prost(string, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for StringArray {
    const NAME: &'static str = "StringArray";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.StringArray".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.StringArray".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Tensor {
    #[prost(enumeration = "tensor::DataType", tag = "1")]
    pub dtype: i32,
    #[prost(int64, repeated, tag = "2")]
    pub shape: ::prost::alloc::vec::Vec<i64>,
    #[prost(bool, repeated, tag = "3")]
    pub bool_val: ::prost::alloc::vec::Vec<bool>,
    #[prost(string, repeated, tag = "14")]
    pub string_val: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bytes = "bytes", repeated, tag = "15")]
    pub bytes_val: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
    #[prost(float, repeated, tag = "5")]
    pub float_val: ::prost::alloc::vec::Vec<f32>,
    #[prost(double, repeated, tag = "6")]
    pub double_val: ::prost::alloc::vec::Vec<f64>,
    #[prost(int32, repeated, tag = "7")]
    pub int_val: ::prost::alloc::vec::Vec<i32>,
    #[prost(int64, repeated, tag = "8")]
    pub int64_val: ::prost::alloc::vec::Vec<i64>,
    #[prost(uint32, repeated, tag = "9")]
    pub uint_val: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint64, repeated, tag = "10")]
    pub uint64_val: ::prost::alloc::vec::Vec<u64>,
    #[prost(message, repeated, tag = "11")]
    pub list_val: ::prost::alloc::vec::Vec<Tensor>,
    #[prost(map = "string, message", tag = "12")]
    pub struct_val: ::std::collections::HashMap<::prost::alloc::string::String, Tensor>,
    #[prost(bytes = "bytes", tag = "13")]
    pub tensor_val: ::prost::bytes::Bytes,
}
/// Nested message and enum types in `Tensor`.
pub mod tensor {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DataType {
        Unspecified = 0,
        Bool = 1,
        String = 2,
        Float = 3,
        Double = 4,
        Int8 = 5,
        Int16 = 6,
        Int32 = 7,
        Int64 = 8,
        Uint8 = 9,
        Uint16 = 10,
        Uint32 = 11,
        Uint64 = 12,
    }
    impl DataType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "DATA_TYPE_UNSPECIFIED",
                Self::Bool => "BOOL",
                Self::String => "STRING",
                Self::Float => "FLOAT",
                Self::Double => "DOUBLE",
                Self::Int8 => "INT8",
                Self::Int16 => "INT16",
                Self::Int32 => "INT32",
                Self::Int64 => "INT64",
                Self::Uint8 => "UINT8",
                Self::Uint16 => "UINT16",
                Self::Uint32 => "UINT32",
                Self::Uint64 => "UINT64",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DATA_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "BOOL" => Some(Self::Bool),
                "STRING" => Some(Self::String),
                "FLOAT" => Some(Self::Float),
                "DOUBLE" => Some(Self::Double),
                "INT8" => Some(Self::Int8),
                "INT16" => Some(Self::Int16),
                "INT32" => Some(Self::Int32),
                "INT64" => Some(Self::Int64),
                "UINT8" => Some(Self::Uint8),
                "UINT16" => Some(Self::Uint16),
                "UINT32" => Some(Self::Uint32),
                "UINT64" => Some(Self::Uint64),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for Tensor {
    const NAME: &'static str = "Tensor";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.Tensor".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.Tensor".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteFeatureValuesRequest {
    #[prost(string, tag = "1")]
    pub entity_type: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub payloads: ::prost::alloc::vec::Vec<WriteFeatureValuesPayload>,
}
impl ::prost::Name for WriteFeatureValuesRequest {
    const NAME: &'static str = "WriteFeatureValuesRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.WriteFeatureValuesRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.WriteFeatureValuesRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteFeatureValuesPayload {
    #[prost(string, tag = "1")]
    pub entity_id: ::prost::alloc::string::String,
    #[prost(map = "string, message", tag = "2")]
    pub feature_values: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        FeatureValue,
    >,
}
impl ::prost::Name for WriteFeatureValuesPayload {
    const NAME: &'static str = "WriteFeatureValuesPayload";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.WriteFeatureValuesPayload".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.WriteFeatureValuesPayload".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WriteFeatureValuesResponse {}
impl ::prost::Name for WriteFeatureValuesResponse {
    const NAME: &'static str = "WriteFeatureValuesResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.WriteFeatureValuesResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.WriteFeatureValuesResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadFeatureValuesRequest {
    #[prost(string, tag = "1")]
    pub entity_type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub entity_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub feature_selector: ::core::option::Option<FeatureSelector>,
}
impl ::prost::Name for ReadFeatureValuesRequest {
    const NAME: &'static str = "ReadFeatureValuesRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ReadFeatureValuesRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ReadFeatureValuesRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadFeatureValuesResponse {
    #[prost(message, optional, tag = "1")]
    pub header: ::core::option::Option<read_feature_values_response::Header>,
    #[prost(message, optional, tag = "2")]
    pub entity_view: ::core::option::Option<read_feature_values_response::EntityView>,
}
/// Nested message and enum types in `ReadFeatureValuesResponse`.
pub mod read_feature_values_response {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FeatureDescriptor {
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
    }
    impl ::prost::Name for FeatureDescriptor {
        const NAME: &'static str = "FeatureDescriptor";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.ReadFeatureValuesResponse.FeatureDescriptor"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.ReadFeatureValuesResponse.FeatureDescriptor"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Header {
        #[prost(string, tag = "1")]
        pub entity_type: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "2")]
        pub feature_descriptors: ::prost::alloc::vec::Vec<FeatureDescriptor>,
    }
    impl ::prost::Name for Header {
        const NAME: &'static str = "Header";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.ReadFeatureValuesResponse.Header".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.ReadFeatureValuesResponse.Header"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EntityView {
        #[prost(string, tag = "1")]
        pub entity_id: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "2")]
        pub data: ::prost::alloc::vec::Vec<entity_view::Data>,
    }
    /// Nested message and enum types in `EntityView`.
    pub mod entity_view {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Data {
            #[prost(oneof = "data::Data", tags = "1, 2")]
            pub data: ::core::option::Option<data::Data>,
        }
        /// Nested message and enum types in `Data`.
        pub mod data {
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum Data {
                #[prost(message, tag = "1")]
                Value(super::super::super::FeatureValue),
                #[prost(message, tag = "2")]
                Values(super::super::super::FeatureValueList),
            }
        }
        impl ::prost::Name for Data {
            const NAME: &'static str = "Data";
            const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "google.cloud.aiplatform.v1.ReadFeatureValuesResponse.EntityView.Data"
                    .into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.cloud.aiplatform.v1.ReadFeatureValuesResponse.EntityView.Data"
                    .into()
            }
        }
    }
    impl ::prost::Name for EntityView {
        const NAME: &'static str = "EntityView";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.ReadFeatureValuesResponse.EntityView".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.ReadFeatureValuesResponse.EntityView"
                .into()
        }
    }
}
impl ::prost::Name for ReadFeatureValuesResponse {
    const NAME: &'static str = "ReadFeatureValuesResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ReadFeatureValuesResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ReadFeatureValuesResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamingReadFeatureValuesRequest {
    #[prost(string, tag = "1")]
    pub entity_type: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub entity_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "3")]
    pub feature_selector: ::core::option::Option<FeatureSelector>,
}
impl ::prost::Name for StreamingReadFeatureValuesRequest {
    const NAME: &'static str = "StreamingReadFeatureValuesRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.StreamingReadFeatureValuesRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.StreamingReadFeatureValuesRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeatureValue {
    #[prost(message, optional, tag = "14")]
    pub metadata: ::core::option::Option<feature_value::Metadata>,
    #[prost(oneof = "feature_value::Value", tags = "1, 2, 5, 6, 7, 8, 11, 12, 13, 15")]
    pub value: ::core::option::Option<feature_value::Value>,
}
/// Nested message and enum types in `FeatureValue`.
pub mod feature_value {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Metadata {
        #[prost(message, optional, tag = "1")]
        pub generate_time: ::core::option::Option<::prost_types::Timestamp>,
    }
    impl ::prost::Name for Metadata {
        const NAME: &'static str = "Metadata";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.FeatureValue.Metadata".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeatureValue.Metadata".into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(bool, tag = "1")]
        BoolValue(bool),
        #[prost(double, tag = "2")]
        DoubleValue(f64),
        #[prost(int64, tag = "5")]
        Int64Value(i64),
        #[prost(string, tag = "6")]
        StringValue(::prost::alloc::string::String),
        #[prost(message, tag = "7")]
        BoolArrayValue(super::BoolArray),
        #[prost(message, tag = "8")]
        DoubleArrayValue(super::DoubleArray),
        #[prost(message, tag = "11")]
        Int64ArrayValue(super::Int64Array),
        #[prost(message, tag = "12")]
        StringArrayValue(super::StringArray),
        #[prost(bytes, tag = "13")]
        BytesValue(::prost::bytes::Bytes),
        #[prost(message, tag = "15")]
        StructValue(super::StructValue),
    }
}
impl ::prost::Name for FeatureValue {
    const NAME: &'static str = "FeatureValue";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.FeatureValue".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.FeatureValue".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StructValue {
    #[prost(message, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<StructFieldValue>,
}
impl ::prost::Name for StructValue {
    const NAME: &'static str = "StructValue";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.StructValue".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.StructValue".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StructFieldValue {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub value: ::core::option::Option<FeatureValue>,
}
impl ::prost::Name for StructFieldValue {
    const NAME: &'static str = "StructFieldValue";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.StructFieldValue".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.StructFieldValue".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeatureValueList {
    #[prost(message, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<FeatureValue>,
}
impl ::prost::Name for FeatureValueList {
    const NAME: &'static str = "FeatureValueList";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.FeatureValueList".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.FeatureValueList".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeatureViewDataKey {
    #[prost(oneof = "feature_view_data_key::KeyOneof", tags = "1, 2")]
    pub key_oneof: ::core::option::Option<feature_view_data_key::KeyOneof>,
}
/// Nested message and enum types in `FeatureViewDataKey`.
pub mod feature_view_data_key {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CompositeKey {
        #[prost(string, repeated, tag = "1")]
        pub parts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    impl ::prost::Name for CompositeKey {
        const NAME: &'static str = "CompositeKey";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.FeatureViewDataKey.CompositeKey".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeatureViewDataKey.CompositeKey"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum KeyOneof {
        #[prost(string, tag = "1")]
        Key(::prost::alloc::string::String),
        #[prost(message, tag = "2")]
        CompositeKey(CompositeKey),
    }
}
impl ::prost::Name for FeatureViewDataKey {
    const NAME: &'static str = "FeatureViewDataKey";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.FeatureViewDataKey".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.FeatureViewDataKey".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchFeatureValuesRequest {
    #[prost(string, tag = "1")]
    pub feature_view: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub data_key: ::core::option::Option<FeatureViewDataKey>,
    #[prost(enumeration = "FeatureViewDataFormat", tag = "7")]
    pub data_format: i32,
}
impl ::prost::Name for FetchFeatureValuesRequest {
    const NAME: &'static str = "FetchFeatureValuesRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.FetchFeatureValuesRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.FetchFeatureValuesRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchFeatureValuesResponse {
    #[prost(message, optional, tag = "4")]
    pub data_key: ::core::option::Option<FeatureViewDataKey>,
    #[prost(oneof = "fetch_feature_values_response::Format", tags = "3, 2")]
    pub format: ::core::option::Option<fetch_feature_values_response::Format>,
}
/// Nested message and enum types in `FetchFeatureValuesResponse`.
pub mod fetch_feature_values_response {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FeatureNameValuePairList {
        #[prost(message, repeated, tag = "1")]
        pub features: ::prost::alloc::vec::Vec<
            feature_name_value_pair_list::FeatureNameValuePair,
        >,
    }
    /// Nested message and enum types in `FeatureNameValuePairList`.
    pub mod feature_name_value_pair_list {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct FeatureNameValuePair {
            #[prost(string, tag = "1")]
            pub name: ::prost::alloc::string::String,
            #[prost(oneof = "feature_name_value_pair::Data", tags = "2")]
            pub data: ::core::option::Option<feature_name_value_pair::Data>,
        }
        /// Nested message and enum types in `FeatureNameValuePair`.
        pub mod feature_name_value_pair {
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum Data {
                #[prost(message, tag = "2")]
                Value(super::super::super::FeatureValue),
            }
        }
        impl ::prost::Name for FeatureNameValuePair {
            const NAME: &'static str = "FeatureNameValuePair";
            const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "google.cloud.aiplatform.v1.FetchFeatureValuesResponse.FeatureNameValuePairList.FeatureNameValuePair"
                    .into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.cloud.aiplatform.v1.FetchFeatureValuesResponse.FeatureNameValuePairList.FeatureNameValuePair"
                    .into()
            }
        }
    }
    impl ::prost::Name for FeatureNameValuePairList {
        const NAME: &'static str = "FeatureNameValuePairList";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.FetchFeatureValuesResponse.FeatureNameValuePairList"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.FetchFeatureValuesResponse.FeatureNameValuePairList"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Format {
        #[prost(message, tag = "3")]
        KeyValues(FeatureNameValuePairList),
        #[prost(message, tag = "2")]
        ProtoStruct(::prost_types::Struct),
    }
}
impl ::prost::Name for FetchFeatureValuesResponse {
    const NAME: &'static str = "FetchFeatureValuesResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.FetchFeatureValuesResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.FetchFeatureValuesResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NearestNeighborQuery {
    #[prost(int32, tag = "3")]
    pub neighbor_count: i32,
    #[prost(message, repeated, tag = "4")]
    pub string_filters: ::prost::alloc::vec::Vec<nearest_neighbor_query::StringFilter>,
    #[prost(message, repeated, tag = "8")]
    pub numeric_filters: ::prost::alloc::vec::Vec<nearest_neighbor_query::NumericFilter>,
    #[prost(int32, tag = "5")]
    pub per_crowding_attribute_neighbor_count: i32,
    #[prost(message, optional, tag = "7")]
    pub parameters: ::core::option::Option<nearest_neighbor_query::Parameters>,
    #[prost(oneof = "nearest_neighbor_query::Instance", tags = "1, 2")]
    pub instance: ::core::option::Option<nearest_neighbor_query::Instance>,
}
/// Nested message and enum types in `NearestNeighborQuery`.
pub mod nearest_neighbor_query {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Embedding {
        #[prost(float, repeated, packed = "false", tag = "1")]
        pub value: ::prost::alloc::vec::Vec<f32>,
    }
    impl ::prost::Name for Embedding {
        const NAME: &'static str = "Embedding";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.NearestNeighborQuery.Embedding".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.NearestNeighborQuery.Embedding"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StringFilter {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(string, repeated, tag = "2")]
        pub allow_tokens: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "3")]
        pub deny_tokens: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    impl ::prost::Name for StringFilter {
        const NAME: &'static str = "StringFilter";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.NearestNeighborQuery.StringFilter".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.NearestNeighborQuery.StringFilter"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NumericFilter {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(enumeration = "numeric_filter::Operator", optional, tag = "5")]
        pub op: ::core::option::Option<i32>,
        #[prost(oneof = "numeric_filter::Value", tags = "2, 3, 4")]
        pub value: ::core::option::Option<numeric_filter::Value>,
    }
    /// Nested message and enum types in `NumericFilter`.
    pub mod numeric_filter {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Operator {
            Unspecified = 0,
            Less = 1,
            LessEqual = 2,
            Equal = 3,
            GreaterEqual = 4,
            Greater = 5,
            NotEqual = 6,
        }
        impl Operator {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "OPERATOR_UNSPECIFIED",
                    Self::Less => "LESS",
                    Self::LessEqual => "LESS_EQUAL",
                    Self::Equal => "EQUAL",
                    Self::GreaterEqual => "GREATER_EQUAL",
                    Self::Greater => "GREATER",
                    Self::NotEqual => "NOT_EQUAL",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "OPERATOR_UNSPECIFIED" => Some(Self::Unspecified),
                    "LESS" => Some(Self::Less),
                    "LESS_EQUAL" => Some(Self::LessEqual),
                    "EQUAL" => Some(Self::Equal),
                    "GREATER_EQUAL" => Some(Self::GreaterEqual),
                    "GREATER" => Some(Self::Greater),
                    "NOT_EQUAL" => Some(Self::NotEqual),
                    _ => None,
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum Value {
            #[prost(int64, tag = "2")]
            ValueInt(i64),
            #[prost(float, tag = "3")]
            ValueFloat(f32),
            #[prost(double, tag = "4")]
            ValueDouble(f64),
        }
    }
    impl ::prost::Name for NumericFilter {
        const NAME: &'static str = "NumericFilter";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.NearestNeighborQuery.NumericFilter".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.NearestNeighborQuery.NumericFilter"
                .into()
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Parameters {
        #[prost(int32, tag = "1")]
        pub approximate_neighbor_candidates: i32,
        #[prost(double, tag = "2")]
        pub leaf_nodes_search_fraction: f64,
    }
    impl ::prost::Name for Parameters {
        const NAME: &'static str = "Parameters";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.NearestNeighborQuery.Parameters".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.NearestNeighborQuery.Parameters"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Instance {
        #[prost(string, tag = "1")]
        EntityId(::prost::alloc::string::String),
        #[prost(message, tag = "2")]
        Embedding(Embedding),
    }
}
impl ::prost::Name for NearestNeighborQuery {
    const NAME: &'static str = "NearestNeighborQuery";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.NearestNeighborQuery".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.NearestNeighborQuery".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchNearestEntitiesRequest {
    #[prost(string, tag = "1")]
    pub feature_view: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub query: ::core::option::Option<NearestNeighborQuery>,
    #[prost(bool, tag = "3")]
    pub return_full_entity: bool,
}
impl ::prost::Name for SearchNearestEntitiesRequest {
    const NAME: &'static str = "SearchNearestEntitiesRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SearchNearestEntitiesRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SearchNearestEntitiesRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NearestNeighbors {
    #[prost(message, repeated, tag = "1")]
    pub neighbors: ::prost::alloc::vec::Vec<nearest_neighbors::Neighbor>,
}
/// Nested message and enum types in `NearestNeighbors`.
pub mod nearest_neighbors {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Neighbor {
        #[prost(string, tag = "1")]
        pub entity_id: ::prost::alloc::string::String,
        #[prost(double, tag = "2")]
        pub distance: f64,
        #[prost(message, optional, tag = "3")]
        pub entity_key_values: ::core::option::Option<super::FetchFeatureValuesResponse>,
    }
    impl ::prost::Name for Neighbor {
        const NAME: &'static str = "Neighbor";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.NearestNeighbors.Neighbor".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.NearestNeighbors.Neighbor"
                .into()
        }
    }
}
impl ::prost::Name for NearestNeighbors {
    const NAME: &'static str = "NearestNeighbors";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.NearestNeighbors".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.NearestNeighbors".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchNearestEntitiesResponse {
    #[prost(message, optional, tag = "1")]
    pub nearest_neighbors: ::core::option::Option<NearestNeighbors>,
}
impl ::prost::Name for SearchNearestEntitiesResponse {
    const NAME: &'static str = "SearchNearestEntitiesResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SearchNearestEntitiesResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SearchNearestEntitiesResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeatureViewDirectWriteRequest {
    #[prost(string, tag = "1")]
    pub feature_view: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub data_key_and_feature_values: ::prost::alloc::vec::Vec<
        feature_view_direct_write_request::DataKeyAndFeatureValues,
    >,
}
/// Nested message and enum types in `FeatureViewDirectWriteRequest`.
pub mod feature_view_direct_write_request {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DataKeyAndFeatureValues {
        #[prost(message, optional, tag = "1")]
        pub data_key: ::core::option::Option<super::FeatureViewDataKey>,
        #[prost(message, repeated, tag = "2")]
        pub features: ::prost::alloc::vec::Vec<data_key_and_feature_values::Feature>,
    }
    /// Nested message and enum types in `DataKeyAndFeatureValues`.
    pub mod data_key_and_feature_values {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Feature {
            #[prost(string, tag = "1")]
            pub name: ::prost::alloc::string::String,
            #[prost(oneof = "feature::DataOneof", tags = "3")]
            pub data_oneof: ::core::option::Option<feature::DataOneof>,
        }
        /// Nested message and enum types in `Feature`.
        pub mod feature {
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum DataOneof {
                #[prost(message, tag = "3")]
                Value(super::super::super::FeatureValue),
            }
        }
        impl ::prost::Name for Feature {
            const NAME: &'static str = "Feature";
            const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "google.cloud.aiplatform.v1.FeatureViewDirectWriteRequest.DataKeyAndFeatureValues.Feature"
                    .into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.cloud.aiplatform.v1.FeatureViewDirectWriteRequest.DataKeyAndFeatureValues.Feature"
                    .into()
            }
        }
    }
    impl ::prost::Name for DataKeyAndFeatureValues {
        const NAME: &'static str = "DataKeyAndFeatureValues";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.FeatureViewDirectWriteRequest.DataKeyAndFeatureValues"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeatureViewDirectWriteRequest.DataKeyAndFeatureValues"
                .into()
        }
    }
}
impl ::prost::Name for FeatureViewDirectWriteRequest {
    const NAME: &'static str = "FeatureViewDirectWriteRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.FeatureViewDirectWriteRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.FeatureViewDirectWriteRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeatureViewDirectWriteResponse {
    #[prost(message, optional, tag = "1")]
    pub status: ::core::option::Option<super::super::super::rpc::Status>,
    #[prost(message, repeated, tag = "2")]
    pub write_responses: ::prost::alloc::vec::Vec<
        feature_view_direct_write_response::WriteResponse,
    >,
}
/// Nested message and enum types in `FeatureViewDirectWriteResponse`.
pub mod feature_view_direct_write_response {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct WriteResponse {
        #[prost(message, optional, tag = "1")]
        pub data_key: ::core::option::Option<super::FeatureViewDataKey>,
        #[prost(message, optional, tag = "2")]
        pub online_store_write_time: ::core::option::Option<::prost_types::Timestamp>,
    }
    impl ::prost::Name for WriteResponse {
        const NAME: &'static str = "WriteResponse";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.FeatureViewDirectWriteResponse.WriteResponse"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.FeatureViewDirectWriteResponse.WriteResponse"
                .into()
        }
    }
}
impl ::prost::Name for FeatureViewDirectWriteResponse {
    const NAME: &'static str = "FeatureViewDirectWriteResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.FeatureViewDirectWriteResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.FeatureViewDirectWriteResponse"
            .into()
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FeatureViewDataFormat {
    Unspecified = 0,
    KeyValue = 1,
    ProtoStruct = 2,
}
impl FeatureViewDataFormat {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "FEATURE_VIEW_DATA_FORMAT_UNSPECIFIED",
            Self::KeyValue => "KEY_VALUE",
            Self::ProtoStruct => "PROTO_STRUCT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FEATURE_VIEW_DATA_FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
            "KEY_VALUE" => Some(Self::KeyValue),
            "PROTO_STRUCT" => Some(Self::ProtoStruct),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Featurestore {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "5")]
    pub etag: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "6")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "7")]
    pub online_serving_config: ::core::option::Option<featurestore::OnlineServingConfig>,
    #[prost(enumeration = "featurestore::State", tag = "8")]
    pub state: i32,
    #[prost(int32, tag = "13")]
    pub online_storage_ttl_days: i32,
    #[prost(message, optional, tag = "10")]
    pub encryption_spec: ::core::option::Option<EncryptionSpec>,
    #[prost(bool, tag = "14")]
    pub satisfies_pzs: bool,
    #[prost(bool, tag = "15")]
    pub satisfies_pzi: bool,
}
/// Nested message and enum types in `Featurestore`.
pub mod featurestore {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct OnlineServingConfig {
        #[prost(int32, tag = "2")]
        pub fixed_node_count: i32,
        #[prost(message, optional, tag = "4")]
        pub scaling: ::core::option::Option<online_serving_config::Scaling>,
    }
    /// Nested message and enum types in `OnlineServingConfig`.
    pub mod online_serving_config {
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Scaling {
            #[prost(int32, tag = "1")]
            pub min_node_count: i32,
            #[prost(int32, tag = "2")]
            pub max_node_count: i32,
            #[prost(int32, tag = "3")]
            pub cpu_utilization_target: i32,
        }
        impl ::prost::Name for Scaling {
            const NAME: &'static str = "Scaling";
            const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "google.cloud.aiplatform.v1.Featurestore.OnlineServingConfig.Scaling"
                    .into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.cloud.aiplatform.v1.Featurestore.OnlineServingConfig.Scaling"
                    .into()
            }
        }
    }
    impl ::prost::Name for OnlineServingConfig {
        const NAME: &'static str = "OnlineServingConfig";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.Featurestore.OnlineServingConfig".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.Featurestore.OnlineServingConfig"
                .into()
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Stable = 1,
        Updating = 2,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Stable => "STABLE",
                Self::Updating => "UPDATING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "STABLE" => Some(Self::Stable),
                "UPDATING" => Some(Self::Updating),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for Featurestore {
    const NAME: &'static str = "Featurestore";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.Featurestore".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.Featurestore".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateFeaturestoreRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub featurestore: ::core::option::Option<Featurestore>,
    #[prost(string, tag = "3")]
    pub featurestore_id: ::prost::alloc::string::String,
}
impl ::prost::Name for CreateFeaturestoreRequest {
    const NAME: &'static str = "CreateFeaturestoreRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateFeaturestoreRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateFeaturestoreRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFeaturestoreRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for GetFeaturestoreRequest {
    const NAME: &'static str = "GetFeaturestoreRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetFeaturestoreRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetFeaturestoreRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFeaturestoresRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for ListFeaturestoresRequest {
    const NAME: &'static str = "ListFeaturestoresRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListFeaturestoresRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListFeaturestoresRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFeaturestoresResponse {
    #[prost(message, repeated, tag = "1")]
    pub featurestores: ::prost::alloc::vec::Vec<Featurestore>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListFeaturestoresResponse {
    const NAME: &'static str = "ListFeaturestoresResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListFeaturestoresResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListFeaturestoresResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFeaturestoreRequest {
    #[prost(message, optional, tag = "1")]
    pub featurestore: ::core::option::Option<Featurestore>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for UpdateFeaturestoreRequest {
    const NAME: &'static str = "UpdateFeaturestoreRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdateFeaturestoreRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateFeaturestoreRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteFeaturestoreRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub force: bool,
}
impl ::prost::Name for DeleteFeaturestoreRequest {
    const NAME: &'static str = "DeleteFeaturestoreRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeleteFeaturestoreRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteFeaturestoreRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportFeatureValuesRequest {
    #[prost(string, tag = "1")]
    pub entity_type: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub entity_id_field: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "8")]
    pub feature_specs: ::prost::alloc::vec::Vec<
        import_feature_values_request::FeatureSpec,
    >,
    #[prost(bool, tag = "9")]
    pub disable_online_serving: bool,
    #[prost(int32, tag = "11")]
    pub worker_count: i32,
    #[prost(bool, tag = "12")]
    pub disable_ingestion_analysis: bool,
    #[prost(oneof = "import_feature_values_request::Source", tags = "2, 3, 4")]
    pub source: ::core::option::Option<import_feature_values_request::Source>,
    #[prost(oneof = "import_feature_values_request::FeatureTimeSource", tags = "6, 7")]
    pub feature_time_source: ::core::option::Option<
        import_feature_values_request::FeatureTimeSource,
    >,
}
/// Nested message and enum types in `ImportFeatureValuesRequest`.
pub mod import_feature_values_request {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FeatureSpec {
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub source_field: ::prost::alloc::string::String,
    }
    impl ::prost::Name for FeatureSpec {
        const NAME: &'static str = "FeatureSpec";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.ImportFeatureValuesRequest.FeatureSpec".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.ImportFeatureValuesRequest.FeatureSpec"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        #[prost(message, tag = "2")]
        AvroSource(super::AvroSource),
        #[prost(message, tag = "3")]
        BigquerySource(super::BigQuerySource),
        #[prost(message, tag = "4")]
        CsvSource(super::CsvSource),
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum FeatureTimeSource {
        #[prost(string, tag = "6")]
        FeatureTimeField(::prost::alloc::string::String),
        #[prost(message, tag = "7")]
        FeatureTime(::prost_types::Timestamp),
    }
}
impl ::prost::Name for ImportFeatureValuesRequest {
    const NAME: &'static str = "ImportFeatureValuesRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ImportFeatureValuesRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ImportFeatureValuesRequest"
            .into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ImportFeatureValuesResponse {
    #[prost(int64, tag = "1")]
    pub imported_entity_count: i64,
    #[prost(int64, tag = "2")]
    pub imported_feature_value_count: i64,
    #[prost(int64, tag = "6")]
    pub invalid_row_count: i64,
    #[prost(int64, tag = "4")]
    pub timestamp_outside_retention_rows_count: i64,
}
impl ::prost::Name for ImportFeatureValuesResponse {
    const NAME: &'static str = "ImportFeatureValuesResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ImportFeatureValuesResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ImportFeatureValuesResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchReadFeatureValuesRequest {
    #[prost(string, tag = "1")]
    pub featurestore: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub destination: ::core::option::Option<FeatureValueDestination>,
    #[prost(message, repeated, tag = "8")]
    pub pass_through_fields: ::prost::alloc::vec::Vec<
        batch_read_feature_values_request::PassThroughField,
    >,
    #[prost(message, repeated, tag = "7")]
    pub entity_type_specs: ::prost::alloc::vec::Vec<
        batch_read_feature_values_request::EntityTypeSpec,
    >,
    #[prost(message, optional, tag = "11")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(oneof = "batch_read_feature_values_request::ReadOption", tags = "3, 5")]
    pub read_option: ::core::option::Option<
        batch_read_feature_values_request::ReadOption,
    >,
}
/// Nested message and enum types in `BatchReadFeatureValuesRequest`.
pub mod batch_read_feature_values_request {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PassThroughField {
        #[prost(string, tag = "1")]
        pub field_name: ::prost::alloc::string::String,
    }
    impl ::prost::Name for PassThroughField {
        const NAME: &'static str = "PassThroughField";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.BatchReadFeatureValuesRequest.PassThroughField"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.BatchReadFeatureValuesRequest.PassThroughField"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EntityTypeSpec {
        #[prost(string, tag = "1")]
        pub entity_type_id: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub feature_selector: ::core::option::Option<super::FeatureSelector>,
        #[prost(message, repeated, tag = "3")]
        pub settings: ::prost::alloc::vec::Vec<super::DestinationFeatureSetting>,
    }
    impl ::prost::Name for EntityTypeSpec {
        const NAME: &'static str = "EntityTypeSpec";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.BatchReadFeatureValuesRequest.EntityTypeSpec"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.BatchReadFeatureValuesRequest.EntityTypeSpec"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ReadOption {
        #[prost(message, tag = "3")]
        CsvReadInstances(super::CsvSource),
        #[prost(message, tag = "5")]
        BigqueryReadInstances(super::BigQuerySource),
    }
}
impl ::prost::Name for BatchReadFeatureValuesRequest {
    const NAME: &'static str = "BatchReadFeatureValuesRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.BatchReadFeatureValuesRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchReadFeatureValuesRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportFeatureValuesRequest {
    #[prost(string, tag = "1")]
    pub entity_type: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub destination: ::core::option::Option<FeatureValueDestination>,
    #[prost(message, optional, tag = "5")]
    pub feature_selector: ::core::option::Option<FeatureSelector>,
    #[prost(message, repeated, tag = "6")]
    pub settings: ::prost::alloc::vec::Vec<DestinationFeatureSetting>,
    #[prost(oneof = "export_feature_values_request::Mode", tags = "3, 7")]
    pub mode: ::core::option::Option<export_feature_values_request::Mode>,
}
/// Nested message and enum types in `ExportFeatureValuesRequest`.
pub mod export_feature_values_request {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SnapshotExport {
        #[prost(message, optional, tag = "1")]
        pub snapshot_time: ::core::option::Option<::prost_types::Timestamp>,
        #[prost(message, optional, tag = "2")]
        pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    }
    impl ::prost::Name for SnapshotExport {
        const NAME: &'static str = "SnapshotExport";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.ExportFeatureValuesRequest.SnapshotExport".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.ExportFeatureValuesRequest.SnapshotExport"
                .into()
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct FullExport {
        #[prost(message, optional, tag = "2")]
        pub start_time: ::core::option::Option<::prost_types::Timestamp>,
        #[prost(message, optional, tag = "1")]
        pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    }
    impl ::prost::Name for FullExport {
        const NAME: &'static str = "FullExport";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.ExportFeatureValuesRequest.FullExport".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.ExportFeatureValuesRequest.FullExport"
                .into()
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Mode {
        #[prost(message, tag = "3")]
        SnapshotExport(SnapshotExport),
        #[prost(message, tag = "7")]
        FullExport(FullExport),
    }
}
impl ::prost::Name for ExportFeatureValuesRequest {
    const NAME: &'static str = "ExportFeatureValuesRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ExportFeatureValuesRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExportFeatureValuesRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DestinationFeatureSetting {
    #[prost(string, tag = "1")]
    pub feature_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub destination_field: ::prost::alloc::string::String,
}
impl ::prost::Name for DestinationFeatureSetting {
    const NAME: &'static str = "DestinationFeatureSetting";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DestinationFeatureSetting".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DestinationFeatureSetting".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeatureValueDestination {
    #[prost(oneof = "feature_value_destination::Destination", tags = "1, 2, 3")]
    pub destination: ::core::option::Option<feature_value_destination::Destination>,
}
/// Nested message and enum types in `FeatureValueDestination`.
pub mod feature_value_destination {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Destination {
        #[prost(message, tag = "1")]
        BigqueryDestination(super::BigQueryDestination),
        #[prost(message, tag = "2")]
        TfrecordDestination(super::TfRecordDestination),
        #[prost(message, tag = "3")]
        CsvDestination(super::CsvDestination),
    }
}
impl ::prost::Name for FeatureValueDestination {
    const NAME: &'static str = "FeatureValueDestination";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.FeatureValueDestination".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.FeatureValueDestination".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExportFeatureValuesResponse {}
impl ::prost::Name for ExportFeatureValuesResponse {
    const NAME: &'static str = "ExportFeatureValuesResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ExportFeatureValuesResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExportFeatureValuesResponse"
            .into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BatchReadFeatureValuesResponse {}
impl ::prost::Name for BatchReadFeatureValuesResponse {
    const NAME: &'static str = "BatchReadFeatureValuesResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.BatchReadFeatureValuesResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchReadFeatureValuesResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateEntityTypeRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub entity_type: ::core::option::Option<EntityType>,
    #[prost(string, tag = "3")]
    pub entity_type_id: ::prost::alloc::string::String,
}
impl ::prost::Name for CreateEntityTypeRequest {
    const NAME: &'static str = "CreateEntityTypeRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateEntityTypeRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateEntityTypeRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEntityTypeRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for GetEntityTypeRequest {
    const NAME: &'static str = "GetEntityTypeRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetEntityTypeRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetEntityTypeRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEntityTypesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for ListEntityTypesRequest {
    const NAME: &'static str = "ListEntityTypesRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListEntityTypesRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListEntityTypesRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEntityTypesResponse {
    #[prost(message, repeated, tag = "1")]
    pub entity_types: ::prost::alloc::vec::Vec<EntityType>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListEntityTypesResponse {
    const NAME: &'static str = "ListEntityTypesResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListEntityTypesResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListEntityTypesResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateEntityTypeRequest {
    #[prost(message, optional, tag = "1")]
    pub entity_type: ::core::option::Option<EntityType>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for UpdateEntityTypeRequest {
    const NAME: &'static str = "UpdateEntityTypeRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdateEntityTypeRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateEntityTypeRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteEntityTypeRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub force: bool,
}
impl ::prost::Name for DeleteEntityTypeRequest {
    const NAME: &'static str = "DeleteEntityTypeRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeleteEntityTypeRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteEntityTypeRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateFeatureRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub feature: ::core::option::Option<Feature>,
    #[prost(string, tag = "3")]
    pub feature_id: ::prost::alloc::string::String,
}
impl ::prost::Name for CreateFeatureRequest {
    const NAME: &'static str = "CreateFeatureRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateFeatureRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateFeatureRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateFeaturesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub requests: ::prost::alloc::vec::Vec<CreateFeatureRequest>,
}
impl ::prost::Name for BatchCreateFeaturesRequest {
    const NAME: &'static str = "BatchCreateFeaturesRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.BatchCreateFeaturesRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchCreateFeaturesRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateFeaturesResponse {
    #[prost(message, repeated, tag = "1")]
    pub features: ::prost::alloc::vec::Vec<Feature>,
}
impl ::prost::Name for BatchCreateFeaturesResponse {
    const NAME: &'static str = "BatchCreateFeaturesResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.BatchCreateFeaturesResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchCreateFeaturesResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFeatureRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for GetFeatureRequest {
    const NAME: &'static str = "GetFeatureRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetFeatureRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetFeatureRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFeaturesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(int32, tag = "7")]
    pub latest_stats_count: i32,
}
impl ::prost::Name for ListFeaturesRequest {
    const NAME: &'static str = "ListFeaturesRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListFeaturesRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListFeaturesRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFeaturesResponse {
    #[prost(message, repeated, tag = "1")]
    pub features: ::prost::alloc::vec::Vec<Feature>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListFeaturesResponse {
    const NAME: &'static str = "ListFeaturesResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListFeaturesResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListFeaturesResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchFeaturesRequest {
    #[prost(string, tag = "1")]
    pub location: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub query: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub page_size: i32,
    #[prost(string, tag = "5")]
    pub page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for SearchFeaturesRequest {
    const NAME: &'static str = "SearchFeaturesRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SearchFeaturesRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SearchFeaturesRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchFeaturesResponse {
    #[prost(message, repeated, tag = "1")]
    pub features: ::prost::alloc::vec::Vec<Feature>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for SearchFeaturesResponse {
    const NAME: &'static str = "SearchFeaturesResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SearchFeaturesResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SearchFeaturesResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFeatureRequest {
    #[prost(message, optional, tag = "1")]
    pub feature: ::core::option::Option<Feature>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for UpdateFeatureRequest {
    const NAME: &'static str = "UpdateFeatureRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdateFeatureRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateFeatureRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteFeatureRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for DeleteFeatureRequest {
    const NAME: &'static str = "DeleteFeatureRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeleteFeatureRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteFeatureRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateFeaturestoreOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for CreateFeaturestoreOperationMetadata {
    const NAME: &'static str = "CreateFeaturestoreOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateFeaturestoreOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateFeaturestoreOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFeaturestoreOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for UpdateFeaturestoreOperationMetadata {
    const NAME: &'static str = "UpdateFeaturestoreOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdateFeaturestoreOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateFeaturestoreOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportFeatureValuesOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
    #[prost(int64, tag = "2")]
    pub imported_entity_count: i64,
    #[prost(int64, tag = "3")]
    pub imported_feature_value_count: i64,
    #[prost(string, repeated, tag = "4")]
    pub source_uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int64, tag = "6")]
    pub invalid_row_count: i64,
    #[prost(int64, tag = "7")]
    pub timestamp_outside_retention_rows_count: i64,
    #[prost(int64, repeated, tag = "8")]
    pub blocking_operation_ids: ::prost::alloc::vec::Vec<i64>,
}
impl ::prost::Name for ImportFeatureValuesOperationMetadata {
    const NAME: &'static str = "ImportFeatureValuesOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ImportFeatureValuesOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ImportFeatureValuesOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportFeatureValuesOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for ExportFeatureValuesOperationMetadata {
    const NAME: &'static str = "ExportFeatureValuesOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ExportFeatureValuesOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExportFeatureValuesOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchReadFeatureValuesOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for BatchReadFeatureValuesOperationMetadata {
    const NAME: &'static str = "BatchReadFeatureValuesOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.BatchReadFeatureValuesOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchReadFeatureValuesOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteFeatureValuesOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for DeleteFeatureValuesOperationMetadata {
    const NAME: &'static str = "DeleteFeatureValuesOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeleteFeatureValuesOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteFeatureValuesOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateEntityTypeOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for CreateEntityTypeOperationMetadata {
    const NAME: &'static str = "CreateEntityTypeOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateEntityTypeOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateEntityTypeOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateFeatureOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for CreateFeatureOperationMetadata {
    const NAME: &'static str = "CreateFeatureOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateFeatureOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateFeatureOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateFeaturesOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for BatchCreateFeaturesOperationMetadata {
    const NAME: &'static str = "BatchCreateFeaturesOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.BatchCreateFeaturesOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchCreateFeaturesOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteFeatureValuesRequest {
    #[prost(string, tag = "1")]
    pub entity_type: ::prost::alloc::string::String,
    #[prost(oneof = "delete_feature_values_request::DeleteOption", tags = "2, 3")]
    pub delete_option: ::core::option::Option<
        delete_feature_values_request::DeleteOption,
    >,
}
/// Nested message and enum types in `DeleteFeatureValuesRequest`.
pub mod delete_feature_values_request {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SelectEntity {
        #[prost(message, optional, tag = "1")]
        pub entity_id_selector: ::core::option::Option<super::EntityIdSelector>,
    }
    impl ::prost::Name for SelectEntity {
        const NAME: &'static str = "SelectEntity";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.DeleteFeatureValuesRequest.SelectEntity".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.DeleteFeatureValuesRequest.SelectEntity"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SelectTimeRangeAndFeature {
        #[prost(message, optional, tag = "1")]
        pub time_range: ::core::option::Option<
            super::super::super::super::r#type::Interval,
        >,
        #[prost(message, optional, tag = "2")]
        pub feature_selector: ::core::option::Option<super::FeatureSelector>,
        #[prost(bool, tag = "3")]
        pub skip_online_storage_delete: bool,
    }
    impl ::prost::Name for SelectTimeRangeAndFeature {
        const NAME: &'static str = "SelectTimeRangeAndFeature";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.DeleteFeatureValuesRequest.SelectTimeRangeAndFeature"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.DeleteFeatureValuesRequest.SelectTimeRangeAndFeature"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum DeleteOption {
        #[prost(message, tag = "2")]
        SelectEntity(SelectEntity),
        #[prost(message, tag = "3")]
        SelectTimeRangeAndFeature(SelectTimeRangeAndFeature),
    }
}
impl ::prost::Name for DeleteFeatureValuesRequest {
    const NAME: &'static str = "DeleteFeatureValuesRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeleteFeatureValuesRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteFeatureValuesRequest"
            .into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteFeatureValuesResponse {
    #[prost(oneof = "delete_feature_values_response::Response", tags = "1, 2")]
    pub response: ::core::option::Option<delete_feature_values_response::Response>,
}
/// Nested message and enum types in `DeleteFeatureValuesResponse`.
pub mod delete_feature_values_response {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SelectEntity {
        #[prost(int64, tag = "1")]
        pub offline_storage_deleted_entity_row_count: i64,
        #[prost(int64, tag = "2")]
        pub online_storage_deleted_entity_count: i64,
    }
    impl ::prost::Name for SelectEntity {
        const NAME: &'static str = "SelectEntity";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.DeleteFeatureValuesResponse.SelectEntity".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.DeleteFeatureValuesResponse.SelectEntity"
                .into()
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SelectTimeRangeAndFeature {
        #[prost(int64, tag = "1")]
        pub impacted_feature_count: i64,
        #[prost(int64, tag = "2")]
        pub offline_storage_modified_entity_row_count: i64,
        #[prost(int64, tag = "3")]
        pub online_storage_modified_entity_count: i64,
    }
    impl ::prost::Name for SelectTimeRangeAndFeature {
        const NAME: &'static str = "SelectTimeRangeAndFeature";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.DeleteFeatureValuesResponse.SelectTimeRangeAndFeature"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.DeleteFeatureValuesResponse.SelectTimeRangeAndFeature"
                .into()
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Response {
        #[prost(message, tag = "1")]
        SelectEntity(SelectEntity),
        #[prost(message, tag = "2")]
        SelectTimeRangeAndFeature(SelectTimeRangeAndFeature),
    }
}
impl ::prost::Name for DeleteFeatureValuesResponse {
    const NAME: &'static str = "DeleteFeatureValuesResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeleteFeatureValuesResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteFeatureValuesResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityIdSelector {
    #[prost(string, tag = "5")]
    pub entity_id_field: ::prost::alloc::string::String,
    #[prost(oneof = "entity_id_selector::EntityIdsSource", tags = "3")]
    pub entity_ids_source: ::core::option::Option<entity_id_selector::EntityIdsSource>,
}
/// Nested message and enum types in `EntityIdSelector`.
pub mod entity_id_selector {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum EntityIdsSource {
        #[prost(message, tag = "3")]
        CsvSource(super::CsvSource),
    }
}
impl ::prost::Name for EntityIdSelector {
    const NAME: &'static str = "EntityIdSelector";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.EntityIdSelector".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.EntityIdSelector".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateFeatureGroupRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub feature_group: ::core::option::Option<FeatureGroup>,
    #[prost(string, tag = "3")]
    pub feature_group_id: ::prost::alloc::string::String,
}
impl ::prost::Name for CreateFeatureGroupRequest {
    const NAME: &'static str = "CreateFeatureGroupRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateFeatureGroupRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateFeatureGroupRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFeatureGroupRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for GetFeatureGroupRequest {
    const NAME: &'static str = "GetFeatureGroupRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetFeatureGroupRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetFeatureGroupRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFeatureGroupsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
impl ::prost::Name for ListFeatureGroupsRequest {
    const NAME: &'static str = "ListFeatureGroupsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListFeatureGroupsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListFeatureGroupsRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFeatureGroupsResponse {
    #[prost(message, repeated, tag = "1")]
    pub feature_groups: ::prost::alloc::vec::Vec<FeatureGroup>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListFeatureGroupsResponse {
    const NAME: &'static str = "ListFeatureGroupsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListFeatureGroupsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListFeatureGroupsResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFeatureGroupRequest {
    #[prost(message, optional, tag = "1")]
    pub feature_group: ::core::option::Option<FeatureGroup>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for UpdateFeatureGroupRequest {
    const NAME: &'static str = "UpdateFeatureGroupRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdateFeatureGroupRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateFeatureGroupRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteFeatureGroupRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub force: bool,
}
impl ::prost::Name for DeleteFeatureGroupRequest {
    const NAME: &'static str = "DeleteFeatureGroupRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeleteFeatureGroupRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteFeatureGroupRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateFeatureGroupOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for CreateFeatureGroupOperationMetadata {
    const NAME: &'static str = "CreateFeatureGroupOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateFeatureGroupOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateFeatureGroupOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFeatureGroupOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for UpdateFeatureGroupOperationMetadata {
    const NAME: &'static str = "UpdateFeatureGroupOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdateFeatureGroupOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateFeatureGroupOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateRegistryFeatureOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for CreateRegistryFeatureOperationMetadata {
    const NAME: &'static str = "CreateRegistryFeatureOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateRegistryFeatureOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateRegistryFeatureOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFeatureOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for UpdateFeatureOperationMetadata {
    const NAME: &'static str = "UpdateFeatureOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdateFeatureOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateFeatureOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCachedContentRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub cached_content: ::core::option::Option<CachedContent>,
}
impl ::prost::Name for CreateCachedContentRequest {
    const NAME: &'static str = "CreateCachedContentRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateCachedContentRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateCachedContentRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCachedContentRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for GetCachedContentRequest {
    const NAME: &'static str = "GetCachedContentRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetCachedContentRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetCachedContentRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateCachedContentRequest {
    #[prost(message, optional, tag = "1")]
    pub cached_content: ::core::option::Option<CachedContent>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for UpdateCachedContentRequest {
    const NAME: &'static str = "UpdateCachedContentRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdateCachedContentRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateCachedContentRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteCachedContentRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for DeleteCachedContentRequest {
    const NAME: &'static str = "DeleteCachedContentRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeleteCachedContentRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteCachedContentRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCachedContentsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListCachedContentsRequest {
    const NAME: &'static str = "ListCachedContentsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListCachedContentsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListCachedContentsRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCachedContentsResponse {
    #[prost(message, repeated, tag = "1")]
    pub cached_contents: ::prost::alloc::vec::Vec<CachedContent>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListCachedContentsResponse {
    const NAME: &'static str = "ListCachedContentsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListCachedContentsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListCachedContentsResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TuningJob {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub tuned_model_display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(enumeration = "JobState", tag = "6")]
    pub state: i32,
    #[prost(message, optional, tag = "7")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "10")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "11")]
    pub error: ::core::option::Option<super::super::super::rpc::Status>,
    #[prost(map = "string, string", tag = "12")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "13")]
    pub experiment: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "14")]
    pub tuned_model: ::core::option::Option<TunedModel>,
    #[prost(message, optional, tag = "15")]
    pub tuning_data_stats: ::core::option::Option<TuningDataStats>,
    #[prost(message, optional, tag = "16")]
    pub encryption_spec: ::core::option::Option<EncryptionSpec>,
    #[prost(string, tag = "22")]
    pub service_account: ::prost::alloc::string::String,
    #[prost(oneof = "tuning_job::SourceModel", tags = "4")]
    pub source_model: ::core::option::Option<tuning_job::SourceModel>,
    #[prost(oneof = "tuning_job::TuningSpec", tags = "5")]
    pub tuning_spec: ::core::option::Option<tuning_job::TuningSpec>,
}
/// Nested message and enum types in `TuningJob`.
pub mod tuning_job {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SourceModel {
        #[prost(string, tag = "4")]
        BaseModel(::prost::alloc::string::String),
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum TuningSpec {
        #[prost(message, tag = "5")]
        SupervisedTuningSpec(super::SupervisedTuningSpec),
    }
}
impl ::prost::Name for TuningJob {
    const NAME: &'static str = "TuningJob";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.TuningJob".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.TuningJob".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TunedModel {
    #[prost(string, tag = "1")]
    pub model: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub endpoint: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub checkpoints: ::prost::alloc::vec::Vec<TunedModelCheckpoint>,
}
impl ::prost::Name for TunedModel {
    const NAME: &'static str = "TunedModel";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.TunedModel".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.TunedModel".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SupervisedTuningDatasetDistribution {
    #[prost(int64, tag = "1")]
    pub sum: i64,
    #[prost(int64, tag = "9")]
    pub billable_sum: i64,
    #[prost(double, tag = "2")]
    pub min: f64,
    #[prost(double, tag = "3")]
    pub max: f64,
    #[prost(double, tag = "4")]
    pub mean: f64,
    #[prost(double, tag = "5")]
    pub median: f64,
    #[prost(double, tag = "6")]
    pub p5: f64,
    #[prost(double, tag = "7")]
    pub p95: f64,
    #[prost(message, repeated, tag = "8")]
    pub buckets: ::prost::alloc::vec::Vec<
        supervised_tuning_dataset_distribution::DatasetBucket,
    >,
}
/// Nested message and enum types in `SupervisedTuningDatasetDistribution`.
pub mod supervised_tuning_dataset_distribution {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DatasetBucket {
        #[prost(double, tag = "1")]
        pub count: f64,
        #[prost(double, tag = "2")]
        pub left: f64,
        #[prost(double, tag = "3")]
        pub right: f64,
    }
    impl ::prost::Name for DatasetBucket {
        const NAME: &'static str = "DatasetBucket";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.SupervisedTuningDatasetDistribution.DatasetBucket"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.SupervisedTuningDatasetDistribution.DatasetBucket"
                .into()
        }
    }
}
impl ::prost::Name for SupervisedTuningDatasetDistribution {
    const NAME: &'static str = "SupervisedTuningDatasetDistribution";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SupervisedTuningDatasetDistribution".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SupervisedTuningDatasetDistribution"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SupervisedTuningDataStats {
    #[prost(int64, tag = "1")]
    pub tuning_dataset_example_count: i64,
    #[prost(int64, tag = "2")]
    pub total_tuning_character_count: i64,
    #[deprecated]
    #[prost(int64, tag = "3")]
    pub total_billable_character_count: i64,
    #[prost(int64, tag = "9")]
    pub total_billable_token_count: i64,
    #[prost(int64, tag = "4")]
    pub tuning_step_count: i64,
    #[prost(message, optional, tag = "5")]
    pub user_input_token_distribution: ::core::option::Option<
        SupervisedTuningDatasetDistribution,
    >,
    #[prost(message, optional, tag = "6")]
    pub user_output_token_distribution: ::core::option::Option<
        SupervisedTuningDatasetDistribution,
    >,
    #[prost(message, optional, tag = "7")]
    pub user_message_per_example_distribution: ::core::option::Option<
        SupervisedTuningDatasetDistribution,
    >,
    #[prost(message, repeated, tag = "8")]
    pub user_dataset_examples: ::prost::alloc::vec::Vec<Content>,
    #[prost(int64, tag = "10")]
    pub total_truncated_example_count: i64,
    #[prost(int64, repeated, packed = "false", tag = "11")]
    pub truncated_example_indices: ::prost::alloc::vec::Vec<i64>,
    #[prost(string, repeated, tag = "12")]
    pub dropped_example_reasons: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
}
impl ::prost::Name for SupervisedTuningDataStats {
    const NAME: &'static str = "SupervisedTuningDataStats";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SupervisedTuningDataStats".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SupervisedTuningDataStats".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TuningDataStats {
    #[prost(oneof = "tuning_data_stats::TuningDataStats", tags = "1")]
    pub tuning_data_stats: ::core::option::Option<tuning_data_stats::TuningDataStats>,
}
/// Nested message and enum types in `TuningDataStats`.
pub mod tuning_data_stats {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum TuningDataStats {
        #[prost(message, tag = "1")]
        SupervisedTuningDataStats(super::SupervisedTuningDataStats),
    }
}
impl ::prost::Name for TuningDataStats {
    const NAME: &'static str = "TuningDataStats";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.TuningDataStats".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.TuningDataStats".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SupervisedHyperParameters {
    #[prost(int64, tag = "1")]
    pub epoch_count: i64,
    #[prost(double, tag = "2")]
    pub learning_rate_multiplier: f64,
    #[prost(enumeration = "supervised_hyper_parameters::AdapterSize", tag = "3")]
    pub adapter_size: i32,
}
/// Nested message and enum types in `SupervisedHyperParameters`.
pub mod supervised_hyper_parameters {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdapterSize {
        Unspecified = 0,
        One = 1,
        Two = 6,
        Four = 2,
        Eight = 3,
        Sixteen = 4,
        ThirtyTwo = 5,
    }
    impl AdapterSize {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "ADAPTER_SIZE_UNSPECIFIED",
                Self::One => "ADAPTER_SIZE_ONE",
                Self::Two => "ADAPTER_SIZE_TWO",
                Self::Four => "ADAPTER_SIZE_FOUR",
                Self::Eight => "ADAPTER_SIZE_EIGHT",
                Self::Sixteen => "ADAPTER_SIZE_SIXTEEN",
                Self::ThirtyTwo => "ADAPTER_SIZE_THIRTY_TWO",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ADAPTER_SIZE_UNSPECIFIED" => Some(Self::Unspecified),
                "ADAPTER_SIZE_ONE" => Some(Self::One),
                "ADAPTER_SIZE_TWO" => Some(Self::Two),
                "ADAPTER_SIZE_FOUR" => Some(Self::Four),
                "ADAPTER_SIZE_EIGHT" => Some(Self::Eight),
                "ADAPTER_SIZE_SIXTEEN" => Some(Self::Sixteen),
                "ADAPTER_SIZE_THIRTY_TWO" => Some(Self::ThirtyTwo),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for SupervisedHyperParameters {
    const NAME: &'static str = "SupervisedHyperParameters";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SupervisedHyperParameters".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SupervisedHyperParameters".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SupervisedTuningSpec {
    #[prost(string, tag = "1")]
    pub training_dataset_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub validation_dataset_uri: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub hyper_parameters: ::core::option::Option<SupervisedHyperParameters>,
    #[prost(bool, tag = "6")]
    pub export_last_checkpoint_only: bool,
}
impl ::prost::Name for SupervisedTuningSpec {
    const NAME: &'static str = "SupervisedTuningSpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SupervisedTuningSpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SupervisedTuningSpec".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TunedModelRef {
    #[prost(oneof = "tuned_model_ref::TunedModelRef", tags = "1, 2, 3")]
    pub tuned_model_ref: ::core::option::Option<tuned_model_ref::TunedModelRef>,
}
/// Nested message and enum types in `TunedModelRef`.
pub mod tuned_model_ref {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum TunedModelRef {
        #[prost(string, tag = "1")]
        TunedModel(::prost::alloc::string::String),
        #[prost(string, tag = "2")]
        TuningJob(::prost::alloc::string::String),
        #[prost(string, tag = "3")]
        PipelineJob(::prost::alloc::string::String),
    }
}
impl ::prost::Name for TunedModelRef {
    const NAME: &'static str = "TunedModelRef";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.TunedModelRef".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.TunedModelRef".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TunedModelCheckpoint {
    #[prost(string, tag = "1")]
    pub checkpoint_id: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub epoch: i64,
    #[prost(int64, tag = "3")]
    pub step: i64,
    #[prost(string, tag = "4")]
    pub endpoint: ::prost::alloc::string::String,
}
impl ::prost::Name for TunedModelCheckpoint {
    const NAME: &'static str = "TunedModelCheckpoint";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.TunedModelCheckpoint".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.TunedModelCheckpoint".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTuningJobRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub tuning_job: ::core::option::Option<TuningJob>,
}
impl ::prost::Name for CreateTuningJobRequest {
    const NAME: &'static str = "CreateTuningJobRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateTuningJobRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateTuningJobRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTuningJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for GetTuningJobRequest {
    const NAME: &'static str = "GetTuningJobRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetTuningJobRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetTuningJobRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTuningJobsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListTuningJobsRequest {
    const NAME: &'static str = "ListTuningJobsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListTuningJobsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListTuningJobsRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTuningJobsResponse {
    #[prost(message, repeated, tag = "1")]
    pub tuning_jobs: ::prost::alloc::vec::Vec<TuningJob>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListTuningJobsResponse {
    const NAME: &'static str = "ListTuningJobsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListTuningJobsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListTuningJobsResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelTuningJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for CancelTuningJobRequest {
    const NAME: &'static str = "CancelTuningJobRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CancelTuningJobRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CancelTuningJobRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RebaseTunedModelRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub tuned_model_ref: ::core::option::Option<TunedModelRef>,
    #[prost(message, optional, tag = "3")]
    pub tuning_job: ::core::option::Option<TuningJob>,
    #[prost(message, optional, tag = "4")]
    pub artifact_destination: ::core::option::Option<GcsDestination>,
    #[prost(bool, tag = "5")]
    pub deploy_to_same_endpoint: bool,
}
impl ::prost::Name for RebaseTunedModelRequest {
    const NAME: &'static str = "RebaseTunedModelRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.RebaseTunedModelRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.RebaseTunedModelRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RebaseTunedModelOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for RebaseTunedModelOperationMetadata {
    const NAME: &'static str = "RebaseTunedModelOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.RebaseTunedModelOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.RebaseTunedModelOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Study {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub study_spec: ::core::option::Option<StudySpec>,
    #[prost(enumeration = "study::State", tag = "4")]
    pub state: i32,
    #[prost(message, optional, tag = "5")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "6")]
    pub inactive_reason: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Study`.
pub mod study {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Active = 1,
        Inactive = 2,
        Completed = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::Inactive => "INACTIVE",
                Self::Completed => "COMPLETED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "INACTIVE" => Some(Self::Inactive),
                "COMPLETED" => Some(Self::Completed),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for Study {
    const NAME: &'static str = "Study";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.Study".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.Study".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Trial {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
    #[prost(enumeration = "trial::State", tag = "3")]
    pub state: i32,
    #[prost(message, repeated, tag = "4")]
    pub parameters: ::prost::alloc::vec::Vec<trial::Parameter>,
    #[prost(message, optional, tag = "5")]
    pub final_measurement: ::core::option::Option<Measurement>,
    #[prost(message, repeated, tag = "6")]
    pub measurements: ::prost::alloc::vec::Vec<Measurement>,
    #[prost(message, optional, tag = "7")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "9")]
    pub client_id: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub infeasible_reason: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub custom_job: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "12")]
    pub web_access_uris: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Nested message and enum types in `Trial`.
pub mod trial {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Parameter {
        #[prost(string, tag = "1")]
        pub parameter_id: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub value: ::core::option::Option<::prost_types::Value>,
    }
    impl ::prost::Name for Parameter {
        const NAME: &'static str = "Parameter";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.Trial.Parameter".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.Trial.Parameter".into()
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Requested = 1,
        Active = 2,
        Stopping = 3,
        Succeeded = 4,
        Infeasible = 5,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Requested => "REQUESTED",
                Self::Active => "ACTIVE",
                Self::Stopping => "STOPPING",
                Self::Succeeded => "SUCCEEDED",
                Self::Infeasible => "INFEASIBLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "REQUESTED" => Some(Self::Requested),
                "ACTIVE" => Some(Self::Active),
                "STOPPING" => Some(Self::Stopping),
                "SUCCEEDED" => Some(Self::Succeeded),
                "INFEASIBLE" => Some(Self::Infeasible),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for Trial {
    const NAME: &'static str = "Trial";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.Trial".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.Trial".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TrialContext {
    #[prost(string, tag = "1")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub parameters: ::prost::alloc::vec::Vec<trial::Parameter>,
}
impl ::prost::Name for TrialContext {
    const NAME: &'static str = "TrialContext";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.TrialContext".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.TrialContext".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StudyTimeConstraint {
    #[prost(oneof = "study_time_constraint::Constraint", tags = "1, 2")]
    pub constraint: ::core::option::Option<study_time_constraint::Constraint>,
}
/// Nested message and enum types in `StudyTimeConstraint`.
pub mod study_time_constraint {
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Constraint {
        #[prost(message, tag = "1")]
        MaxDuration(::prost_types::Duration),
        #[prost(message, tag = "2")]
        EndTime(::prost_types::Timestamp),
    }
}
impl ::prost::Name for StudyTimeConstraint {
    const NAME: &'static str = "StudyTimeConstraint";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.StudyTimeConstraint".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.StudyTimeConstraint".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StudySpec {
    #[prost(message, repeated, tag = "1")]
    pub metrics: ::prost::alloc::vec::Vec<study_spec::MetricSpec>,
    #[prost(message, repeated, tag = "2")]
    pub parameters: ::prost::alloc::vec::Vec<study_spec::ParameterSpec>,
    #[prost(enumeration = "study_spec::Algorithm", tag = "3")]
    pub algorithm: i32,
    #[prost(enumeration = "study_spec::ObservationNoise", tag = "6")]
    pub observation_noise: i32,
    #[prost(enumeration = "study_spec::MeasurementSelectionType", tag = "7")]
    pub measurement_selection_type: i32,
    #[prost(message, optional, tag = "11")]
    pub study_stopping_config: ::core::option::Option<study_spec::StudyStoppingConfig>,
    #[prost(oneof = "study_spec::AutomatedStoppingSpec", tags = "4, 5, 9")]
    pub automated_stopping_spec: ::core::option::Option<
        study_spec::AutomatedStoppingSpec,
    >,
}
/// Nested message and enum types in `StudySpec`.
pub mod study_spec {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MetricSpec {
        #[prost(string, tag = "1")]
        pub metric_id: ::prost::alloc::string::String,
        #[prost(enumeration = "metric_spec::GoalType", tag = "2")]
        pub goal: i32,
        #[prost(message, optional, tag = "3")]
        pub safety_config: ::core::option::Option<metric_spec::SafetyMetricConfig>,
    }
    /// Nested message and enum types in `MetricSpec`.
    pub mod metric_spec {
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct SafetyMetricConfig {
            #[prost(double, tag = "1")]
            pub safety_threshold: f64,
            #[prost(double, optional, tag = "2")]
            pub desired_min_safe_trials_fraction: ::core::option::Option<f64>,
        }
        impl ::prost::Name for SafetyMetricConfig {
            const NAME: &'static str = "SafetyMetricConfig";
            const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "google.cloud.aiplatform.v1.StudySpec.MetricSpec.SafetyMetricConfig"
                    .into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec.MetricSpec.SafetyMetricConfig"
                    .into()
            }
        }
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum GoalType {
            Unspecified = 0,
            Maximize = 1,
            Minimize = 2,
        }
        impl GoalType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "GOAL_TYPE_UNSPECIFIED",
                    Self::Maximize => "MAXIMIZE",
                    Self::Minimize => "MINIMIZE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "GOAL_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "MAXIMIZE" => Some(Self::Maximize),
                    "MINIMIZE" => Some(Self::Minimize),
                    _ => None,
                }
            }
        }
    }
    impl ::prost::Name for MetricSpec {
        const NAME: &'static str = "MetricSpec";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.StudySpec.MetricSpec".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec.MetricSpec".into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ParameterSpec {
        #[prost(string, tag = "1")]
        pub parameter_id: ::prost::alloc::string::String,
        #[prost(enumeration = "parameter_spec::ScaleType", tag = "6")]
        pub scale_type: i32,
        #[prost(message, repeated, tag = "10")]
        pub conditional_parameter_specs: ::prost::alloc::vec::Vec<
            parameter_spec::ConditionalParameterSpec,
        >,
        #[prost(oneof = "parameter_spec::ParameterValueSpec", tags = "2, 3, 4, 5")]
        pub parameter_value_spec: ::core::option::Option<
            parameter_spec::ParameterValueSpec,
        >,
    }
    /// Nested message and enum types in `ParameterSpec`.
    pub mod parameter_spec {
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct DoubleValueSpec {
            #[prost(double, tag = "1")]
            pub min_value: f64,
            #[prost(double, tag = "2")]
            pub max_value: f64,
            #[prost(double, optional, tag = "4")]
            pub default_value: ::core::option::Option<f64>,
        }
        impl ::prost::Name for DoubleValueSpec {
            const NAME: &'static str = "DoubleValueSpec";
            const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "google.cloud.aiplatform.v1.StudySpec.ParameterSpec.DoubleValueSpec"
                    .into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec.ParameterSpec.DoubleValueSpec"
                    .into()
            }
        }
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct IntegerValueSpec {
            #[prost(int64, tag = "1")]
            pub min_value: i64,
            #[prost(int64, tag = "2")]
            pub max_value: i64,
            #[prost(int64, optional, tag = "4")]
            pub default_value: ::core::option::Option<i64>,
        }
        impl ::prost::Name for IntegerValueSpec {
            const NAME: &'static str = "IntegerValueSpec";
            const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "google.cloud.aiplatform.v1.StudySpec.ParameterSpec.IntegerValueSpec"
                    .into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec.ParameterSpec.IntegerValueSpec"
                    .into()
            }
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct CategoricalValueSpec {
            #[prost(string, repeated, tag = "1")]
            pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            #[prost(string, optional, tag = "3")]
            pub default_value: ::core::option::Option<::prost::alloc::string::String>,
        }
        impl ::prost::Name for CategoricalValueSpec {
            const NAME: &'static str = "CategoricalValueSpec";
            const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "google.cloud.aiplatform.v1.StudySpec.ParameterSpec.CategoricalValueSpec"
                    .into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec.ParameterSpec.CategoricalValueSpec"
                    .into()
            }
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct DiscreteValueSpec {
            #[prost(double, repeated, packed = "false", tag = "1")]
            pub values: ::prost::alloc::vec::Vec<f64>,
            #[prost(double, optional, tag = "3")]
            pub default_value: ::core::option::Option<f64>,
        }
        impl ::prost::Name for DiscreteValueSpec {
            const NAME: &'static str = "DiscreteValueSpec";
            const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "google.cloud.aiplatform.v1.StudySpec.ParameterSpec.DiscreteValueSpec"
                    .into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec.ParameterSpec.DiscreteValueSpec"
                    .into()
            }
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct ConditionalParameterSpec {
            #[prost(message, optional, tag = "1")]
            pub parameter_spec: ::core::option::Option<super::ParameterSpec>,
            #[prost(
                oneof = "conditional_parameter_spec::ParentValueCondition",
                tags = "2, 3, 4"
            )]
            pub parent_value_condition: ::core::option::Option<
                conditional_parameter_spec::ParentValueCondition,
            >,
        }
        /// Nested message and enum types in `ConditionalParameterSpec`.
        pub mod conditional_parameter_spec {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct DiscreteValueCondition {
                #[prost(double, repeated, packed = "false", tag = "1")]
                pub values: ::prost::alloc::vec::Vec<f64>,
            }
            impl ::prost::Name for DiscreteValueCondition {
                const NAME: &'static str = "DiscreteValueCondition";
                const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
                fn full_name() -> ::prost::alloc::string::String {
                    "google.cloud.aiplatform.v1.StudySpec.ParameterSpec.ConditionalParameterSpec.DiscreteValueCondition"
                        .into()
                }
                fn type_url() -> ::prost::alloc::string::String {
                    "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec.ParameterSpec.ConditionalParameterSpec.DiscreteValueCondition"
                        .into()
                }
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct IntValueCondition {
                #[prost(int64, repeated, packed = "false", tag = "1")]
                pub values: ::prost::alloc::vec::Vec<i64>,
            }
            impl ::prost::Name for IntValueCondition {
                const NAME: &'static str = "IntValueCondition";
                const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
                fn full_name() -> ::prost::alloc::string::String {
                    "google.cloud.aiplatform.v1.StudySpec.ParameterSpec.ConditionalParameterSpec.IntValueCondition"
                        .into()
                }
                fn type_url() -> ::prost::alloc::string::String {
                    "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec.ParameterSpec.ConditionalParameterSpec.IntValueCondition"
                        .into()
                }
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct CategoricalValueCondition {
                #[prost(string, repeated, tag = "1")]
                pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            impl ::prost::Name for CategoricalValueCondition {
                const NAME: &'static str = "CategoricalValueCondition";
                const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
                fn full_name() -> ::prost::alloc::string::String {
                    "google.cloud.aiplatform.v1.StudySpec.ParameterSpec.ConditionalParameterSpec.CategoricalValueCondition"
                        .into()
                }
                fn type_url() -> ::prost::alloc::string::String {
                    "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec.ParameterSpec.ConditionalParameterSpec.CategoricalValueCondition"
                        .into()
                }
            }
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum ParentValueCondition {
                #[prost(message, tag = "2")]
                ParentDiscreteValues(DiscreteValueCondition),
                #[prost(message, tag = "3")]
                ParentIntValues(IntValueCondition),
                #[prost(message, tag = "4")]
                ParentCategoricalValues(CategoricalValueCondition),
            }
        }
        impl ::prost::Name for ConditionalParameterSpec {
            const NAME: &'static str = "ConditionalParameterSpec";
            const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "google.cloud.aiplatform.v1.StudySpec.ParameterSpec.ConditionalParameterSpec"
                    .into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec.ParameterSpec.ConditionalParameterSpec"
                    .into()
            }
        }
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum ScaleType {
            Unspecified = 0,
            UnitLinearScale = 1,
            UnitLogScale = 2,
            UnitReverseLogScale = 3,
        }
        impl ScaleType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "SCALE_TYPE_UNSPECIFIED",
                    Self::UnitLinearScale => "UNIT_LINEAR_SCALE",
                    Self::UnitLogScale => "UNIT_LOG_SCALE",
                    Self::UnitReverseLogScale => "UNIT_REVERSE_LOG_SCALE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "SCALE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "UNIT_LINEAR_SCALE" => Some(Self::UnitLinearScale),
                    "UNIT_LOG_SCALE" => Some(Self::UnitLogScale),
                    "UNIT_REVERSE_LOG_SCALE" => Some(Self::UnitReverseLogScale),
                    _ => None,
                }
            }
        }
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum ParameterValueSpec {
            #[prost(message, tag = "2")]
            DoubleValueSpec(DoubleValueSpec),
            #[prost(message, tag = "3")]
            IntegerValueSpec(IntegerValueSpec),
            #[prost(message, tag = "4")]
            CategoricalValueSpec(CategoricalValueSpec),
            #[prost(message, tag = "5")]
            DiscreteValueSpec(DiscreteValueSpec),
        }
    }
    impl ::prost::Name for ParameterSpec {
        const NAME: &'static str = "ParameterSpec";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.StudySpec.ParameterSpec".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec.ParameterSpec"
                .into()
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DecayCurveAutomatedStoppingSpec {
        #[prost(bool, tag = "1")]
        pub use_elapsed_duration: bool,
    }
    impl ::prost::Name for DecayCurveAutomatedStoppingSpec {
        const NAME: &'static str = "DecayCurveAutomatedStoppingSpec";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.StudySpec.DecayCurveAutomatedStoppingSpec".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec.DecayCurveAutomatedStoppingSpec"
                .into()
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct MedianAutomatedStoppingSpec {
        #[prost(bool, tag = "1")]
        pub use_elapsed_duration: bool,
    }
    impl ::prost::Name for MedianAutomatedStoppingSpec {
        const NAME: &'static str = "MedianAutomatedStoppingSpec";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.StudySpec.MedianAutomatedStoppingSpec".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec.MedianAutomatedStoppingSpec"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ConvexAutomatedStoppingSpec {
        #[prost(int64, tag = "1")]
        pub max_step_count: i64,
        #[prost(int64, tag = "2")]
        pub min_step_count: i64,
        #[prost(int64, tag = "3")]
        pub min_measurement_count: i64,
        #[prost(string, tag = "4")]
        pub learning_rate_parameter_name: ::prost::alloc::string::String,
        #[prost(bool, tag = "5")]
        pub use_elapsed_duration: bool,
        #[prost(bool, optional, tag = "6")]
        pub update_all_stopped_trials: ::core::option::Option<bool>,
    }
    impl ::prost::Name for ConvexAutomatedStoppingSpec {
        const NAME: &'static str = "ConvexAutomatedStoppingSpec";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.StudySpec.ConvexAutomatedStoppingSpec".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec.ConvexAutomatedStoppingSpec"
                .into()
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct StudyStoppingConfig {
        #[prost(message, optional, tag = "1")]
        pub should_stop_asap: ::core::option::Option<bool>,
        #[prost(message, optional, tag = "2")]
        pub minimum_runtime_constraint: ::core::option::Option<
            super::StudyTimeConstraint,
        >,
        #[prost(message, optional, tag = "3")]
        pub maximum_runtime_constraint: ::core::option::Option<
            super::StudyTimeConstraint,
        >,
        #[prost(message, optional, tag = "4")]
        pub min_num_trials: ::core::option::Option<i32>,
        #[prost(message, optional, tag = "5")]
        pub max_num_trials: ::core::option::Option<i32>,
        #[prost(message, optional, tag = "6")]
        pub max_num_trials_no_progress: ::core::option::Option<i32>,
        #[prost(message, optional, tag = "7")]
        pub max_duration_no_progress: ::core::option::Option<::prost_types::Duration>,
    }
    impl ::prost::Name for StudyStoppingConfig {
        const NAME: &'static str = "StudyStoppingConfig";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.StudySpec.StudyStoppingConfig".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec.StudyStoppingConfig"
                .into()
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Algorithm {
        Unspecified = 0,
        GridSearch = 2,
        RandomSearch = 3,
    }
    impl Algorithm {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "ALGORITHM_UNSPECIFIED",
                Self::GridSearch => "GRID_SEARCH",
                Self::RandomSearch => "RANDOM_SEARCH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ALGORITHM_UNSPECIFIED" => Some(Self::Unspecified),
                "GRID_SEARCH" => Some(Self::GridSearch),
                "RANDOM_SEARCH" => Some(Self::RandomSearch),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ObservationNoise {
        Unspecified = 0,
        Low = 1,
        High = 2,
    }
    impl ObservationNoise {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "OBSERVATION_NOISE_UNSPECIFIED",
                Self::Low => "LOW",
                Self::High => "HIGH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OBSERVATION_NOISE_UNSPECIFIED" => Some(Self::Unspecified),
                "LOW" => Some(Self::Low),
                "HIGH" => Some(Self::High),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MeasurementSelectionType {
        Unspecified = 0,
        LastMeasurement = 1,
        BestMeasurement = 2,
    }
    impl MeasurementSelectionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "MEASUREMENT_SELECTION_TYPE_UNSPECIFIED",
                Self::LastMeasurement => "LAST_MEASUREMENT",
                Self::BestMeasurement => "BEST_MEASUREMENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MEASUREMENT_SELECTION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "LAST_MEASUREMENT" => Some(Self::LastMeasurement),
                "BEST_MEASUREMENT" => Some(Self::BestMeasurement),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum AutomatedStoppingSpec {
        #[prost(message, tag = "4")]
        DecayCurveStoppingSpec(DecayCurveAutomatedStoppingSpec),
        #[prost(message, tag = "5")]
        MedianAutomatedStoppingSpec(MedianAutomatedStoppingSpec),
        #[prost(message, tag = "9")]
        ConvexAutomatedStoppingSpec(ConvexAutomatedStoppingSpec),
    }
}
impl ::prost::Name for StudySpec {
    const NAME: &'static str = "StudySpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.StudySpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.StudySpec".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Measurement {
    #[prost(message, optional, tag = "1")]
    pub elapsed_duration: ::core::option::Option<::prost_types::Duration>,
    #[prost(int64, tag = "2")]
    pub step_count: i64,
    #[prost(message, repeated, tag = "3")]
    pub metrics: ::prost::alloc::vec::Vec<measurement::Metric>,
}
/// Nested message and enum types in `Measurement`.
pub mod measurement {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Metric {
        #[prost(string, tag = "1")]
        pub metric_id: ::prost::alloc::string::String,
        #[prost(double, tag = "2")]
        pub value: f64,
    }
    impl ::prost::Name for Metric {
        const NAME: &'static str = "Metric";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.Measurement.Metric".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.Measurement.Metric".into()
        }
    }
}
impl ::prost::Name for Measurement {
    const NAME: &'static str = "Measurement";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.Measurement".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.Measurement".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HyperparameterTuningJob {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub study_spec: ::core::option::Option<StudySpec>,
    #[prost(int32, tag = "5")]
    pub max_trial_count: i32,
    #[prost(int32, tag = "6")]
    pub parallel_trial_count: i32,
    #[prost(int32, tag = "7")]
    pub max_failed_trial_count: i32,
    #[prost(message, optional, tag = "8")]
    pub trial_job_spec: ::core::option::Option<CustomJobSpec>,
    #[prost(message, repeated, tag = "9")]
    pub trials: ::prost::alloc::vec::Vec<Trial>,
    #[prost(enumeration = "JobState", tag = "10")]
    pub state: i32,
    #[prost(message, optional, tag = "11")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "12")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "13")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "14")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "15")]
    pub error: ::core::option::Option<super::super::super::rpc::Status>,
    #[prost(map = "string, string", tag = "16")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "17")]
    pub encryption_spec: ::core::option::Option<EncryptionSpec>,
    #[prost(bool, tag = "19")]
    pub satisfies_pzs: bool,
    #[prost(bool, tag = "20")]
    pub satisfies_pzi: bool,
}
impl ::prost::Name for HyperparameterTuningJob {
    const NAME: &'static str = "HyperparameterTuningJob";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.HyperparameterTuningJob".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.HyperparameterTuningJob".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Index {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub metadata_schema_uri: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub metadata: ::core::option::Option<::prost_types::Value>,
    #[prost(message, repeated, tag = "7")]
    pub deployed_indexes: ::prost::alloc::vec::Vec<DeployedIndexRef>,
    #[prost(string, tag = "8")]
    pub etag: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "9")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "10")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "11")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "14")]
    pub index_stats: ::core::option::Option<IndexStats>,
    #[prost(enumeration = "index::IndexUpdateMethod", tag = "16")]
    pub index_update_method: i32,
    #[prost(message, optional, tag = "17")]
    pub encryption_spec: ::core::option::Option<EncryptionSpec>,
    #[prost(bool, tag = "18")]
    pub satisfies_pzs: bool,
    #[prost(bool, tag = "19")]
    pub satisfies_pzi: bool,
}
/// Nested message and enum types in `Index`.
pub mod index {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum IndexUpdateMethod {
        Unspecified = 0,
        BatchUpdate = 1,
        StreamUpdate = 2,
    }
    impl IndexUpdateMethod {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "INDEX_UPDATE_METHOD_UNSPECIFIED",
                Self::BatchUpdate => "BATCH_UPDATE",
                Self::StreamUpdate => "STREAM_UPDATE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INDEX_UPDATE_METHOD_UNSPECIFIED" => Some(Self::Unspecified),
                "BATCH_UPDATE" => Some(Self::BatchUpdate),
                "STREAM_UPDATE" => Some(Self::StreamUpdate),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for Index {
    const NAME: &'static str = "Index";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.Index".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.Index".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexDatapoint {
    #[prost(string, tag = "1")]
    pub datapoint_id: ::prost::alloc::string::String,
    #[prost(float, repeated, packed = "false", tag = "2")]
    pub feature_vector: ::prost::alloc::vec::Vec<f32>,
    #[prost(message, optional, tag = "7")]
    pub sparse_embedding: ::core::option::Option<index_datapoint::SparseEmbedding>,
    #[prost(message, repeated, tag = "4")]
    pub restricts: ::prost::alloc::vec::Vec<index_datapoint::Restriction>,
    #[prost(message, repeated, tag = "6")]
    pub numeric_restricts: ::prost::alloc::vec::Vec<index_datapoint::NumericRestriction>,
    #[prost(message, optional, tag = "5")]
    pub crowding_tag: ::core::option::Option<index_datapoint::CrowdingTag>,
    #[prost(message, optional, tag = "8")]
    pub embedding_metadata: ::core::option::Option<::prost_types::Struct>,
}
/// Nested message and enum types in `IndexDatapoint`.
pub mod index_datapoint {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SparseEmbedding {
        #[prost(float, repeated, packed = "false", tag = "1")]
        pub values: ::prost::alloc::vec::Vec<f32>,
        #[prost(int64, repeated, packed = "false", tag = "2")]
        pub dimensions: ::prost::alloc::vec::Vec<i64>,
    }
    impl ::prost::Name for SparseEmbedding {
        const NAME: &'static str = "SparseEmbedding";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.IndexDatapoint.SparseEmbedding".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.IndexDatapoint.SparseEmbedding"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Restriction {
        #[prost(string, tag = "1")]
        pub namespace: ::prost::alloc::string::String,
        #[prost(string, repeated, tag = "2")]
        pub allow_list: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "3")]
        pub deny_list: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    impl ::prost::Name for Restriction {
        const NAME: &'static str = "Restriction";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.IndexDatapoint.Restriction".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.IndexDatapoint.Restriction"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NumericRestriction {
        #[prost(string, tag = "1")]
        pub namespace: ::prost::alloc::string::String,
        #[prost(enumeration = "numeric_restriction::Operator", tag = "5")]
        pub op: i32,
        #[prost(oneof = "numeric_restriction::Value", tags = "2, 3, 4")]
        pub value: ::core::option::Option<numeric_restriction::Value>,
    }
    /// Nested message and enum types in `NumericRestriction`.
    pub mod numeric_restriction {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Operator {
            Unspecified = 0,
            Less = 1,
            LessEqual = 2,
            Equal = 3,
            GreaterEqual = 4,
            Greater = 5,
            NotEqual = 6,
        }
        impl Operator {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "OPERATOR_UNSPECIFIED",
                    Self::Less => "LESS",
                    Self::LessEqual => "LESS_EQUAL",
                    Self::Equal => "EQUAL",
                    Self::GreaterEqual => "GREATER_EQUAL",
                    Self::Greater => "GREATER",
                    Self::NotEqual => "NOT_EQUAL",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "OPERATOR_UNSPECIFIED" => Some(Self::Unspecified),
                    "LESS" => Some(Self::Less),
                    "LESS_EQUAL" => Some(Self::LessEqual),
                    "EQUAL" => Some(Self::Equal),
                    "GREATER_EQUAL" => Some(Self::GreaterEqual),
                    "GREATER" => Some(Self::Greater),
                    "NOT_EQUAL" => Some(Self::NotEqual),
                    _ => None,
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum Value {
            #[prost(int64, tag = "2")]
            ValueInt(i64),
            #[prost(float, tag = "3")]
            ValueFloat(f32),
            #[prost(double, tag = "4")]
            ValueDouble(f64),
        }
    }
    impl ::prost::Name for NumericRestriction {
        const NAME: &'static str = "NumericRestriction";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.IndexDatapoint.NumericRestriction".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.IndexDatapoint.NumericRestriction"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CrowdingTag {
        #[prost(string, tag = "1")]
        pub crowding_attribute: ::prost::alloc::string::String,
    }
    impl ::prost::Name for CrowdingTag {
        const NAME: &'static str = "CrowdingTag";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.IndexDatapoint.CrowdingTag".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.IndexDatapoint.CrowdingTag"
                .into()
        }
    }
}
impl ::prost::Name for IndexDatapoint {
    const NAME: &'static str = "IndexDatapoint";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.IndexDatapoint".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.IndexDatapoint".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IndexStats {
    #[prost(int64, tag = "1")]
    pub vectors_count: i64,
    #[prost(int64, tag = "3")]
    pub sparse_vectors_count: i64,
    #[prost(int32, tag = "2")]
    pub shards_count: i32,
}
impl ::prost::Name for IndexStats {
    const NAME: &'static str = "IndexStats";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.IndexStats".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.IndexStats".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexEndpoint {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "4")]
    pub deployed_indexes: ::prost::alloc::vec::Vec<DeployedIndex>,
    #[prost(string, tag = "5")]
    pub etag: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "6")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "7")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "9")]
    pub network: ::prost::alloc::string::String,
    #[deprecated]
    #[prost(bool, tag = "10")]
    pub enable_private_service_connect: bool,
    #[prost(message, optional, tag = "12")]
    pub private_service_connect_config: ::core::option::Option<
        PrivateServiceConnectConfig,
    >,
    #[prost(bool, tag = "13")]
    pub public_endpoint_enabled: bool,
    #[prost(string, tag = "14")]
    pub public_endpoint_domain_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "15")]
    pub encryption_spec: ::core::option::Option<EncryptionSpec>,
    #[prost(bool, tag = "17")]
    pub satisfies_pzs: bool,
    #[prost(bool, tag = "18")]
    pub satisfies_pzi: bool,
}
impl ::prost::Name for IndexEndpoint {
    const NAME: &'static str = "IndexEndpoint";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.IndexEndpoint".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.IndexEndpoint".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployedIndex {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub index: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "5")]
    pub private_endpoints: ::core::option::Option<IndexPrivateEndpoints>,
    #[prost(message, optional, tag = "6")]
    pub index_sync_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub automatic_resources: ::core::option::Option<AutomaticResources>,
    #[prost(message, optional, tag = "16")]
    pub dedicated_resources: ::core::option::Option<DedicatedResources>,
    #[prost(bool, tag = "8")]
    pub enable_access_logging: bool,
    #[prost(bool, tag = "20")]
    pub enable_datapoint_upsert_logging: bool,
    #[prost(message, optional, tag = "9")]
    pub deployed_index_auth_config: ::core::option::Option<DeployedIndexAuthConfig>,
    #[prost(string, repeated, tag = "10")]
    pub reserved_ip_ranges: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "11")]
    pub deployment_group: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "19")]
    pub psc_automation_configs: ::prost::alloc::vec::Vec<PscAutomationConfig>,
}
impl ::prost::Name for DeployedIndex {
    const NAME: &'static str = "DeployedIndex";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeployedIndex".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeployedIndex".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployedIndexAuthConfig {
    #[prost(message, optional, tag = "1")]
    pub auth_provider: ::core::option::Option<deployed_index_auth_config::AuthProvider>,
}
/// Nested message and enum types in `DeployedIndexAuthConfig`.
pub mod deployed_index_auth_config {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AuthProvider {
        #[prost(string, repeated, tag = "1")]
        pub audiences: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "2")]
        pub allowed_issuers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    impl ::prost::Name for AuthProvider {
        const NAME: &'static str = "AuthProvider";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.DeployedIndexAuthConfig.AuthProvider".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.DeployedIndexAuthConfig.AuthProvider"
                .into()
        }
    }
}
impl ::prost::Name for DeployedIndexAuthConfig {
    const NAME: &'static str = "DeployedIndexAuthConfig";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeployedIndexAuthConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeployedIndexAuthConfig".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexPrivateEndpoints {
    #[prost(string, tag = "1")]
    pub match_grpc_address: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub service_attachment: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub psc_automated_endpoints: ::prost::alloc::vec::Vec<PscAutomatedEndpoints>,
}
impl ::prost::Name for IndexPrivateEndpoints {
    const NAME: &'static str = "IndexPrivateEndpoints";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.IndexPrivateEndpoints".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.IndexPrivateEndpoints".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateIndexEndpointRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub index_endpoint: ::core::option::Option<IndexEndpoint>,
}
impl ::prost::Name for CreateIndexEndpointRequest {
    const NAME: &'static str = "CreateIndexEndpointRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateIndexEndpointRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateIndexEndpointRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateIndexEndpointOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for CreateIndexEndpointOperationMetadata {
    const NAME: &'static str = "CreateIndexEndpointOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateIndexEndpointOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateIndexEndpointOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIndexEndpointRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for GetIndexEndpointRequest {
    const NAME: &'static str = "GetIndexEndpointRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetIndexEndpointRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetIndexEndpointRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListIndexEndpointsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for ListIndexEndpointsRequest {
    const NAME: &'static str = "ListIndexEndpointsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListIndexEndpointsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListIndexEndpointsRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListIndexEndpointsResponse {
    #[prost(message, repeated, tag = "1")]
    pub index_endpoints: ::prost::alloc::vec::Vec<IndexEndpoint>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListIndexEndpointsResponse {
    const NAME: &'static str = "ListIndexEndpointsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListIndexEndpointsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListIndexEndpointsResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateIndexEndpointRequest {
    #[prost(message, optional, tag = "1")]
    pub index_endpoint: ::core::option::Option<IndexEndpoint>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for UpdateIndexEndpointRequest {
    const NAME: &'static str = "UpdateIndexEndpointRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdateIndexEndpointRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateIndexEndpointRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteIndexEndpointRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for DeleteIndexEndpointRequest {
    const NAME: &'static str = "DeleteIndexEndpointRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeleteIndexEndpointRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteIndexEndpointRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployIndexRequest {
    #[prost(string, tag = "1")]
    pub index_endpoint: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub deployed_index: ::core::option::Option<DeployedIndex>,
}
impl ::prost::Name for DeployIndexRequest {
    const NAME: &'static str = "DeployIndexRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeployIndexRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeployIndexRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployIndexResponse {
    #[prost(message, optional, tag = "1")]
    pub deployed_index: ::core::option::Option<DeployedIndex>,
}
impl ::prost::Name for DeployIndexResponse {
    const NAME: &'static str = "DeployIndexResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeployIndexResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeployIndexResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployIndexOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
    #[prost(string, tag = "2")]
    pub deployed_index_id: ::prost::alloc::string::String,
}
impl ::prost::Name for DeployIndexOperationMetadata {
    const NAME: &'static str = "DeployIndexOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeployIndexOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeployIndexOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UndeployIndexRequest {
    #[prost(string, tag = "1")]
    pub index_endpoint: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub deployed_index_id: ::prost::alloc::string::String,
}
impl ::prost::Name for UndeployIndexRequest {
    const NAME: &'static str = "UndeployIndexRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UndeployIndexRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UndeployIndexRequest".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UndeployIndexResponse {}
impl ::prost::Name for UndeployIndexResponse {
    const NAME: &'static str = "UndeployIndexResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UndeployIndexResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UndeployIndexResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UndeployIndexOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for UndeployIndexOperationMetadata {
    const NAME: &'static str = "UndeployIndexOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UndeployIndexOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UndeployIndexOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateDeployedIndexRequest {
    #[prost(string, tag = "1")]
    pub index_endpoint: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub deployed_index: ::core::option::Option<DeployedIndex>,
}
impl ::prost::Name for MutateDeployedIndexRequest {
    const NAME: &'static str = "MutateDeployedIndexRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.MutateDeployedIndexRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.MutateDeployedIndexRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateDeployedIndexResponse {
    #[prost(message, optional, tag = "1")]
    pub deployed_index: ::core::option::Option<DeployedIndex>,
}
impl ::prost::Name for MutateDeployedIndexResponse {
    const NAME: &'static str = "MutateDeployedIndexResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.MutateDeployedIndexResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.MutateDeployedIndexResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MutateDeployedIndexOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
    #[prost(string, tag = "2")]
    pub deployed_index_id: ::prost::alloc::string::String,
}
impl ::prost::Name for MutateDeployedIndexOperationMetadata {
    const NAME: &'static str = "MutateDeployedIndexOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.MutateDeployedIndexOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.MutateDeployedIndexOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateIndexRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub index: ::core::option::Option<Index>,
}
impl ::prost::Name for CreateIndexRequest {
    const NAME: &'static str = "CreateIndexRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateIndexRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateIndexRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateIndexOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
    #[prost(message, optional, tag = "2")]
    pub nearest_neighbor_search_operation_metadata: ::core::option::Option<
        NearestNeighborSearchOperationMetadata,
    >,
}
impl ::prost::Name for CreateIndexOperationMetadata {
    const NAME: &'static str = "CreateIndexOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateIndexOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateIndexOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIndexRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for GetIndexRequest {
    const NAME: &'static str = "GetIndexRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetIndexRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetIndexRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListIndexesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for ListIndexesRequest {
    const NAME: &'static str = "ListIndexesRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListIndexesRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListIndexesRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListIndexesResponse {
    #[prost(message, repeated, tag = "1")]
    pub indexes: ::prost::alloc::vec::Vec<Index>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListIndexesResponse {
    const NAME: &'static str = "ListIndexesResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListIndexesResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListIndexesResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateIndexRequest {
    #[prost(message, optional, tag = "1")]
    pub index: ::core::option::Option<Index>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for UpdateIndexRequest {
    const NAME: &'static str = "UpdateIndexRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdateIndexRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateIndexRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateIndexOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
    #[prost(message, optional, tag = "2")]
    pub nearest_neighbor_search_operation_metadata: ::core::option::Option<
        NearestNeighborSearchOperationMetadata,
    >,
}
impl ::prost::Name for UpdateIndexOperationMetadata {
    const NAME: &'static str = "UpdateIndexOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdateIndexOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateIndexOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteIndexRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for DeleteIndexRequest {
    const NAME: &'static str = "DeleteIndexRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeleteIndexRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteIndexRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpsertDatapointsRequest {
    #[prost(string, tag = "1")]
    pub index: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub datapoints: ::prost::alloc::vec::Vec<IndexDatapoint>,
    #[prost(message, optional, tag = "3")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for UpsertDatapointsRequest {
    const NAME: &'static str = "UpsertDatapointsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpsertDatapointsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpsertDatapointsRequest".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UpsertDatapointsResponse {}
impl ::prost::Name for UpsertDatapointsResponse {
    const NAME: &'static str = "UpsertDatapointsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpsertDatapointsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpsertDatapointsResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveDatapointsRequest {
    #[prost(string, tag = "1")]
    pub index: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub datapoint_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for RemoveDatapointsRequest {
    const NAME: &'static str = "RemoveDatapointsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.RemoveDatapointsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.RemoveDatapointsRequest".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RemoveDatapointsResponse {}
impl ::prost::Name for RemoveDatapointsResponse {
    const NAME: &'static str = "RemoveDatapointsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.RemoveDatapointsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.RemoveDatapointsResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NearestNeighborSearchOperationMetadata {
    #[prost(message, repeated, tag = "1")]
    pub content_validation_stats: ::prost::alloc::vec::Vec<
        nearest_neighbor_search_operation_metadata::ContentValidationStats,
    >,
    #[prost(int64, tag = "2")]
    pub data_bytes_count: i64,
}
/// Nested message and enum types in `NearestNeighborSearchOperationMetadata`.
pub mod nearest_neighbor_search_operation_metadata {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RecordError {
        #[prost(enumeration = "record_error::RecordErrorType", tag = "1")]
        pub error_type: i32,
        #[prost(string, tag = "2")]
        pub error_message: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub source_gcs_uri: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub embedding_id: ::prost::alloc::string::String,
        #[prost(string, tag = "5")]
        pub raw_record: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `RecordError`.
    pub mod record_error {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum RecordErrorType {
            ErrorTypeUnspecified = 0,
            EmptyLine = 1,
            InvalidJsonSyntax = 2,
            InvalidCsvSyntax = 3,
            InvalidAvroSyntax = 4,
            InvalidEmbeddingId = 5,
            EmbeddingSizeMismatch = 6,
            NamespaceMissing = 7,
            ParsingError = 8,
            DuplicateNamespace = 9,
            OpInDatapoint = 10,
            MultipleValues = 11,
            InvalidNumericValue = 12,
            InvalidEncoding = 13,
            InvalidSparseDimensions = 14,
            InvalidTokenValue = 15,
            InvalidSparseEmbedding = 16,
            InvalidEmbedding = 17,
        }
        impl RecordErrorType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::ErrorTypeUnspecified => "ERROR_TYPE_UNSPECIFIED",
                    Self::EmptyLine => "EMPTY_LINE",
                    Self::InvalidJsonSyntax => "INVALID_JSON_SYNTAX",
                    Self::InvalidCsvSyntax => "INVALID_CSV_SYNTAX",
                    Self::InvalidAvroSyntax => "INVALID_AVRO_SYNTAX",
                    Self::InvalidEmbeddingId => "INVALID_EMBEDDING_ID",
                    Self::EmbeddingSizeMismatch => "EMBEDDING_SIZE_MISMATCH",
                    Self::NamespaceMissing => "NAMESPACE_MISSING",
                    Self::ParsingError => "PARSING_ERROR",
                    Self::DuplicateNamespace => "DUPLICATE_NAMESPACE",
                    Self::OpInDatapoint => "OP_IN_DATAPOINT",
                    Self::MultipleValues => "MULTIPLE_VALUES",
                    Self::InvalidNumericValue => "INVALID_NUMERIC_VALUE",
                    Self::InvalidEncoding => "INVALID_ENCODING",
                    Self::InvalidSparseDimensions => "INVALID_SPARSE_DIMENSIONS",
                    Self::InvalidTokenValue => "INVALID_TOKEN_VALUE",
                    Self::InvalidSparseEmbedding => "INVALID_SPARSE_EMBEDDING",
                    Self::InvalidEmbedding => "INVALID_EMBEDDING",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "ERROR_TYPE_UNSPECIFIED" => Some(Self::ErrorTypeUnspecified),
                    "EMPTY_LINE" => Some(Self::EmptyLine),
                    "INVALID_JSON_SYNTAX" => Some(Self::InvalidJsonSyntax),
                    "INVALID_CSV_SYNTAX" => Some(Self::InvalidCsvSyntax),
                    "INVALID_AVRO_SYNTAX" => Some(Self::InvalidAvroSyntax),
                    "INVALID_EMBEDDING_ID" => Some(Self::InvalidEmbeddingId),
                    "EMBEDDING_SIZE_MISMATCH" => Some(Self::EmbeddingSizeMismatch),
                    "NAMESPACE_MISSING" => Some(Self::NamespaceMissing),
                    "PARSING_ERROR" => Some(Self::ParsingError),
                    "DUPLICATE_NAMESPACE" => Some(Self::DuplicateNamespace),
                    "OP_IN_DATAPOINT" => Some(Self::OpInDatapoint),
                    "MULTIPLE_VALUES" => Some(Self::MultipleValues),
                    "INVALID_NUMERIC_VALUE" => Some(Self::InvalidNumericValue),
                    "INVALID_ENCODING" => Some(Self::InvalidEncoding),
                    "INVALID_SPARSE_DIMENSIONS" => Some(Self::InvalidSparseDimensions),
                    "INVALID_TOKEN_VALUE" => Some(Self::InvalidTokenValue),
                    "INVALID_SPARSE_EMBEDDING" => Some(Self::InvalidSparseEmbedding),
                    "INVALID_EMBEDDING" => Some(Self::InvalidEmbedding),
                    _ => None,
                }
            }
        }
    }
    impl ::prost::Name for RecordError {
        const NAME: &'static str = "RecordError";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.NearestNeighborSearchOperationMetadata.RecordError"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.NearestNeighborSearchOperationMetadata.RecordError"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ContentValidationStats {
        #[prost(string, tag = "1")]
        pub source_gcs_uri: ::prost::alloc::string::String,
        #[prost(int64, tag = "2")]
        pub valid_record_count: i64,
        #[prost(int64, tag = "3")]
        pub invalid_record_count: i64,
        #[prost(message, repeated, tag = "4")]
        pub partial_errors: ::prost::alloc::vec::Vec<RecordError>,
        #[prost(int64, tag = "5")]
        pub valid_sparse_record_count: i64,
        #[prost(int64, tag = "6")]
        pub invalid_sparse_record_count: i64,
    }
    impl ::prost::Name for ContentValidationStats {
        const NAME: &'static str = "ContentValidationStats";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.NearestNeighborSearchOperationMetadata.ContentValidationStats"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.NearestNeighborSearchOperationMetadata.ContentValidationStats"
                .into()
        }
    }
}
impl ::prost::Name for NearestNeighborSearchOperationMetadata {
    const NAME: &'static str = "NearestNeighborSearchOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.NearestNeighborSearchOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.NearestNeighborSearchOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModelMonitoringObjectiveConfig {
    #[prost(message, optional, tag = "1")]
    pub training_dataset: ::core::option::Option<
        model_monitoring_objective_config::TrainingDataset,
    >,
    #[prost(message, optional, tag = "2")]
    pub training_prediction_skew_detection_config: ::core::option::Option<
        model_monitoring_objective_config::TrainingPredictionSkewDetectionConfig,
    >,
    #[prost(message, optional, tag = "3")]
    pub prediction_drift_detection_config: ::core::option::Option<
        model_monitoring_objective_config::PredictionDriftDetectionConfig,
    >,
    #[prost(message, optional, tag = "5")]
    pub explanation_config: ::core::option::Option<
        model_monitoring_objective_config::ExplanationConfig,
    >,
}
/// Nested message and enum types in `ModelMonitoringObjectiveConfig`.
pub mod model_monitoring_objective_config {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TrainingDataset {
        #[prost(string, tag = "2")]
        pub data_format: ::prost::alloc::string::String,
        #[prost(string, tag = "6")]
        pub target_field: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "7")]
        pub logging_sampling_strategy: ::core::option::Option<super::SamplingStrategy>,
        #[prost(oneof = "training_dataset::DataSource", tags = "3, 4, 5")]
        pub data_source: ::core::option::Option<training_dataset::DataSource>,
    }
    /// Nested message and enum types in `TrainingDataset`.
    pub mod training_dataset {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum DataSource {
            #[prost(string, tag = "3")]
            Dataset(::prost::alloc::string::String),
            #[prost(message, tag = "4")]
            GcsSource(super::super::GcsSource),
            #[prost(message, tag = "5")]
            BigquerySource(super::super::BigQuerySource),
        }
    }
    impl ::prost::Name for TrainingDataset {
        const NAME: &'static str = "TrainingDataset";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.ModelMonitoringObjectiveConfig.TrainingDataset"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.ModelMonitoringObjectiveConfig.TrainingDataset"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TrainingPredictionSkewDetectionConfig {
        #[prost(map = "string, message", tag = "1")]
        pub skew_thresholds: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            super::ThresholdConfig,
        >,
        #[prost(map = "string, message", tag = "2")]
        pub attribution_score_skew_thresholds: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            super::ThresholdConfig,
        >,
        #[prost(message, optional, tag = "6")]
        pub default_skew_threshold: ::core::option::Option<super::ThresholdConfig>,
    }
    impl ::prost::Name for TrainingPredictionSkewDetectionConfig {
        const NAME: &'static str = "TrainingPredictionSkewDetectionConfig";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.ModelMonitoringObjectiveConfig.TrainingPredictionSkewDetectionConfig"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.ModelMonitoringObjectiveConfig.TrainingPredictionSkewDetectionConfig"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PredictionDriftDetectionConfig {
        #[prost(map = "string, message", tag = "1")]
        pub drift_thresholds: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            super::ThresholdConfig,
        >,
        #[prost(map = "string, message", tag = "2")]
        pub attribution_score_drift_thresholds: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            super::ThresholdConfig,
        >,
        #[prost(message, optional, tag = "5")]
        pub default_drift_threshold: ::core::option::Option<super::ThresholdConfig>,
    }
    impl ::prost::Name for PredictionDriftDetectionConfig {
        const NAME: &'static str = "PredictionDriftDetectionConfig";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.ModelMonitoringObjectiveConfig.PredictionDriftDetectionConfig"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.ModelMonitoringObjectiveConfig.PredictionDriftDetectionConfig"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ExplanationConfig {
        #[prost(bool, tag = "1")]
        pub enable_feature_attributes: bool,
        #[prost(message, optional, tag = "2")]
        pub explanation_baseline: ::core::option::Option<
            explanation_config::ExplanationBaseline,
        >,
    }
    /// Nested message and enum types in `ExplanationConfig`.
    pub mod explanation_config {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct ExplanationBaseline {
            #[prost(enumeration = "explanation_baseline::PredictionFormat", tag = "1")]
            pub prediction_format: i32,
            #[prost(oneof = "explanation_baseline::Destination", tags = "2, 3")]
            pub destination: ::core::option::Option<explanation_baseline::Destination>,
        }
        /// Nested message and enum types in `ExplanationBaseline`.
        pub mod explanation_baseline {
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum PredictionFormat {
                Unspecified = 0,
                Jsonl = 2,
                Bigquery = 3,
            }
            impl PredictionFormat {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Unspecified => "PREDICTION_FORMAT_UNSPECIFIED",
                        Self::Jsonl => "JSONL",
                        Self::Bigquery => "BIGQUERY",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "PREDICTION_FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
                        "JSONL" => Some(Self::Jsonl),
                        "BIGQUERY" => Some(Self::Bigquery),
                        _ => None,
                    }
                }
            }
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum Destination {
                #[prost(message, tag = "2")]
                Gcs(super::super::super::GcsDestination),
                #[prost(message, tag = "3")]
                Bigquery(super::super::super::BigQueryDestination),
            }
        }
        impl ::prost::Name for ExplanationBaseline {
            const NAME: &'static str = "ExplanationBaseline";
            const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "google.cloud.aiplatform.v1.ModelMonitoringObjectiveConfig.ExplanationConfig.ExplanationBaseline"
                    .into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.cloud.aiplatform.v1.ModelMonitoringObjectiveConfig.ExplanationConfig.ExplanationBaseline"
                    .into()
            }
        }
    }
    impl ::prost::Name for ExplanationConfig {
        const NAME: &'static str = "ExplanationConfig";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.ModelMonitoringObjectiveConfig.ExplanationConfig"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.ModelMonitoringObjectiveConfig.ExplanationConfig"
                .into()
        }
    }
}
impl ::prost::Name for ModelMonitoringObjectiveConfig {
    const NAME: &'static str = "ModelMonitoringObjectiveConfig";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ModelMonitoringObjectiveConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ModelMonitoringObjectiveConfig"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModelMonitoringAlertConfig {
    #[prost(bool, tag = "2")]
    pub enable_logging: bool,
    #[prost(string, repeated, tag = "3")]
    pub notification_channels: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(oneof = "model_monitoring_alert_config::Alert", tags = "1")]
    pub alert: ::core::option::Option<model_monitoring_alert_config::Alert>,
}
/// Nested message and enum types in `ModelMonitoringAlertConfig`.
pub mod model_monitoring_alert_config {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EmailAlertConfig {
        #[prost(string, repeated, tag = "1")]
        pub user_emails: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    impl ::prost::Name for EmailAlertConfig {
        const NAME: &'static str = "EmailAlertConfig";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.ModelMonitoringAlertConfig.EmailAlertConfig"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.ModelMonitoringAlertConfig.EmailAlertConfig"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Alert {
        #[prost(message, tag = "1")]
        EmailAlertConfig(EmailAlertConfig),
    }
}
impl ::prost::Name for ModelMonitoringAlertConfig {
    const NAME: &'static str = "ModelMonitoringAlertConfig";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ModelMonitoringAlertConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ModelMonitoringAlertConfig"
            .into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ThresholdConfig {
    #[prost(oneof = "threshold_config::Threshold", tags = "1")]
    pub threshold: ::core::option::Option<threshold_config::Threshold>,
}
/// Nested message and enum types in `ThresholdConfig`.
pub mod threshold_config {
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Threshold {
        #[prost(double, tag = "1")]
        Value(f64),
    }
}
impl ::prost::Name for ThresholdConfig {
    const NAME: &'static str = "ThresholdConfig";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ThresholdConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ThresholdConfig".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SamplingStrategy {
    #[prost(message, optional, tag = "1")]
    pub random_sample_config: ::core::option::Option<
        sampling_strategy::RandomSampleConfig,
    >,
}
/// Nested message and enum types in `SamplingStrategy`.
pub mod sampling_strategy {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct RandomSampleConfig {
        #[prost(double, tag = "1")]
        pub sample_rate: f64,
    }
    impl ::prost::Name for RandomSampleConfig {
        const NAME: &'static str = "RandomSampleConfig";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.SamplingStrategy.RandomSampleConfig".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.SamplingStrategy.RandomSampleConfig"
                .into()
        }
    }
}
impl ::prost::Name for SamplingStrategy {
    const NAME: &'static str = "SamplingStrategy";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SamplingStrategy".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SamplingStrategy".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModelDeploymentMonitoringJob {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub endpoint: ::prost::alloc::string::String,
    #[prost(enumeration = "JobState", tag = "4")]
    pub state: i32,
    #[prost(
        enumeration = "model_deployment_monitoring_job::MonitoringScheduleState",
        tag = "5"
    )]
    pub schedule_state: i32,
    #[prost(message, optional, tag = "25")]
    pub latest_monitoring_pipeline_metadata: ::core::option::Option<
        model_deployment_monitoring_job::LatestMonitoringPipelineMetadata,
    >,
    #[prost(message, repeated, tag = "6")]
    pub model_deployment_monitoring_objective_configs: ::prost::alloc::vec::Vec<
        ModelDeploymentMonitoringObjectiveConfig,
    >,
    #[prost(message, optional, tag = "7")]
    pub model_deployment_monitoring_schedule_config: ::core::option::Option<
        ModelDeploymentMonitoringScheduleConfig,
    >,
    #[prost(message, optional, tag = "8")]
    pub logging_sampling_strategy: ::core::option::Option<SamplingStrategy>,
    #[prost(message, optional, tag = "15")]
    pub model_monitoring_alert_config: ::core::option::Option<
        ModelMonitoringAlertConfig,
    >,
    #[prost(string, tag = "9")]
    pub predict_instance_schema_uri: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "19")]
    pub sample_predict_instance: ::core::option::Option<::prost_types::Value>,
    #[prost(string, tag = "16")]
    pub analysis_instance_schema_uri: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "10")]
    pub bigquery_tables: ::prost::alloc::vec::Vec<
        ModelDeploymentMonitoringBigQueryTable,
    >,
    #[prost(message, optional, tag = "17")]
    pub log_ttl: ::core::option::Option<::prost_types::Duration>,
    #[prost(map = "string, string", tag = "11")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "12")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "13")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "14")]
    pub next_schedule_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "20")]
    pub stats_anomalies_base_directory: ::core::option::Option<GcsDestination>,
    #[prost(message, optional, tag = "21")]
    pub encryption_spec: ::core::option::Option<EncryptionSpec>,
    #[prost(bool, tag = "22")]
    pub enable_monitoring_pipeline_logs: bool,
    #[prost(message, optional, tag = "23")]
    pub error: ::core::option::Option<super::super::super::rpc::Status>,
    #[prost(bool, tag = "26")]
    pub satisfies_pzs: bool,
    #[prost(bool, tag = "27")]
    pub satisfies_pzi: bool,
}
/// Nested message and enum types in `ModelDeploymentMonitoringJob`.
pub mod model_deployment_monitoring_job {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LatestMonitoringPipelineMetadata {
        #[prost(message, optional, tag = "1")]
        pub run_time: ::core::option::Option<::prost_types::Timestamp>,
        #[prost(message, optional, tag = "2")]
        pub status: ::core::option::Option<super::super::super::super::rpc::Status>,
    }
    impl ::prost::Name for LatestMonitoringPipelineMetadata {
        const NAME: &'static str = "LatestMonitoringPipelineMetadata";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.ModelDeploymentMonitoringJob.LatestMonitoringPipelineMetadata"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.ModelDeploymentMonitoringJob.LatestMonitoringPipelineMetadata"
                .into()
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MonitoringScheduleState {
        Unspecified = 0,
        Pending = 1,
        Offline = 2,
        Running = 3,
    }
    impl MonitoringScheduleState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "MONITORING_SCHEDULE_STATE_UNSPECIFIED",
                Self::Pending => "PENDING",
                Self::Offline => "OFFLINE",
                Self::Running => "RUNNING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MONITORING_SCHEDULE_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PENDING" => Some(Self::Pending),
                "OFFLINE" => Some(Self::Offline),
                "RUNNING" => Some(Self::Running),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for ModelDeploymentMonitoringJob {
    const NAME: &'static str = "ModelDeploymentMonitoringJob";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ModelDeploymentMonitoringJob".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ModelDeploymentMonitoringJob"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModelDeploymentMonitoringBigQueryTable {
    #[prost(
        enumeration = "model_deployment_monitoring_big_query_table::LogSource",
        tag = "1"
    )]
    pub log_source: i32,
    #[prost(
        enumeration = "model_deployment_monitoring_big_query_table::LogType",
        tag = "2"
    )]
    pub log_type: i32,
    #[prost(string, tag = "3")]
    pub bigquery_table_path: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub request_response_logging_schema_version: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ModelDeploymentMonitoringBigQueryTable`.
pub mod model_deployment_monitoring_big_query_table {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LogSource {
        Unspecified = 0,
        Training = 1,
        Serving = 2,
    }
    impl LogSource {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "LOG_SOURCE_UNSPECIFIED",
                Self::Training => "TRAINING",
                Self::Serving => "SERVING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LOG_SOURCE_UNSPECIFIED" => Some(Self::Unspecified),
                "TRAINING" => Some(Self::Training),
                "SERVING" => Some(Self::Serving),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LogType {
        Unspecified = 0,
        Predict = 1,
        Explain = 2,
    }
    impl LogType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "LOG_TYPE_UNSPECIFIED",
                Self::Predict => "PREDICT",
                Self::Explain => "EXPLAIN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LOG_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "PREDICT" => Some(Self::Predict),
                "EXPLAIN" => Some(Self::Explain),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for ModelDeploymentMonitoringBigQueryTable {
    const NAME: &'static str = "ModelDeploymentMonitoringBigQueryTable";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ModelDeploymentMonitoringBigQueryTable".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ModelDeploymentMonitoringBigQueryTable"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModelDeploymentMonitoringObjectiveConfig {
    #[prost(string, tag = "1")]
    pub deployed_model_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub objective_config: ::core::option::Option<ModelMonitoringObjectiveConfig>,
}
impl ::prost::Name for ModelDeploymentMonitoringObjectiveConfig {
    const NAME: &'static str = "ModelDeploymentMonitoringObjectiveConfig";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ModelDeploymentMonitoringObjectiveConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ModelDeploymentMonitoringObjectiveConfig"
            .into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ModelDeploymentMonitoringScheduleConfig {
    #[prost(message, optional, tag = "1")]
    pub monitor_interval: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "2")]
    pub monitor_window: ::core::option::Option<::prost_types::Duration>,
}
impl ::prost::Name for ModelDeploymentMonitoringScheduleConfig {
    const NAME: &'static str = "ModelDeploymentMonitoringScheduleConfig";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ModelDeploymentMonitoringScheduleConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ModelDeploymentMonitoringScheduleConfig"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModelMonitoringStatsAnomalies {
    #[prost(enumeration = "ModelDeploymentMonitoringObjectiveType", tag = "1")]
    pub objective: i32,
    #[prost(string, tag = "2")]
    pub deployed_model_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub anomaly_count: i32,
    #[prost(message, repeated, tag = "4")]
    pub feature_stats: ::prost::alloc::vec::Vec<
        model_monitoring_stats_anomalies::FeatureHistoricStatsAnomalies,
    >,
}
/// Nested message and enum types in `ModelMonitoringStatsAnomalies`.
pub mod model_monitoring_stats_anomalies {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FeatureHistoricStatsAnomalies {
        #[prost(string, tag = "1")]
        pub feature_display_name: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "3")]
        pub threshold: ::core::option::Option<super::ThresholdConfig>,
        #[prost(message, optional, tag = "4")]
        pub training_stats: ::core::option::Option<super::FeatureStatsAnomaly>,
        #[prost(message, repeated, tag = "5")]
        pub prediction_stats: ::prost::alloc::vec::Vec<super::FeatureStatsAnomaly>,
    }
    impl ::prost::Name for FeatureHistoricStatsAnomalies {
        const NAME: &'static str = "FeatureHistoricStatsAnomalies";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.ModelMonitoringStatsAnomalies.FeatureHistoricStatsAnomalies"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.ModelMonitoringStatsAnomalies.FeatureHistoricStatsAnomalies"
                .into()
        }
    }
}
impl ::prost::Name for ModelMonitoringStatsAnomalies {
    const NAME: &'static str = "ModelMonitoringStatsAnomalies";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ModelMonitoringStatsAnomalies".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ModelMonitoringStatsAnomalies"
            .into()
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ModelDeploymentMonitoringObjectiveType {
    Unspecified = 0,
    RawFeatureSkew = 1,
    RawFeatureDrift = 2,
    FeatureAttributionSkew = 3,
    FeatureAttributionDrift = 4,
}
impl ModelDeploymentMonitoringObjectiveType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "MODEL_DEPLOYMENT_MONITORING_OBJECTIVE_TYPE_UNSPECIFIED",
            Self::RawFeatureSkew => "RAW_FEATURE_SKEW",
            Self::RawFeatureDrift => "RAW_FEATURE_DRIFT",
            Self::FeatureAttributionSkew => "FEATURE_ATTRIBUTION_SKEW",
            Self::FeatureAttributionDrift => "FEATURE_ATTRIBUTION_DRIFT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MODEL_DEPLOYMENT_MONITORING_OBJECTIVE_TYPE_UNSPECIFIED" => {
                Some(Self::Unspecified)
            }
            "RAW_FEATURE_SKEW" => Some(Self::RawFeatureSkew),
            "RAW_FEATURE_DRIFT" => Some(Self::RawFeatureDrift),
            "FEATURE_ATTRIBUTION_SKEW" => Some(Self::FeatureAttributionSkew),
            "FEATURE_ATTRIBUTION_DRIFT" => Some(Self::FeatureAttributionDrift),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NasJob {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub nas_job_spec: ::core::option::Option<NasJobSpec>,
    #[prost(message, optional, tag = "5")]
    pub nas_job_output: ::core::option::Option<NasJobOutput>,
    #[prost(enumeration = "JobState", tag = "6")]
    pub state: i32,
    #[prost(message, optional, tag = "7")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "10")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "11")]
    pub error: ::core::option::Option<super::super::super::rpc::Status>,
    #[prost(map = "string, string", tag = "12")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "13")]
    pub encryption_spec: ::core::option::Option<EncryptionSpec>,
    #[deprecated]
    #[prost(bool, tag = "14")]
    pub enable_restricted_image_training: bool,
    #[prost(bool, tag = "15")]
    pub satisfies_pzs: bool,
    #[prost(bool, tag = "16")]
    pub satisfies_pzi: bool,
}
impl ::prost::Name for NasJob {
    const NAME: &'static str = "NasJob";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.NasJob".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.NasJob".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NasTrialDetail {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub parameters: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub search_trial: ::core::option::Option<NasTrial>,
    #[prost(message, optional, tag = "4")]
    pub train_trial: ::core::option::Option<NasTrial>,
}
impl ::prost::Name for NasTrialDetail {
    const NAME: &'static str = "NasTrialDetail";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.NasTrialDetail".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.NasTrialDetail".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NasJobSpec {
    #[prost(string, tag = "3")]
    pub resume_nas_job_id: ::prost::alloc::string::String,
    #[prost(string, tag = "1")]
    pub search_space_spec: ::prost::alloc::string::String,
    #[prost(oneof = "nas_job_spec::NasAlgorithmSpec", tags = "2")]
    pub nas_algorithm_spec: ::core::option::Option<nas_job_spec::NasAlgorithmSpec>,
}
/// Nested message and enum types in `NasJobSpec`.
pub mod nas_job_spec {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MultiTrialAlgorithmSpec {
        #[prost(
            enumeration = "multi_trial_algorithm_spec::MultiTrialAlgorithm",
            tag = "1"
        )]
        pub multi_trial_algorithm: i32,
        #[prost(message, optional, tag = "2")]
        pub metric: ::core::option::Option<multi_trial_algorithm_spec::MetricSpec>,
        #[prost(message, optional, tag = "3")]
        pub search_trial_spec: ::core::option::Option<
            multi_trial_algorithm_spec::SearchTrialSpec,
        >,
        #[prost(message, optional, tag = "4")]
        pub train_trial_spec: ::core::option::Option<
            multi_trial_algorithm_spec::TrainTrialSpec,
        >,
    }
    /// Nested message and enum types in `MultiTrialAlgorithmSpec`.
    pub mod multi_trial_algorithm_spec {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct MetricSpec {
            #[prost(string, tag = "1")]
            pub metric_id: ::prost::alloc::string::String,
            #[prost(enumeration = "metric_spec::GoalType", tag = "2")]
            pub goal: i32,
        }
        /// Nested message and enum types in `MetricSpec`.
        pub mod metric_spec {
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum GoalType {
                Unspecified = 0,
                Maximize = 1,
                Minimize = 2,
            }
            impl GoalType {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Unspecified => "GOAL_TYPE_UNSPECIFIED",
                        Self::Maximize => "MAXIMIZE",
                        Self::Minimize => "MINIMIZE",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "GOAL_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                        "MAXIMIZE" => Some(Self::Maximize),
                        "MINIMIZE" => Some(Self::Minimize),
                        _ => None,
                    }
                }
            }
        }
        impl ::prost::Name for MetricSpec {
            const NAME: &'static str = "MetricSpec";
            const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "google.cloud.aiplatform.v1.NasJobSpec.MultiTrialAlgorithmSpec.MetricSpec"
                    .into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.cloud.aiplatform.v1.NasJobSpec.MultiTrialAlgorithmSpec.MetricSpec"
                    .into()
            }
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct SearchTrialSpec {
            #[prost(message, optional, tag = "1")]
            pub search_trial_job_spec: ::core::option::Option<
                super::super::CustomJobSpec,
            >,
            #[prost(int32, tag = "2")]
            pub max_trial_count: i32,
            #[prost(int32, tag = "3")]
            pub max_parallel_trial_count: i32,
            #[prost(int32, tag = "4")]
            pub max_failed_trial_count: i32,
        }
        impl ::prost::Name for SearchTrialSpec {
            const NAME: &'static str = "SearchTrialSpec";
            const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "google.cloud.aiplatform.v1.NasJobSpec.MultiTrialAlgorithmSpec.SearchTrialSpec"
                    .into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.cloud.aiplatform.v1.NasJobSpec.MultiTrialAlgorithmSpec.SearchTrialSpec"
                    .into()
            }
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct TrainTrialSpec {
            #[prost(message, optional, tag = "1")]
            pub train_trial_job_spec: ::core::option::Option<
                super::super::CustomJobSpec,
            >,
            #[prost(int32, tag = "2")]
            pub max_parallel_trial_count: i32,
            #[prost(int32, tag = "3")]
            pub frequency: i32,
        }
        impl ::prost::Name for TrainTrialSpec {
            const NAME: &'static str = "TrainTrialSpec";
            const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "google.cloud.aiplatform.v1.NasJobSpec.MultiTrialAlgorithmSpec.TrainTrialSpec"
                    .into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.cloud.aiplatform.v1.NasJobSpec.MultiTrialAlgorithmSpec.TrainTrialSpec"
                    .into()
            }
        }
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum MultiTrialAlgorithm {
            Unspecified = 0,
            ReinforcementLearning = 1,
            GridSearch = 2,
        }
        impl MultiTrialAlgorithm {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "MULTI_TRIAL_ALGORITHM_UNSPECIFIED",
                    Self::ReinforcementLearning => "REINFORCEMENT_LEARNING",
                    Self::GridSearch => "GRID_SEARCH",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "MULTI_TRIAL_ALGORITHM_UNSPECIFIED" => Some(Self::Unspecified),
                    "REINFORCEMENT_LEARNING" => Some(Self::ReinforcementLearning),
                    "GRID_SEARCH" => Some(Self::GridSearch),
                    _ => None,
                }
            }
        }
    }
    impl ::prost::Name for MultiTrialAlgorithmSpec {
        const NAME: &'static str = "MultiTrialAlgorithmSpec";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.NasJobSpec.MultiTrialAlgorithmSpec".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.NasJobSpec.MultiTrialAlgorithmSpec"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum NasAlgorithmSpec {
        #[prost(message, tag = "2")]
        MultiTrialAlgorithmSpec(MultiTrialAlgorithmSpec),
    }
}
impl ::prost::Name for NasJobSpec {
    const NAME: &'static str = "NasJobSpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.NasJobSpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.NasJobSpec".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NasJobOutput {
    #[prost(oneof = "nas_job_output::Output", tags = "1")]
    pub output: ::core::option::Option<nas_job_output::Output>,
}
/// Nested message and enum types in `NasJobOutput`.
pub mod nas_job_output {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MultiTrialJobOutput {
        #[prost(message, repeated, tag = "1")]
        pub search_trials: ::prost::alloc::vec::Vec<super::NasTrial>,
        #[prost(message, repeated, tag = "2")]
        pub train_trials: ::prost::alloc::vec::Vec<super::NasTrial>,
    }
    impl ::prost::Name for MultiTrialJobOutput {
        const NAME: &'static str = "MultiTrialJobOutput";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.NasJobOutput.MultiTrialJobOutput".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.NasJobOutput.MultiTrialJobOutput"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Output {
        #[prost(message, tag = "1")]
        MultiTrialJobOutput(MultiTrialJobOutput),
    }
}
impl ::prost::Name for NasJobOutput {
    const NAME: &'static str = "NasJobOutput";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.NasJobOutput".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.NasJobOutput".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NasTrial {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(enumeration = "nas_trial::State", tag = "2")]
    pub state: i32,
    #[prost(message, optional, tag = "3")]
    pub final_measurement: ::core::option::Option<Measurement>,
    #[prost(message, optional, tag = "4")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "5")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `NasTrial`.
pub mod nas_trial {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Requested = 1,
        Active = 2,
        Stopping = 3,
        Succeeded = 4,
        Infeasible = 5,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Requested => "REQUESTED",
                Self::Active => "ACTIVE",
                Self::Stopping => "STOPPING",
                Self::Succeeded => "SUCCEEDED",
                Self::Infeasible => "INFEASIBLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "REQUESTED" => Some(Self::Requested),
                "ACTIVE" => Some(Self::Active),
                "STOPPING" => Some(Self::Stopping),
                "SUCCEEDED" => Some(Self::Succeeded),
                "INFEASIBLE" => Some(Self::Infeasible),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for NasTrial {
    const NAME: &'static str = "NasTrial";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.NasTrial".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.NasTrial".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCustomJobRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub custom_job: ::core::option::Option<CustomJob>,
}
impl ::prost::Name for CreateCustomJobRequest {
    const NAME: &'static str = "CreateCustomJobRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateCustomJobRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateCustomJobRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCustomJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for GetCustomJobRequest {
    const NAME: &'static str = "GetCustomJobRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetCustomJobRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetCustomJobRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCustomJobsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for ListCustomJobsRequest {
    const NAME: &'static str = "ListCustomJobsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListCustomJobsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListCustomJobsRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCustomJobsResponse {
    #[prost(message, repeated, tag = "1")]
    pub custom_jobs: ::prost::alloc::vec::Vec<CustomJob>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListCustomJobsResponse {
    const NAME: &'static str = "ListCustomJobsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListCustomJobsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListCustomJobsResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteCustomJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for DeleteCustomJobRequest {
    const NAME: &'static str = "DeleteCustomJobRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeleteCustomJobRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteCustomJobRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelCustomJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for CancelCustomJobRequest {
    const NAME: &'static str = "CancelCustomJobRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CancelCustomJobRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CancelCustomJobRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDataLabelingJobRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub data_labeling_job: ::core::option::Option<DataLabelingJob>,
}
impl ::prost::Name for CreateDataLabelingJobRequest {
    const NAME: &'static str = "CreateDataLabelingJobRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateDataLabelingJobRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateDataLabelingJobRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDataLabelingJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for GetDataLabelingJobRequest {
    const NAME: &'static str = "GetDataLabelingJobRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetDataLabelingJobRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetDataLabelingJobRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDataLabelingJobsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(string, tag = "6")]
    pub order_by: ::prost::alloc::string::String,
}
impl ::prost::Name for ListDataLabelingJobsRequest {
    const NAME: &'static str = "ListDataLabelingJobsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListDataLabelingJobsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListDataLabelingJobsRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDataLabelingJobsResponse {
    #[prost(message, repeated, tag = "1")]
    pub data_labeling_jobs: ::prost::alloc::vec::Vec<DataLabelingJob>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListDataLabelingJobsResponse {
    const NAME: &'static str = "ListDataLabelingJobsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListDataLabelingJobsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListDataLabelingJobsResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDataLabelingJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for DeleteDataLabelingJobRequest {
    const NAME: &'static str = "DeleteDataLabelingJobRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeleteDataLabelingJobRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteDataLabelingJobRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelDataLabelingJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for CancelDataLabelingJobRequest {
    const NAME: &'static str = "CancelDataLabelingJobRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CancelDataLabelingJobRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CancelDataLabelingJobRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateHyperparameterTuningJobRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub hyperparameter_tuning_job: ::core::option::Option<HyperparameterTuningJob>,
}
impl ::prost::Name for CreateHyperparameterTuningJobRequest {
    const NAME: &'static str = "CreateHyperparameterTuningJobRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateHyperparameterTuningJobRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateHyperparameterTuningJobRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetHyperparameterTuningJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for GetHyperparameterTuningJobRequest {
    const NAME: &'static str = "GetHyperparameterTuningJobRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetHyperparameterTuningJobRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetHyperparameterTuningJobRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListHyperparameterTuningJobsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for ListHyperparameterTuningJobsRequest {
    const NAME: &'static str = "ListHyperparameterTuningJobsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListHyperparameterTuningJobsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListHyperparameterTuningJobsRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListHyperparameterTuningJobsResponse {
    #[prost(message, repeated, tag = "1")]
    pub hyperparameter_tuning_jobs: ::prost::alloc::vec::Vec<HyperparameterTuningJob>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListHyperparameterTuningJobsResponse {
    const NAME: &'static str = "ListHyperparameterTuningJobsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListHyperparameterTuningJobsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListHyperparameterTuningJobsResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteHyperparameterTuningJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for DeleteHyperparameterTuningJobRequest {
    const NAME: &'static str = "DeleteHyperparameterTuningJobRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeleteHyperparameterTuningJobRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteHyperparameterTuningJobRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelHyperparameterTuningJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for CancelHyperparameterTuningJobRequest {
    const NAME: &'static str = "CancelHyperparameterTuningJobRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CancelHyperparameterTuningJobRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CancelHyperparameterTuningJobRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateNasJobRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub nas_job: ::core::option::Option<NasJob>,
}
impl ::prost::Name for CreateNasJobRequest {
    const NAME: &'static str = "CreateNasJobRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateNasJobRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateNasJobRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNasJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for GetNasJobRequest {
    const NAME: &'static str = "GetNasJobRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetNasJobRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetNasJobRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNasJobsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for ListNasJobsRequest {
    const NAME: &'static str = "ListNasJobsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListNasJobsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListNasJobsRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNasJobsResponse {
    #[prost(message, repeated, tag = "1")]
    pub nas_jobs: ::prost::alloc::vec::Vec<NasJob>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListNasJobsResponse {
    const NAME: &'static str = "ListNasJobsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListNasJobsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListNasJobsResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteNasJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for DeleteNasJobRequest {
    const NAME: &'static str = "DeleteNasJobRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeleteNasJobRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteNasJobRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelNasJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for CancelNasJobRequest {
    const NAME: &'static str = "CancelNasJobRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CancelNasJobRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CancelNasJobRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNasTrialDetailRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for GetNasTrialDetailRequest {
    const NAME: &'static str = "GetNasTrialDetailRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetNasTrialDetailRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetNasTrialDetailRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNasTrialDetailsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListNasTrialDetailsRequest {
    const NAME: &'static str = "ListNasTrialDetailsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListNasTrialDetailsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListNasTrialDetailsRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNasTrialDetailsResponse {
    #[prost(message, repeated, tag = "1")]
    pub nas_trial_details: ::prost::alloc::vec::Vec<NasTrialDetail>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListNasTrialDetailsResponse {
    const NAME: &'static str = "ListNasTrialDetailsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListNasTrialDetailsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListNasTrialDetailsResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateBatchPredictionJobRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub batch_prediction_job: ::core::option::Option<BatchPredictionJob>,
}
impl ::prost::Name for CreateBatchPredictionJobRequest {
    const NAME: &'static str = "CreateBatchPredictionJobRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateBatchPredictionJobRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateBatchPredictionJobRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBatchPredictionJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for GetBatchPredictionJobRequest {
    const NAME: &'static str = "GetBatchPredictionJobRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetBatchPredictionJobRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetBatchPredictionJobRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBatchPredictionJobsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for ListBatchPredictionJobsRequest {
    const NAME: &'static str = "ListBatchPredictionJobsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListBatchPredictionJobsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListBatchPredictionJobsRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBatchPredictionJobsResponse {
    #[prost(message, repeated, tag = "1")]
    pub batch_prediction_jobs: ::prost::alloc::vec::Vec<BatchPredictionJob>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListBatchPredictionJobsResponse {
    const NAME: &'static str = "ListBatchPredictionJobsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListBatchPredictionJobsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListBatchPredictionJobsResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteBatchPredictionJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for DeleteBatchPredictionJobRequest {
    const NAME: &'static str = "DeleteBatchPredictionJobRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeleteBatchPredictionJobRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteBatchPredictionJobRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelBatchPredictionJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for CancelBatchPredictionJobRequest {
    const NAME: &'static str = "CancelBatchPredictionJobRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CancelBatchPredictionJobRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CancelBatchPredictionJobRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateModelDeploymentMonitoringJobRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub model_deployment_monitoring_job: ::core::option::Option<
        ModelDeploymentMonitoringJob,
    >,
}
impl ::prost::Name for CreateModelDeploymentMonitoringJobRequest {
    const NAME: &'static str = "CreateModelDeploymentMonitoringJobRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateModelDeploymentMonitoringJobRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateModelDeploymentMonitoringJobRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchModelDeploymentMonitoringStatsAnomaliesRequest {
    #[prost(string, tag = "1")]
    pub model_deployment_monitoring_job: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub deployed_model_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub feature_display_name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "4")]
    pub objectives: ::prost::alloc::vec::Vec<
        search_model_deployment_monitoring_stats_anomalies_request::StatsAnomaliesObjective,
    >,
    #[prost(int32, tag = "5")]
    pub page_size: i32,
    #[prost(string, tag = "6")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "7")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `SearchModelDeploymentMonitoringStatsAnomaliesRequest`.
pub mod search_model_deployment_monitoring_stats_anomalies_request {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct StatsAnomaliesObjective {
        #[prost(
            enumeration = "super::ModelDeploymentMonitoringObjectiveType",
            tag = "1"
        )]
        pub r#type: i32,
        #[prost(int32, tag = "4")]
        pub top_feature_count: i32,
    }
    impl ::prost::Name for StatsAnomaliesObjective {
        const NAME: &'static str = "StatsAnomaliesObjective";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.SearchModelDeploymentMonitoringStatsAnomaliesRequest.StatsAnomaliesObjective"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.SearchModelDeploymentMonitoringStatsAnomaliesRequest.StatsAnomaliesObjective"
                .into()
        }
    }
}
impl ::prost::Name for SearchModelDeploymentMonitoringStatsAnomaliesRequest {
    const NAME: &'static str = "SearchModelDeploymentMonitoringStatsAnomaliesRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SearchModelDeploymentMonitoringStatsAnomaliesRequest"
            .into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SearchModelDeploymentMonitoringStatsAnomaliesRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchModelDeploymentMonitoringStatsAnomaliesResponse {
    #[prost(message, repeated, tag = "1")]
    pub monitoring_stats: ::prost::alloc::vec::Vec<ModelMonitoringStatsAnomalies>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for SearchModelDeploymentMonitoringStatsAnomaliesResponse {
    const NAME: &'static str = "SearchModelDeploymentMonitoringStatsAnomaliesResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SearchModelDeploymentMonitoringStatsAnomaliesResponse"
            .into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SearchModelDeploymentMonitoringStatsAnomaliesResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetModelDeploymentMonitoringJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for GetModelDeploymentMonitoringJobRequest {
    const NAME: &'static str = "GetModelDeploymentMonitoringJobRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetModelDeploymentMonitoringJobRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetModelDeploymentMonitoringJobRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListModelDeploymentMonitoringJobsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for ListModelDeploymentMonitoringJobsRequest {
    const NAME: &'static str = "ListModelDeploymentMonitoringJobsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListModelDeploymentMonitoringJobsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListModelDeploymentMonitoringJobsRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListModelDeploymentMonitoringJobsResponse {
    #[prost(message, repeated, tag = "1")]
    pub model_deployment_monitoring_jobs: ::prost::alloc::vec::Vec<
        ModelDeploymentMonitoringJob,
    >,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListModelDeploymentMonitoringJobsResponse {
    const NAME: &'static str = "ListModelDeploymentMonitoringJobsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListModelDeploymentMonitoringJobsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListModelDeploymentMonitoringJobsResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateModelDeploymentMonitoringJobRequest {
    #[prost(message, optional, tag = "1")]
    pub model_deployment_monitoring_job: ::core::option::Option<
        ModelDeploymentMonitoringJob,
    >,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for UpdateModelDeploymentMonitoringJobRequest {
    const NAME: &'static str = "UpdateModelDeploymentMonitoringJobRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdateModelDeploymentMonitoringJobRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateModelDeploymentMonitoringJobRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteModelDeploymentMonitoringJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for DeleteModelDeploymentMonitoringJobRequest {
    const NAME: &'static str = "DeleteModelDeploymentMonitoringJobRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeleteModelDeploymentMonitoringJobRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteModelDeploymentMonitoringJobRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PauseModelDeploymentMonitoringJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for PauseModelDeploymentMonitoringJobRequest {
    const NAME: &'static str = "PauseModelDeploymentMonitoringJobRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.PauseModelDeploymentMonitoringJobRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.PauseModelDeploymentMonitoringJobRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResumeModelDeploymentMonitoringJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for ResumeModelDeploymentMonitoringJobRequest {
    const NAME: &'static str = "ResumeModelDeploymentMonitoringJobRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ResumeModelDeploymentMonitoringJobRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ResumeModelDeploymentMonitoringJobRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateModelDeploymentMonitoringJobOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for UpdateModelDeploymentMonitoringJobOperationMetadata {
    const NAME: &'static str = "UpdateModelDeploymentMonitoringJobOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdateModelDeploymentMonitoringJobOperationMetadata"
            .into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateModelDeploymentMonitoringJobOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LineageSubgraph {
    #[prost(message, repeated, tag = "1")]
    pub artifacts: ::prost::alloc::vec::Vec<Artifact>,
    #[prost(message, repeated, tag = "2")]
    pub executions: ::prost::alloc::vec::Vec<Execution>,
    #[prost(message, repeated, tag = "3")]
    pub events: ::prost::alloc::vec::Vec<Event>,
}
impl ::prost::Name for LineageSubgraph {
    const NAME: &'static str = "LineageSubgraph";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.LineageSubgraph".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.LineageSubgraph".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PredictRequest {
    #[prost(string, tag = "1")]
    pub endpoint: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub instances: ::prost::alloc::vec::Vec<::prost_types::Value>,
    #[prost(message, optional, tag = "3")]
    pub parameters: ::core::option::Option<::prost_types::Value>,
}
impl ::prost::Name for PredictRequest {
    const NAME: &'static str = "PredictRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.PredictRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.PredictRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PredictResponse {
    #[prost(message, repeated, tag = "1")]
    pub predictions: ::prost::alloc::vec::Vec<::prost_types::Value>,
    #[prost(string, tag = "2")]
    pub deployed_model_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub model: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub model_version_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub model_display_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub metadata: ::core::option::Option<::prost_types::Value>,
}
impl ::prost::Name for PredictResponse {
    const NAME: &'static str = "PredictResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.PredictResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.PredictResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RawPredictRequest {
    #[prost(string, tag = "1")]
    pub endpoint: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub http_body: ::core::option::Option<super::super::super::api::HttpBody>,
}
impl ::prost::Name for RawPredictRequest {
    const NAME: &'static str = "RawPredictRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.RawPredictRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.RawPredictRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamRawPredictRequest {
    #[prost(string, tag = "1")]
    pub endpoint: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub http_body: ::core::option::Option<super::super::super::api::HttpBody>,
}
impl ::prost::Name for StreamRawPredictRequest {
    const NAME: &'static str = "StreamRawPredictRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.StreamRawPredictRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.StreamRawPredictRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DirectPredictRequest {
    #[prost(string, tag = "1")]
    pub endpoint: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub inputs: ::prost::alloc::vec::Vec<Tensor>,
    #[prost(message, optional, tag = "3")]
    pub parameters: ::core::option::Option<Tensor>,
}
impl ::prost::Name for DirectPredictRequest {
    const NAME: &'static str = "DirectPredictRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DirectPredictRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DirectPredictRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DirectPredictResponse {
    #[prost(message, repeated, tag = "1")]
    pub outputs: ::prost::alloc::vec::Vec<Tensor>,
    #[prost(message, optional, tag = "2")]
    pub parameters: ::core::option::Option<Tensor>,
}
impl ::prost::Name for DirectPredictResponse {
    const NAME: &'static str = "DirectPredictResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DirectPredictResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DirectPredictResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DirectRawPredictRequest {
    #[prost(string, tag = "1")]
    pub endpoint: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub method_name: ::prost::alloc::string::String,
    #[prost(bytes = "bytes", tag = "3")]
    pub input: ::prost::bytes::Bytes,
}
impl ::prost::Name for DirectRawPredictRequest {
    const NAME: &'static str = "DirectRawPredictRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DirectRawPredictRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DirectRawPredictRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DirectRawPredictResponse {
    #[prost(bytes = "bytes", tag = "1")]
    pub output: ::prost::bytes::Bytes,
}
impl ::prost::Name for DirectRawPredictResponse {
    const NAME: &'static str = "DirectRawPredictResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DirectRawPredictResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DirectRawPredictResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamDirectPredictRequest {
    #[prost(string, tag = "1")]
    pub endpoint: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub inputs: ::prost::alloc::vec::Vec<Tensor>,
    #[prost(message, optional, tag = "3")]
    pub parameters: ::core::option::Option<Tensor>,
}
impl ::prost::Name for StreamDirectPredictRequest {
    const NAME: &'static str = "StreamDirectPredictRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.StreamDirectPredictRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.StreamDirectPredictRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamDirectPredictResponse {
    #[prost(message, repeated, tag = "1")]
    pub outputs: ::prost::alloc::vec::Vec<Tensor>,
    #[prost(message, optional, tag = "2")]
    pub parameters: ::core::option::Option<Tensor>,
}
impl ::prost::Name for StreamDirectPredictResponse {
    const NAME: &'static str = "StreamDirectPredictResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.StreamDirectPredictResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.StreamDirectPredictResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamDirectRawPredictRequest {
    #[prost(string, tag = "1")]
    pub endpoint: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub method_name: ::prost::alloc::string::String,
    #[prost(bytes = "bytes", tag = "3")]
    pub input: ::prost::bytes::Bytes,
}
impl ::prost::Name for StreamDirectRawPredictRequest {
    const NAME: &'static str = "StreamDirectRawPredictRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.StreamDirectRawPredictRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.StreamDirectRawPredictRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamDirectRawPredictResponse {
    #[prost(bytes = "bytes", tag = "1")]
    pub output: ::prost::bytes::Bytes,
}
impl ::prost::Name for StreamDirectRawPredictResponse {
    const NAME: &'static str = "StreamDirectRawPredictResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.StreamDirectRawPredictResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.StreamDirectRawPredictResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamingPredictRequest {
    #[prost(string, tag = "1")]
    pub endpoint: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub inputs: ::prost::alloc::vec::Vec<Tensor>,
    #[prost(message, optional, tag = "3")]
    pub parameters: ::core::option::Option<Tensor>,
}
impl ::prost::Name for StreamingPredictRequest {
    const NAME: &'static str = "StreamingPredictRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.StreamingPredictRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.StreamingPredictRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamingPredictResponse {
    #[prost(message, repeated, tag = "1")]
    pub outputs: ::prost::alloc::vec::Vec<Tensor>,
    #[prost(message, optional, tag = "2")]
    pub parameters: ::core::option::Option<Tensor>,
}
impl ::prost::Name for StreamingPredictResponse {
    const NAME: &'static str = "StreamingPredictResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.StreamingPredictResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.StreamingPredictResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamingRawPredictRequest {
    #[prost(string, tag = "1")]
    pub endpoint: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub method_name: ::prost::alloc::string::String,
    #[prost(bytes = "bytes", tag = "3")]
    pub input: ::prost::bytes::Bytes,
}
impl ::prost::Name for StreamingRawPredictRequest {
    const NAME: &'static str = "StreamingRawPredictRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.StreamingRawPredictRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.StreamingRawPredictRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamingRawPredictResponse {
    #[prost(bytes = "bytes", tag = "1")]
    pub output: ::prost::bytes::Bytes,
}
impl ::prost::Name for StreamingRawPredictResponse {
    const NAME: &'static str = "StreamingRawPredictResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.StreamingRawPredictResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.StreamingRawPredictResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExplainRequest {
    #[prost(string, tag = "1")]
    pub endpoint: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub instances: ::prost::alloc::vec::Vec<::prost_types::Value>,
    #[prost(message, optional, tag = "4")]
    pub parameters: ::core::option::Option<::prost_types::Value>,
    #[prost(message, optional, tag = "5")]
    pub explanation_spec_override: ::core::option::Option<ExplanationSpecOverride>,
    #[prost(string, tag = "3")]
    pub deployed_model_id: ::prost::alloc::string::String,
}
impl ::prost::Name for ExplainRequest {
    const NAME: &'static str = "ExplainRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ExplainRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExplainRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExplainResponse {
    #[prost(message, repeated, tag = "1")]
    pub explanations: ::prost::alloc::vec::Vec<Explanation>,
    #[prost(string, tag = "2")]
    pub deployed_model_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub predictions: ::prost::alloc::vec::Vec<::prost_types::Value>,
}
impl ::prost::Name for ExplainResponse {
    const NAME: &'static str = "ExplainResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ExplainResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExplainResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CountTokensRequest {
    #[prost(string, tag = "1")]
    pub endpoint: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub model: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub instances: ::prost::alloc::vec::Vec<::prost_types::Value>,
    #[prost(message, repeated, tag = "4")]
    pub contents: ::prost::alloc::vec::Vec<Content>,
    #[prost(message, optional, tag = "5")]
    pub system_instruction: ::core::option::Option<Content>,
    #[prost(message, repeated, tag = "6")]
    pub tools: ::prost::alloc::vec::Vec<Tool>,
    #[prost(message, optional, tag = "7")]
    pub generation_config: ::core::option::Option<GenerationConfig>,
}
impl ::prost::Name for CountTokensRequest {
    const NAME: &'static str = "CountTokensRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CountTokensRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CountTokensRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CountTokensResponse {
    #[prost(int32, tag = "1")]
    pub total_tokens: i32,
    #[prost(int32, tag = "2")]
    pub total_billable_characters: i32,
    #[prost(message, repeated, tag = "3")]
    pub prompt_tokens_details: ::prost::alloc::vec::Vec<ModalityTokenCount>,
}
impl ::prost::Name for CountTokensResponse {
    const NAME: &'static str = "CountTokensResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CountTokensResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CountTokensResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateContentRequest {
    #[prost(string, tag = "5")]
    pub model: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub contents: ::prost::alloc::vec::Vec<Content>,
    #[prost(message, optional, tag = "8")]
    pub system_instruction: ::core::option::Option<Content>,
    #[prost(string, tag = "9")]
    pub cached_content: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "6")]
    pub tools: ::prost::alloc::vec::Vec<Tool>,
    #[prost(message, optional, tag = "7")]
    pub tool_config: ::core::option::Option<ToolConfig>,
    #[prost(map = "string, string", tag = "10")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, repeated, tag = "3")]
    pub safety_settings: ::prost::alloc::vec::Vec<SafetySetting>,
    #[prost(message, optional, tag = "11")]
    pub model_armor_config: ::core::option::Option<ModelArmorConfig>,
    #[prost(message, optional, tag = "4")]
    pub generation_config: ::core::option::Option<GenerationConfig>,
}
impl ::prost::Name for GenerateContentRequest {
    const NAME: &'static str = "GenerateContentRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GenerateContentRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GenerateContentRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateContentResponse {
    #[prost(message, repeated, tag = "2")]
    pub candidates: ::prost::alloc::vec::Vec<Candidate>,
    #[prost(string, tag = "11")]
    pub model_version: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "12")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "13")]
    pub response_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub prompt_feedback: ::core::option::Option<
        generate_content_response::PromptFeedback,
    >,
    #[prost(message, optional, tag = "4")]
    pub usage_metadata: ::core::option::Option<generate_content_response::UsageMetadata>,
}
/// Nested message and enum types in `GenerateContentResponse`.
pub mod generate_content_response {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PromptFeedback {
        #[prost(enumeration = "prompt_feedback::BlockedReason", tag = "1")]
        pub block_reason: i32,
        #[prost(message, repeated, tag = "2")]
        pub safety_ratings: ::prost::alloc::vec::Vec<super::SafetyRating>,
        #[prost(string, tag = "3")]
        pub block_reason_message: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `PromptFeedback`.
    pub mod prompt_feedback {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum BlockedReason {
            Unspecified = 0,
            Safety = 1,
            Other = 2,
            Blocklist = 3,
            ProhibitedContent = 4,
            ModelArmor = 5,
        }
        impl BlockedReason {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "BLOCKED_REASON_UNSPECIFIED",
                    Self::Safety => "SAFETY",
                    Self::Other => "OTHER",
                    Self::Blocklist => "BLOCKLIST",
                    Self::ProhibitedContent => "PROHIBITED_CONTENT",
                    Self::ModelArmor => "MODEL_ARMOR",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "BLOCKED_REASON_UNSPECIFIED" => Some(Self::Unspecified),
                    "SAFETY" => Some(Self::Safety),
                    "OTHER" => Some(Self::Other),
                    "BLOCKLIST" => Some(Self::Blocklist),
                    "PROHIBITED_CONTENT" => Some(Self::ProhibitedContent),
                    "MODEL_ARMOR" => Some(Self::ModelArmor),
                    _ => None,
                }
            }
        }
    }
    impl ::prost::Name for PromptFeedback {
        const NAME: &'static str = "PromptFeedback";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.GenerateContentResponse.PromptFeedback".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.GenerateContentResponse.PromptFeedback"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UsageMetadata {
        #[prost(int32, tag = "1")]
        pub prompt_token_count: i32,
        #[prost(int32, tag = "2")]
        pub candidates_token_count: i32,
        #[prost(int32, tag = "14")]
        pub thoughts_token_count: i32,
        #[prost(int32, tag = "3")]
        pub total_token_count: i32,
        #[prost(int32, tag = "5")]
        pub cached_content_token_count: i32,
        #[prost(message, repeated, tag = "9")]
        pub prompt_tokens_details: ::prost::alloc::vec::Vec<super::ModalityTokenCount>,
        #[prost(message, repeated, tag = "10")]
        pub cache_tokens_details: ::prost::alloc::vec::Vec<super::ModalityTokenCount>,
        #[prost(message, repeated, tag = "11")]
        pub candidates_tokens_details: ::prost::alloc::vec::Vec<
            super::ModalityTokenCount,
        >,
    }
    impl ::prost::Name for UsageMetadata {
        const NAME: &'static str = "UsageMetadata";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.GenerateContentResponse.UsageMetadata".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.GenerateContentResponse.UsageMetadata"
                .into()
        }
    }
}
impl ::prost::Name for GenerateContentResponse {
    const NAME: &'static str = "GenerateContentResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GenerateContentResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GenerateContentResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComputeTokensRequest {
    #[prost(string, tag = "1")]
    pub endpoint: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub instances: ::prost::alloc::vec::Vec<::prost_types::Value>,
    #[prost(string, tag = "3")]
    pub model: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "4")]
    pub contents: ::prost::alloc::vec::Vec<Content>,
}
impl ::prost::Name for ComputeTokensRequest {
    const NAME: &'static str = "ComputeTokensRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ComputeTokensRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ComputeTokensRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TokensInfo {
    #[prost(bytes = "bytes", repeated, tag = "1")]
    pub tokens: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
    #[prost(int64, repeated, tag = "2")]
    pub token_ids: ::prost::alloc::vec::Vec<i64>,
    #[prost(string, tag = "3")]
    pub role: ::prost::alloc::string::String,
}
impl ::prost::Name for TokensInfo {
    const NAME: &'static str = "TokensInfo";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.TokensInfo".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.TokensInfo".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComputeTokensResponse {
    #[prost(message, repeated, tag = "1")]
    pub tokens_info: ::prost::alloc::vec::Vec<TokensInfo>,
}
impl ::prost::Name for ComputeTokensResponse {
    const NAME: &'static str = "ComputeTokensResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ComputeTokensResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ComputeTokensResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindNeighborsRequest {
    #[prost(string, tag = "1")]
    pub index_endpoint: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub deployed_index_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub queries: ::prost::alloc::vec::Vec<find_neighbors_request::Query>,
    #[prost(bool, tag = "4")]
    pub return_full_datapoint: bool,
}
/// Nested message and enum types in `FindNeighborsRequest`.
pub mod find_neighbors_request {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Query {
        #[prost(message, optional, tag = "1")]
        pub datapoint: ::core::option::Option<super::IndexDatapoint>,
        #[prost(int32, tag = "2")]
        pub neighbor_count: i32,
        #[prost(int32, tag = "3")]
        pub per_crowding_attribute_neighbor_count: i32,
        #[prost(int32, tag = "4")]
        pub approximate_neighbor_count: i32,
        #[prost(double, tag = "5")]
        pub fraction_leaf_nodes_to_search_override: f64,
        #[prost(oneof = "query::Ranking", tags = "6")]
        pub ranking: ::core::option::Option<query::Ranking>,
    }
    /// Nested message and enum types in `Query`.
    pub mod query {
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Rrf {
            #[prost(float, tag = "1")]
            pub alpha: f32,
        }
        impl ::prost::Name for Rrf {
            const NAME: &'static str = "RRF";
            const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "google.cloud.aiplatform.v1.FindNeighborsRequest.Query.RRF".into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.cloud.aiplatform.v1.FindNeighborsRequest.Query.RRF"
                    .into()
            }
        }
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum Ranking {
            #[prost(message, tag = "6")]
            Rrf(Rrf),
        }
    }
    impl ::prost::Name for Query {
        const NAME: &'static str = "Query";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.FindNeighborsRequest.Query".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.FindNeighborsRequest.Query"
                .into()
        }
    }
}
impl ::prost::Name for FindNeighborsRequest {
    const NAME: &'static str = "FindNeighborsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.FindNeighborsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.FindNeighborsRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FindNeighborsResponse {
    #[prost(message, repeated, tag = "1")]
    pub nearest_neighbors: ::prost::alloc::vec::Vec<
        find_neighbors_response::NearestNeighbors,
    >,
}
/// Nested message and enum types in `FindNeighborsResponse`.
pub mod find_neighbors_response {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Neighbor {
        #[prost(message, optional, tag = "1")]
        pub datapoint: ::core::option::Option<super::IndexDatapoint>,
        #[prost(double, tag = "2")]
        pub distance: f64,
        #[prost(double, tag = "3")]
        pub sparse_distance: f64,
    }
    impl ::prost::Name for Neighbor {
        const NAME: &'static str = "Neighbor";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.FindNeighborsResponse.Neighbor".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.FindNeighborsResponse.Neighbor"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NearestNeighbors {
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "2")]
        pub neighbors: ::prost::alloc::vec::Vec<Neighbor>,
    }
    impl ::prost::Name for NearestNeighbors {
        const NAME: &'static str = "NearestNeighbors";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.FindNeighborsResponse.NearestNeighbors".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.FindNeighborsResponse.NearestNeighbors"
                .into()
        }
    }
}
impl ::prost::Name for FindNeighborsResponse {
    const NAME: &'static str = "FindNeighborsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.FindNeighborsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.FindNeighborsResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadIndexDatapointsRequest {
    #[prost(string, tag = "1")]
    pub index_endpoint: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub deployed_index_id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for ReadIndexDatapointsRequest {
    const NAME: &'static str = "ReadIndexDatapointsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ReadIndexDatapointsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ReadIndexDatapointsRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadIndexDatapointsResponse {
    #[prost(message, repeated, tag = "1")]
    pub datapoints: ::prost::alloc::vec::Vec<IndexDatapoint>,
}
impl ::prost::Name for ReadIndexDatapointsResponse {
    const NAME: &'static str = "ReadIndexDatapointsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ReadIndexDatapointsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ReadIndexDatapointsResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataSchema {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub schema_version: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub schema: ::prost::alloc::string::String,
    #[prost(enumeration = "metadata_schema::MetadataSchemaType", tag = "4")]
    pub schema_type: i32,
    #[prost(message, optional, tag = "5")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "6")]
    pub description: ::prost::alloc::string::String,
}
/// Nested message and enum types in `MetadataSchema`.
pub mod metadata_schema {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MetadataSchemaType {
        Unspecified = 0,
        ArtifactType = 1,
        ExecutionType = 2,
        ContextType = 3,
    }
    impl MetadataSchemaType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "METADATA_SCHEMA_TYPE_UNSPECIFIED",
                Self::ArtifactType => "ARTIFACT_TYPE",
                Self::ExecutionType => "EXECUTION_TYPE",
                Self::ContextType => "CONTEXT_TYPE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "METADATA_SCHEMA_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "ARTIFACT_TYPE" => Some(Self::ArtifactType),
                "EXECUTION_TYPE" => Some(Self::ExecutionType),
                "CONTEXT_TYPE" => Some(Self::ContextType),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for MetadataSchema {
    const NAME: &'static str = "MetadataSchema";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.MetadataSchema".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.MetadataSchema".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataStore {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "5")]
    pub encryption_spec: ::core::option::Option<EncryptionSpec>,
    #[prost(string, tag = "6")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "7")]
    pub state: ::core::option::Option<metadata_store::MetadataStoreState>,
    #[prost(message, optional, tag = "8")]
    pub dataplex_config: ::core::option::Option<metadata_store::DataplexConfig>,
}
/// Nested message and enum types in `MetadataStore`.
pub mod metadata_store {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct MetadataStoreState {
        #[prost(int64, tag = "1")]
        pub disk_utilization_bytes: i64,
    }
    impl ::prost::Name for MetadataStoreState {
        const NAME: &'static str = "MetadataStoreState";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.MetadataStore.MetadataStoreState".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.MetadataStore.MetadataStoreState"
                .into()
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DataplexConfig {
        #[prost(bool, tag = "1")]
        pub enabled_pipelines_lineage: bool,
    }
    impl ::prost::Name for DataplexConfig {
        const NAME: &'static str = "DataplexConfig";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.MetadataStore.DataplexConfig".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.MetadataStore.DataplexConfig"
                .into()
        }
    }
}
impl ::prost::Name for MetadataStore {
    const NAME: &'static str = "MetadataStore";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.MetadataStore".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.MetadataStore".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateMetadataStoreRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub metadata_store: ::core::option::Option<MetadataStore>,
    #[prost(string, tag = "3")]
    pub metadata_store_id: ::prost::alloc::string::String,
}
impl ::prost::Name for CreateMetadataStoreRequest {
    const NAME: &'static str = "CreateMetadataStoreRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateMetadataStoreRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateMetadataStoreRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateMetadataStoreOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for CreateMetadataStoreOperationMetadata {
    const NAME: &'static str = "CreateMetadataStoreOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateMetadataStoreOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateMetadataStoreOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMetadataStoreRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for GetMetadataStoreRequest {
    const NAME: &'static str = "GetMetadataStoreRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetMetadataStoreRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetMetadataStoreRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMetadataStoresRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListMetadataStoresRequest {
    const NAME: &'static str = "ListMetadataStoresRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListMetadataStoresRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListMetadataStoresRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMetadataStoresResponse {
    #[prost(message, repeated, tag = "1")]
    pub metadata_stores: ::prost::alloc::vec::Vec<MetadataStore>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListMetadataStoresResponse {
    const NAME: &'static str = "ListMetadataStoresResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListMetadataStoresResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListMetadataStoresResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteMetadataStoreRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[deprecated]
    #[prost(bool, tag = "2")]
    pub force: bool,
}
impl ::prost::Name for DeleteMetadataStoreRequest {
    const NAME: &'static str = "DeleteMetadataStoreRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeleteMetadataStoreRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteMetadataStoreRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteMetadataStoreOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for DeleteMetadataStoreOperationMetadata {
    const NAME: &'static str = "DeleteMetadataStoreOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeleteMetadataStoreOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteMetadataStoreOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateArtifactRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub artifact: ::core::option::Option<Artifact>,
    #[prost(string, tag = "3")]
    pub artifact_id: ::prost::alloc::string::String,
}
impl ::prost::Name for CreateArtifactRequest {
    const NAME: &'static str = "CreateArtifactRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateArtifactRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateArtifactRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetArtifactRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for GetArtifactRequest {
    const NAME: &'static str = "GetArtifactRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetArtifactRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetArtifactRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListArtifactsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
impl ::prost::Name for ListArtifactsRequest {
    const NAME: &'static str = "ListArtifactsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListArtifactsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListArtifactsRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListArtifactsResponse {
    #[prost(message, repeated, tag = "1")]
    pub artifacts: ::prost::alloc::vec::Vec<Artifact>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListArtifactsResponse {
    const NAME: &'static str = "ListArtifactsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListArtifactsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListArtifactsResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateArtifactRequest {
    #[prost(message, optional, tag = "1")]
    pub artifact: ::core::option::Option<Artifact>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(bool, tag = "3")]
    pub allow_missing: bool,
}
impl ::prost::Name for UpdateArtifactRequest {
    const NAME: &'static str = "UpdateArtifactRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdateArtifactRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateArtifactRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteArtifactRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub etag: ::prost::alloc::string::String,
}
impl ::prost::Name for DeleteArtifactRequest {
    const NAME: &'static str = "DeleteArtifactRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeleteArtifactRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteArtifactRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurgeArtifactsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub force: bool,
}
impl ::prost::Name for PurgeArtifactsRequest {
    const NAME: &'static str = "PurgeArtifactsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.PurgeArtifactsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.PurgeArtifactsRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurgeArtifactsResponse {
    #[prost(int64, tag = "1")]
    pub purge_count: i64,
    #[prost(string, repeated, tag = "2")]
    pub purge_sample: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for PurgeArtifactsResponse {
    const NAME: &'static str = "PurgeArtifactsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.PurgeArtifactsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.PurgeArtifactsResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurgeArtifactsMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for PurgeArtifactsMetadata {
    const NAME: &'static str = "PurgeArtifactsMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.PurgeArtifactsMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.PurgeArtifactsMetadata".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateContextRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub context: ::core::option::Option<Context>,
    #[prost(string, tag = "3")]
    pub context_id: ::prost::alloc::string::String,
}
impl ::prost::Name for CreateContextRequest {
    const NAME: &'static str = "CreateContextRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateContextRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateContextRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetContextRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for GetContextRequest {
    const NAME: &'static str = "GetContextRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetContextRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetContextRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListContextsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
impl ::prost::Name for ListContextsRequest {
    const NAME: &'static str = "ListContextsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListContextsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListContextsRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListContextsResponse {
    #[prost(message, repeated, tag = "1")]
    pub contexts: ::prost::alloc::vec::Vec<Context>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListContextsResponse {
    const NAME: &'static str = "ListContextsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListContextsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListContextsResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateContextRequest {
    #[prost(message, optional, tag = "1")]
    pub context: ::core::option::Option<Context>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(bool, tag = "3")]
    pub allow_missing: bool,
}
impl ::prost::Name for UpdateContextRequest {
    const NAME: &'static str = "UpdateContextRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdateContextRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateContextRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteContextRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub force: bool,
    #[prost(string, tag = "3")]
    pub etag: ::prost::alloc::string::String,
}
impl ::prost::Name for DeleteContextRequest {
    const NAME: &'static str = "DeleteContextRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeleteContextRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteContextRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurgeContextsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub force: bool,
}
impl ::prost::Name for PurgeContextsRequest {
    const NAME: &'static str = "PurgeContextsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.PurgeContextsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.PurgeContextsRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurgeContextsResponse {
    #[prost(int64, tag = "1")]
    pub purge_count: i64,
    #[prost(string, repeated, tag = "2")]
    pub purge_sample: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for PurgeContextsResponse {
    const NAME: &'static str = "PurgeContextsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.PurgeContextsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.PurgeContextsResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurgeContextsMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for PurgeContextsMetadata {
    const NAME: &'static str = "PurgeContextsMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.PurgeContextsMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.PurgeContextsMetadata".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddContextArtifactsAndExecutionsRequest {
    #[prost(string, tag = "1")]
    pub context: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub artifacts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "3")]
    pub executions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for AddContextArtifactsAndExecutionsRequest {
    const NAME: &'static str = "AddContextArtifactsAndExecutionsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.AddContextArtifactsAndExecutionsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.AddContextArtifactsAndExecutionsRequest"
            .into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AddContextArtifactsAndExecutionsResponse {}
impl ::prost::Name for AddContextArtifactsAndExecutionsResponse {
    const NAME: &'static str = "AddContextArtifactsAndExecutionsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.AddContextArtifactsAndExecutionsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.AddContextArtifactsAndExecutionsResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddContextChildrenRequest {
    #[prost(string, tag = "1")]
    pub context: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub child_contexts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for AddContextChildrenRequest {
    const NAME: &'static str = "AddContextChildrenRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.AddContextChildrenRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.AddContextChildrenRequest".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AddContextChildrenResponse {}
impl ::prost::Name for AddContextChildrenResponse {
    const NAME: &'static str = "AddContextChildrenResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.AddContextChildrenResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.AddContextChildrenResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveContextChildrenRequest {
    #[prost(string, tag = "1")]
    pub context: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub child_contexts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for RemoveContextChildrenRequest {
    const NAME: &'static str = "RemoveContextChildrenRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.RemoveContextChildrenRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.RemoveContextChildrenRequest"
            .into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RemoveContextChildrenResponse {}
impl ::prost::Name for RemoveContextChildrenResponse {
    const NAME: &'static str = "RemoveContextChildrenResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.RemoveContextChildrenResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.RemoveContextChildrenResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryContextLineageSubgraphRequest {
    #[prost(string, tag = "1")]
    pub context: ::prost::alloc::string::String,
}
impl ::prost::Name for QueryContextLineageSubgraphRequest {
    const NAME: &'static str = "QueryContextLineageSubgraphRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.QueryContextLineageSubgraphRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.QueryContextLineageSubgraphRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateExecutionRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub execution: ::core::option::Option<Execution>,
    #[prost(string, tag = "3")]
    pub execution_id: ::prost::alloc::string::String,
}
impl ::prost::Name for CreateExecutionRequest {
    const NAME: &'static str = "CreateExecutionRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateExecutionRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateExecutionRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetExecutionRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for GetExecutionRequest {
    const NAME: &'static str = "GetExecutionRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetExecutionRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetExecutionRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListExecutionsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
impl ::prost::Name for ListExecutionsRequest {
    const NAME: &'static str = "ListExecutionsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListExecutionsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListExecutionsRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListExecutionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub executions: ::prost::alloc::vec::Vec<Execution>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListExecutionsResponse {
    const NAME: &'static str = "ListExecutionsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListExecutionsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListExecutionsResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateExecutionRequest {
    #[prost(message, optional, tag = "1")]
    pub execution: ::core::option::Option<Execution>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(bool, tag = "3")]
    pub allow_missing: bool,
}
impl ::prost::Name for UpdateExecutionRequest {
    const NAME: &'static str = "UpdateExecutionRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdateExecutionRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateExecutionRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteExecutionRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub etag: ::prost::alloc::string::String,
}
impl ::prost::Name for DeleteExecutionRequest {
    const NAME: &'static str = "DeleteExecutionRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeleteExecutionRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteExecutionRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurgeExecutionsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub force: bool,
}
impl ::prost::Name for PurgeExecutionsRequest {
    const NAME: &'static str = "PurgeExecutionsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.PurgeExecutionsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.PurgeExecutionsRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurgeExecutionsResponse {
    #[prost(int64, tag = "1")]
    pub purge_count: i64,
    #[prost(string, repeated, tag = "2")]
    pub purge_sample: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for PurgeExecutionsResponse {
    const NAME: &'static str = "PurgeExecutionsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.PurgeExecutionsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.PurgeExecutionsResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurgeExecutionsMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for PurgeExecutionsMetadata {
    const NAME: &'static str = "PurgeExecutionsMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.PurgeExecutionsMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.PurgeExecutionsMetadata".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddExecutionEventsRequest {
    #[prost(string, tag = "1")]
    pub execution: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub events: ::prost::alloc::vec::Vec<Event>,
}
impl ::prost::Name for AddExecutionEventsRequest {
    const NAME: &'static str = "AddExecutionEventsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.AddExecutionEventsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.AddExecutionEventsRequest".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AddExecutionEventsResponse {}
impl ::prost::Name for AddExecutionEventsResponse {
    const NAME: &'static str = "AddExecutionEventsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.AddExecutionEventsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.AddExecutionEventsResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryExecutionInputsAndOutputsRequest {
    #[prost(string, tag = "1")]
    pub execution: ::prost::alloc::string::String,
}
impl ::prost::Name for QueryExecutionInputsAndOutputsRequest {
    const NAME: &'static str = "QueryExecutionInputsAndOutputsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.QueryExecutionInputsAndOutputsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.QueryExecutionInputsAndOutputsRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateMetadataSchemaRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub metadata_schema: ::core::option::Option<MetadataSchema>,
    #[prost(string, tag = "3")]
    pub metadata_schema_id: ::prost::alloc::string::String,
}
impl ::prost::Name for CreateMetadataSchemaRequest {
    const NAME: &'static str = "CreateMetadataSchemaRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateMetadataSchemaRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateMetadataSchemaRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMetadataSchemaRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for GetMetadataSchemaRequest {
    const NAME: &'static str = "GetMetadataSchemaRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetMetadataSchemaRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetMetadataSchemaRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMetadataSchemasRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
impl ::prost::Name for ListMetadataSchemasRequest {
    const NAME: &'static str = "ListMetadataSchemasRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListMetadataSchemasRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListMetadataSchemasRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMetadataSchemasResponse {
    #[prost(message, repeated, tag = "1")]
    pub metadata_schemas: ::prost::alloc::vec::Vec<MetadataSchema>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListMetadataSchemasResponse {
    const NAME: &'static str = "ListMetadataSchemasResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListMetadataSchemasResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListMetadataSchemasResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryArtifactLineageSubgraphRequest {
    #[prost(string, tag = "1")]
    pub artifact: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub max_hops: i32,
    #[prost(string, tag = "3")]
    pub filter: ::prost::alloc::string::String,
}
impl ::prost::Name for QueryArtifactLineageSubgraphRequest {
    const NAME: &'static str = "QueryArtifactLineageSubgraphRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.QueryArtifactLineageSubgraphRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.QueryArtifactLineageSubgraphRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MigratableResource {
    #[prost(message, optional, tag = "5")]
    pub last_migrate_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub last_update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(oneof = "migratable_resource::Resource", tags = "1, 2, 3, 4")]
    pub resource: ::core::option::Option<migratable_resource::Resource>,
}
/// Nested message and enum types in `MigratableResource`.
pub mod migratable_resource {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MlEngineModelVersion {
        #[prost(string, tag = "1")]
        pub endpoint: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub version: ::prost::alloc::string::String,
    }
    impl ::prost::Name for MlEngineModelVersion {
        const NAME: &'static str = "MlEngineModelVersion";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.MigratableResource.MlEngineModelVersion".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.MigratableResource.MlEngineModelVersion"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AutomlModel {
        #[prost(string, tag = "1")]
        pub model: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub model_display_name: ::prost::alloc::string::String,
    }
    impl ::prost::Name for AutomlModel {
        const NAME: &'static str = "AutomlModel";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.MigratableResource.AutomlModel".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.MigratableResource.AutomlModel"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AutomlDataset {
        #[prost(string, tag = "1")]
        pub dataset: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub dataset_display_name: ::prost::alloc::string::String,
    }
    impl ::prost::Name for AutomlDataset {
        const NAME: &'static str = "AutomlDataset";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.MigratableResource.AutomlDataset".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.MigratableResource.AutomlDataset"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DataLabelingDataset {
        #[prost(string, tag = "1")]
        pub dataset: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub dataset_display_name: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "3")]
        pub data_labeling_annotated_datasets: ::prost::alloc::vec::Vec<
            data_labeling_dataset::DataLabelingAnnotatedDataset,
        >,
    }
    /// Nested message and enum types in `DataLabelingDataset`.
    pub mod data_labeling_dataset {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct DataLabelingAnnotatedDataset {
            #[prost(string, tag = "1")]
            pub annotated_dataset: ::prost::alloc::string::String,
            #[prost(string, tag = "3")]
            pub annotated_dataset_display_name: ::prost::alloc::string::String,
        }
        impl ::prost::Name for DataLabelingAnnotatedDataset {
            const NAME: &'static str = "DataLabelingAnnotatedDataset";
            const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "google.cloud.aiplatform.v1.MigratableResource.DataLabelingDataset.DataLabelingAnnotatedDataset"
                    .into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.cloud.aiplatform.v1.MigratableResource.DataLabelingDataset.DataLabelingAnnotatedDataset"
                    .into()
            }
        }
    }
    impl ::prost::Name for DataLabelingDataset {
        const NAME: &'static str = "DataLabelingDataset";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.MigratableResource.DataLabelingDataset".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.MigratableResource.DataLabelingDataset"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Resource {
        #[prost(message, tag = "1")]
        MlEngineModelVersion(MlEngineModelVersion),
        #[prost(message, tag = "2")]
        AutomlModel(AutomlModel),
        #[prost(message, tag = "3")]
        AutomlDataset(AutomlDataset),
        #[prost(message, tag = "4")]
        DataLabelingDataset(DataLabelingDataset),
    }
}
impl ::prost::Name for MigratableResource {
    const NAME: &'static str = "MigratableResource";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.MigratableResource".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.MigratableResource".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchMigratableResourcesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
impl ::prost::Name for SearchMigratableResourcesRequest {
    const NAME: &'static str = "SearchMigratableResourcesRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SearchMigratableResourcesRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SearchMigratableResourcesRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchMigratableResourcesResponse {
    #[prost(message, repeated, tag = "1")]
    pub migratable_resources: ::prost::alloc::vec::Vec<MigratableResource>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for SearchMigratableResourcesResponse {
    const NAME: &'static str = "SearchMigratableResourcesResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SearchMigratableResourcesResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SearchMigratableResourcesResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchMigrateResourcesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub migrate_resource_requests: ::prost::alloc::vec::Vec<MigrateResourceRequest>,
}
impl ::prost::Name for BatchMigrateResourcesRequest {
    const NAME: &'static str = "BatchMigrateResourcesRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.BatchMigrateResourcesRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchMigrateResourcesRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MigrateResourceRequest {
    #[prost(oneof = "migrate_resource_request::Request", tags = "1, 2, 3, 4")]
    pub request: ::core::option::Option<migrate_resource_request::Request>,
}
/// Nested message and enum types in `MigrateResourceRequest`.
pub mod migrate_resource_request {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MigrateMlEngineModelVersionConfig {
        #[prost(string, tag = "1")]
        pub endpoint: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub model_version: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub model_display_name: ::prost::alloc::string::String,
    }
    impl ::prost::Name for MigrateMlEngineModelVersionConfig {
        const NAME: &'static str = "MigrateMlEngineModelVersionConfig";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.MigrateResourceRequest.MigrateMlEngineModelVersionConfig"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.MigrateResourceRequest.MigrateMlEngineModelVersionConfig"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MigrateAutomlModelConfig {
        #[prost(string, tag = "1")]
        pub model: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub model_display_name: ::prost::alloc::string::String,
    }
    impl ::prost::Name for MigrateAutomlModelConfig {
        const NAME: &'static str = "MigrateAutomlModelConfig";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.MigrateResourceRequest.MigrateAutomlModelConfig"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.MigrateResourceRequest.MigrateAutomlModelConfig"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MigrateAutomlDatasetConfig {
        #[prost(string, tag = "1")]
        pub dataset: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub dataset_display_name: ::prost::alloc::string::String,
    }
    impl ::prost::Name for MigrateAutomlDatasetConfig {
        const NAME: &'static str = "MigrateAutomlDatasetConfig";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.MigrateResourceRequest.MigrateAutomlDatasetConfig"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.MigrateResourceRequest.MigrateAutomlDatasetConfig"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MigrateDataLabelingDatasetConfig {
        #[prost(string, tag = "1")]
        pub dataset: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub dataset_display_name: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "3")]
        pub migrate_data_labeling_annotated_dataset_configs: ::prost::alloc::vec::Vec<
            migrate_data_labeling_dataset_config::MigrateDataLabelingAnnotatedDatasetConfig,
        >,
    }
    /// Nested message and enum types in `MigrateDataLabelingDatasetConfig`.
    pub mod migrate_data_labeling_dataset_config {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct MigrateDataLabelingAnnotatedDatasetConfig {
            #[prost(string, tag = "1")]
            pub annotated_dataset: ::prost::alloc::string::String,
        }
        impl ::prost::Name for MigrateDataLabelingAnnotatedDatasetConfig {
            const NAME: &'static str = "MigrateDataLabelingAnnotatedDatasetConfig";
            const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "google.cloud.aiplatform.v1.MigrateResourceRequest.MigrateDataLabelingDatasetConfig.MigrateDataLabelingAnnotatedDatasetConfig"
                    .into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.cloud.aiplatform.v1.MigrateResourceRequest.MigrateDataLabelingDatasetConfig.MigrateDataLabelingAnnotatedDatasetConfig"
                    .into()
            }
        }
    }
    impl ::prost::Name for MigrateDataLabelingDatasetConfig {
        const NAME: &'static str = "MigrateDataLabelingDatasetConfig";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.MigrateResourceRequest.MigrateDataLabelingDatasetConfig"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.MigrateResourceRequest.MigrateDataLabelingDatasetConfig"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Request {
        #[prost(message, tag = "1")]
        MigrateMlEngineModelVersionConfig(MigrateMlEngineModelVersionConfig),
        #[prost(message, tag = "2")]
        MigrateAutomlModelConfig(MigrateAutomlModelConfig),
        #[prost(message, tag = "3")]
        MigrateAutomlDatasetConfig(MigrateAutomlDatasetConfig),
        #[prost(message, tag = "4")]
        MigrateDataLabelingDatasetConfig(MigrateDataLabelingDatasetConfig),
    }
}
impl ::prost::Name for MigrateResourceRequest {
    const NAME: &'static str = "MigrateResourceRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.MigrateResourceRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.MigrateResourceRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchMigrateResourcesResponse {
    #[prost(message, repeated, tag = "1")]
    pub migrate_resource_responses: ::prost::alloc::vec::Vec<MigrateResourceResponse>,
}
impl ::prost::Name for BatchMigrateResourcesResponse {
    const NAME: &'static str = "BatchMigrateResourcesResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.BatchMigrateResourcesResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchMigrateResourcesResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MigrateResourceResponse {
    #[prost(message, optional, tag = "3")]
    pub migratable_resource: ::core::option::Option<MigratableResource>,
    #[prost(oneof = "migrate_resource_response::MigratedResource", tags = "1, 2")]
    pub migrated_resource: ::core::option::Option<
        migrate_resource_response::MigratedResource,
    >,
}
/// Nested message and enum types in `MigrateResourceResponse`.
pub mod migrate_resource_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum MigratedResource {
        #[prost(string, tag = "1")]
        Dataset(::prost::alloc::string::String),
        #[prost(string, tag = "2")]
        Model(::prost::alloc::string::String),
    }
}
impl ::prost::Name for MigrateResourceResponse {
    const NAME: &'static str = "MigrateResourceResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.MigrateResourceResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.MigrateResourceResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchMigrateResourcesOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
    #[prost(message, repeated, tag = "2")]
    pub partial_results: ::prost::alloc::vec::Vec<
        batch_migrate_resources_operation_metadata::PartialResult,
    >,
}
/// Nested message and enum types in `BatchMigrateResourcesOperationMetadata`.
pub mod batch_migrate_resources_operation_metadata {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PartialResult {
        #[prost(message, optional, tag = "1")]
        pub request: ::core::option::Option<super::MigrateResourceRequest>,
        #[prost(oneof = "partial_result::Result", tags = "2, 3, 4")]
        pub result: ::core::option::Option<partial_result::Result>,
    }
    /// Nested message and enum types in `PartialResult`.
    pub mod partial_result {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Result {
            #[prost(message, tag = "2")]
            Error(super::super::super::super::super::rpc::Status),
            #[prost(string, tag = "3")]
            Model(::prost::alloc::string::String),
            #[prost(string, tag = "4")]
            Dataset(::prost::alloc::string::String),
        }
    }
    impl ::prost::Name for PartialResult {
        const NAME: &'static str = "PartialResult";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.BatchMigrateResourcesOperationMetadata.PartialResult"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.BatchMigrateResourcesOperationMetadata.PartialResult"
                .into()
        }
    }
}
impl ::prost::Name for BatchMigrateResourcesOperationMetadata {
    const NAME: &'static str = "BatchMigrateResourcesOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.BatchMigrateResourcesOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchMigrateResourcesOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModelEvaluation {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub metrics_schema_uri: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub metrics: ::core::option::Option<::prost_types::Value>,
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, repeated, tag = "5")]
    pub slice_dimensions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "6")]
    pub data_item_schema_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub annotation_schema_uri: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "8")]
    pub model_explanation: ::core::option::Option<ModelExplanation>,
    #[prost(message, repeated, tag = "9")]
    pub explanation_specs: ::prost::alloc::vec::Vec<
        model_evaluation::ModelEvaluationExplanationSpec,
    >,
    #[prost(message, optional, tag = "11")]
    pub metadata: ::core::option::Option<::prost_types::Value>,
}
/// Nested message and enum types in `ModelEvaluation`.
pub mod model_evaluation {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ModelEvaluationExplanationSpec {
        #[prost(string, tag = "1")]
        pub explanation_type: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub explanation_spec: ::core::option::Option<super::ExplanationSpec>,
    }
    impl ::prost::Name for ModelEvaluationExplanationSpec {
        const NAME: &'static str = "ModelEvaluationExplanationSpec";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.ModelEvaluation.ModelEvaluationExplanationSpec"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.ModelEvaluation.ModelEvaluationExplanationSpec"
                .into()
        }
    }
}
impl ::prost::Name for ModelEvaluation {
    const NAME: &'static str = "ModelEvaluation";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ModelEvaluation".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ModelEvaluation".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModelEvaluationSlice {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub slice: ::core::option::Option<model_evaluation_slice::Slice>,
    #[prost(string, tag = "3")]
    pub metrics_schema_uri: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub metrics: ::core::option::Option<::prost_types::Value>,
    #[prost(message, optional, tag = "5")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub model_explanation: ::core::option::Option<ModelExplanation>,
}
/// Nested message and enum types in `ModelEvaluationSlice`.
pub mod model_evaluation_slice {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Slice {
        #[prost(string, tag = "1")]
        pub dimension: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub value: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "3")]
        pub slice_spec: ::core::option::Option<slice::SliceSpec>,
    }
    /// Nested message and enum types in `Slice`.
    pub mod slice {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct SliceSpec {
            #[prost(map = "string, message", tag = "1")]
            pub configs: ::std::collections::HashMap<
                ::prost::alloc::string::String,
                slice_spec::SliceConfig,
            >,
        }
        /// Nested message and enum types in `SliceSpec`.
        pub mod slice_spec {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct SliceConfig {
                #[prost(oneof = "slice_config::Kind", tags = "1, 2, 3")]
                pub kind: ::core::option::Option<slice_config::Kind>,
            }
            /// Nested message and enum types in `SliceConfig`.
            pub mod slice_config {
                #[derive(Clone, PartialEq, ::prost::Oneof)]
                pub enum Kind {
                    #[prost(message, tag = "1")]
                    Value(super::Value),
                    #[prost(message, tag = "2")]
                    Range(super::Range),
                    #[prost(message, tag = "3")]
                    AllValues(bool),
                }
            }
            impl ::prost::Name for SliceConfig {
                const NAME: &'static str = "SliceConfig";
                const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
                fn full_name() -> ::prost::alloc::string::String {
                    "google.cloud.aiplatform.v1.ModelEvaluationSlice.Slice.SliceSpec.SliceConfig"
                        .into()
                }
                fn type_url() -> ::prost::alloc::string::String {
                    "type.googleapis.com/google.cloud.aiplatform.v1.ModelEvaluationSlice.Slice.SliceSpec.SliceConfig"
                        .into()
                }
            }
            #[derive(Clone, Copy, PartialEq, ::prost::Message)]
            pub struct Range {
                #[prost(float, tag = "1")]
                pub low: f32,
                #[prost(float, tag = "2")]
                pub high: f32,
            }
            impl ::prost::Name for Range {
                const NAME: &'static str = "Range";
                const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
                fn full_name() -> ::prost::alloc::string::String {
                    "google.cloud.aiplatform.v1.ModelEvaluationSlice.Slice.SliceSpec.Range"
                        .into()
                }
                fn type_url() -> ::prost::alloc::string::String {
                    "type.googleapis.com/google.cloud.aiplatform.v1.ModelEvaluationSlice.Slice.SliceSpec.Range"
                        .into()
                }
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Value {
                #[prost(oneof = "value::Kind", tags = "1, 2")]
                pub kind: ::core::option::Option<value::Kind>,
            }
            /// Nested message and enum types in `Value`.
            pub mod value {
                #[derive(Clone, PartialEq, ::prost::Oneof)]
                pub enum Kind {
                    #[prost(string, tag = "1")]
                    StringValue(::prost::alloc::string::String),
                    #[prost(float, tag = "2")]
                    FloatValue(f32),
                }
            }
            impl ::prost::Name for Value {
                const NAME: &'static str = "Value";
                const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
                fn full_name() -> ::prost::alloc::string::String {
                    "google.cloud.aiplatform.v1.ModelEvaluationSlice.Slice.SliceSpec.Value"
                        .into()
                }
                fn type_url() -> ::prost::alloc::string::String {
                    "type.googleapis.com/google.cloud.aiplatform.v1.ModelEvaluationSlice.Slice.SliceSpec.Value"
                        .into()
                }
            }
        }
        impl ::prost::Name for SliceSpec {
            const NAME: &'static str = "SliceSpec";
            const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "google.cloud.aiplatform.v1.ModelEvaluationSlice.Slice.SliceSpec".into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.cloud.aiplatform.v1.ModelEvaluationSlice.Slice.SliceSpec"
                    .into()
            }
        }
    }
    impl ::prost::Name for Slice {
        const NAME: &'static str = "Slice";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.ModelEvaluationSlice.Slice".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.ModelEvaluationSlice.Slice"
                .into()
        }
    }
}
impl ::prost::Name for ModelEvaluationSlice {
    const NAME: &'static str = "ModelEvaluationSlice";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ModelEvaluationSlice".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ModelEvaluationSlice".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublisherModel {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub version_id: ::prost::alloc::string::String,
    #[prost(enumeration = "publisher_model::OpenSourceCategory", tag = "7")]
    pub open_source_category: i32,
    #[prost(message, optional, tag = "19")]
    pub supported_actions: ::core::option::Option<publisher_model::CallToAction>,
    #[prost(string, repeated, tag = "23")]
    pub frameworks: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(enumeration = "publisher_model::LaunchStage", tag = "29")]
    pub launch_stage: i32,
    #[prost(enumeration = "publisher_model::VersionState", tag = "37")]
    pub version_state: i32,
    #[prost(string, tag = "30")]
    pub publisher_model_template: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "31")]
    pub predict_schemata: ::core::option::Option<PredictSchemata>,
}
/// Nested message and enum types in `PublisherModel`.
pub mod publisher_model {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ResourceReference {
        #[prost(oneof = "resource_reference::Reference", tags = "1, 2, 3, 4")]
        pub reference: ::core::option::Option<resource_reference::Reference>,
    }
    /// Nested message and enum types in `ResourceReference`.
    pub mod resource_reference {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Reference {
            #[prost(string, tag = "1")]
            Uri(::prost::alloc::string::String),
            #[prost(string, tag = "2")]
            ResourceName(::prost::alloc::string::String),
            #[prost(string, tag = "3")]
            UseCase(::prost::alloc::string::String),
            #[prost(string, tag = "4")]
            Description(::prost::alloc::string::String),
        }
    }
    impl ::prost::Name for ResourceReference {
        const NAME: &'static str = "ResourceReference";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.PublisherModel.ResourceReference".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.PublisherModel.ResourceReference"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Documentation {
        #[prost(string, tag = "1")]
        pub title: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub content: ::prost::alloc::string::String,
    }
    impl ::prost::Name for Documentation {
        const NAME: &'static str = "Documentation";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.PublisherModel.Documentation".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.PublisherModel.Documentation"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CallToAction {
        #[prost(message, optional, tag = "1")]
        pub view_rest_api: ::core::option::Option<call_to_action::ViewRestApi>,
        #[prost(message, optional, tag = "2")]
        pub open_notebook: ::core::option::Option<
            call_to_action::RegionalResourceReferences,
        >,
        #[prost(message, optional, tag = "12")]
        pub open_notebooks: ::core::option::Option<call_to_action::OpenNotebooks>,
        #[prost(message, optional, tag = "3")]
        pub create_application: ::core::option::Option<
            call_to_action::RegionalResourceReferences,
        >,
        #[prost(message, optional, tag = "4")]
        pub open_fine_tuning_pipeline: ::core::option::Option<
            call_to_action::RegionalResourceReferences,
        >,
        #[prost(message, optional, tag = "13")]
        pub open_fine_tuning_pipelines: ::core::option::Option<
            call_to_action::OpenFineTuningPipelines,
        >,
        #[prost(message, optional, tag = "5")]
        pub open_prompt_tuning_pipeline: ::core::option::Option<
            call_to_action::RegionalResourceReferences,
        >,
        #[prost(message, optional, tag = "6")]
        pub open_genie: ::core::option::Option<
            call_to_action::RegionalResourceReferences,
        >,
        #[prost(message, optional, tag = "7")]
        pub deploy: ::core::option::Option<call_to_action::Deploy>,
        #[prost(message, optional, tag = "14")]
        pub deploy_gke: ::core::option::Option<call_to_action::DeployGke>,
        #[prost(message, optional, tag = "8")]
        pub open_generation_ai_studio: ::core::option::Option<
            call_to_action::RegionalResourceReferences,
        >,
        #[prost(message, optional, tag = "9")]
        pub request_access: ::core::option::Option<
            call_to_action::RegionalResourceReferences,
        >,
        #[prost(message, optional, tag = "11")]
        pub open_evaluation_pipeline: ::core::option::Option<
            call_to_action::RegionalResourceReferences,
        >,
    }
    /// Nested message and enum types in `CallToAction`.
    pub mod call_to_action {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct RegionalResourceReferences {
            #[prost(map = "string, message", tag = "1")]
            pub references: ::std::collections::HashMap<
                ::prost::alloc::string::String,
                super::ResourceReference,
            >,
            #[prost(string, tag = "2")]
            pub title: ::prost::alloc::string::String,
            #[prost(string, optional, tag = "3")]
            pub resource_title: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(string, optional, tag = "4")]
            pub resource_use_case: ::core::option::Option<
                ::prost::alloc::string::String,
            >,
            #[prost(string, optional, tag = "5")]
            pub resource_description: ::core::option::Option<
                ::prost::alloc::string::String,
            >,
        }
        impl ::prost::Name for RegionalResourceReferences {
            const NAME: &'static str = "RegionalResourceReferences";
            const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "google.cloud.aiplatform.v1.PublisherModel.CallToAction.RegionalResourceReferences"
                    .into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.cloud.aiplatform.v1.PublisherModel.CallToAction.RegionalResourceReferences"
                    .into()
            }
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct ViewRestApi {
            #[prost(message, repeated, tag = "1")]
            pub documentations: ::prost::alloc::vec::Vec<super::Documentation>,
            #[prost(string, tag = "2")]
            pub title: ::prost::alloc::string::String,
        }
        impl ::prost::Name for ViewRestApi {
            const NAME: &'static str = "ViewRestApi";
            const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "google.cloud.aiplatform.v1.PublisherModel.CallToAction.ViewRestApi"
                    .into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.cloud.aiplatform.v1.PublisherModel.CallToAction.ViewRestApi"
                    .into()
            }
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct OpenNotebooks {
            #[prost(message, repeated, tag = "1")]
            pub notebooks: ::prost::alloc::vec::Vec<RegionalResourceReferences>,
        }
        impl ::prost::Name for OpenNotebooks {
            const NAME: &'static str = "OpenNotebooks";
            const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "google.cloud.aiplatform.v1.PublisherModel.CallToAction.OpenNotebooks"
                    .into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.cloud.aiplatform.v1.PublisherModel.CallToAction.OpenNotebooks"
                    .into()
            }
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct OpenFineTuningPipelines {
            #[prost(message, repeated, tag = "1")]
            pub fine_tuning_pipelines: ::prost::alloc::vec::Vec<
                RegionalResourceReferences,
            >,
        }
        impl ::prost::Name for OpenFineTuningPipelines {
            const NAME: &'static str = "OpenFineTuningPipelines";
            const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "google.cloud.aiplatform.v1.PublisherModel.CallToAction.OpenFineTuningPipelines"
                    .into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.cloud.aiplatform.v1.PublisherModel.CallToAction.OpenFineTuningPipelines"
                    .into()
            }
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Deploy {
            #[prost(string, tag = "1")]
            pub model_display_name: ::prost::alloc::string::String,
            #[prost(message, optional, tag = "2")]
            pub large_model_reference: ::core::option::Option<
                super::super::LargeModelReference,
            >,
            #[prost(message, optional, tag = "3")]
            pub container_spec: ::core::option::Option<super::super::ModelContainerSpec>,
            #[prost(string, tag = "4")]
            pub artifact_uri: ::prost::alloc::string::String,
            #[prost(string, optional, tag = "10")]
            pub deploy_task_name: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(message, optional, tag = "11")]
            pub deploy_metadata: ::core::option::Option<deploy::DeployMetadata>,
            #[prost(string, tag = "8")]
            pub title: ::prost::alloc::string::String,
            #[prost(string, tag = "9")]
            pub public_artifact_uri: ::prost::alloc::string::String,
            #[prost(oneof = "deploy::PredictionResources", tags = "5, 6, 7")]
            pub prediction_resources: ::core::option::Option<
                deploy::PredictionResources,
            >,
        }
        /// Nested message and enum types in `Deploy`.
        pub mod deploy {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct DeployMetadata {
                #[prost(map = "string, string", tag = "1")]
                pub labels: ::std::collections::HashMap<
                    ::prost::alloc::string::String,
                    ::prost::alloc::string::String,
                >,
                #[prost(string, tag = "2")]
                pub sample_request: ::prost::alloc::string::String,
            }
            impl ::prost::Name for DeployMetadata {
                const NAME: &'static str = "DeployMetadata";
                const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
                fn full_name() -> ::prost::alloc::string::String {
                    "google.cloud.aiplatform.v1.PublisherModel.CallToAction.Deploy.DeployMetadata"
                        .into()
                }
                fn type_url() -> ::prost::alloc::string::String {
                    "type.googleapis.com/google.cloud.aiplatform.v1.PublisherModel.CallToAction.Deploy.DeployMetadata"
                        .into()
                }
            }
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum PredictionResources {
                #[prost(message, tag = "5")]
                DedicatedResources(super::super::super::DedicatedResources),
                #[prost(message, tag = "6")]
                AutomaticResources(super::super::super::AutomaticResources),
                #[prost(string, tag = "7")]
                SharedResources(::prost::alloc::string::String),
            }
        }
        impl ::prost::Name for Deploy {
            const NAME: &'static str = "Deploy";
            const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "google.cloud.aiplatform.v1.PublisherModel.CallToAction.Deploy".into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.cloud.aiplatform.v1.PublisherModel.CallToAction.Deploy"
                    .into()
            }
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct DeployGke {
            #[prost(string, repeated, tag = "1")]
            pub gke_yaml_configs: ::prost::alloc::vec::Vec<
                ::prost::alloc::string::String,
            >,
        }
        impl ::prost::Name for DeployGke {
            const NAME: &'static str = "DeployGke";
            const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "google.cloud.aiplatform.v1.PublisherModel.CallToAction.DeployGke".into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.cloud.aiplatform.v1.PublisherModel.CallToAction.DeployGke"
                    .into()
            }
        }
    }
    impl ::prost::Name for CallToAction {
        const NAME: &'static str = "CallToAction";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.PublisherModel.CallToAction".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.PublisherModel.CallToAction"
                .into()
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OpenSourceCategory {
        Unspecified = 0,
        Proprietary = 1,
        GoogleOwnedOssWithGoogleCheckpoint = 2,
        ThirdPartyOwnedOssWithGoogleCheckpoint = 3,
        GoogleOwnedOss = 4,
        ThirdPartyOwnedOss = 5,
    }
    impl OpenSourceCategory {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "OPEN_SOURCE_CATEGORY_UNSPECIFIED",
                Self::Proprietary => "PROPRIETARY",
                Self::GoogleOwnedOssWithGoogleCheckpoint => {
                    "GOOGLE_OWNED_OSS_WITH_GOOGLE_CHECKPOINT"
                }
                Self::ThirdPartyOwnedOssWithGoogleCheckpoint => {
                    "THIRD_PARTY_OWNED_OSS_WITH_GOOGLE_CHECKPOINT"
                }
                Self::GoogleOwnedOss => "GOOGLE_OWNED_OSS",
                Self::ThirdPartyOwnedOss => "THIRD_PARTY_OWNED_OSS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OPEN_SOURCE_CATEGORY_UNSPECIFIED" => Some(Self::Unspecified),
                "PROPRIETARY" => Some(Self::Proprietary),
                "GOOGLE_OWNED_OSS_WITH_GOOGLE_CHECKPOINT" => {
                    Some(Self::GoogleOwnedOssWithGoogleCheckpoint)
                }
                "THIRD_PARTY_OWNED_OSS_WITH_GOOGLE_CHECKPOINT" => {
                    Some(Self::ThirdPartyOwnedOssWithGoogleCheckpoint)
                }
                "GOOGLE_OWNED_OSS" => Some(Self::GoogleOwnedOss),
                "THIRD_PARTY_OWNED_OSS" => Some(Self::ThirdPartyOwnedOss),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LaunchStage {
        Unspecified = 0,
        Experimental = 1,
        PrivatePreview = 2,
        PublicPreview = 3,
        Ga = 4,
    }
    impl LaunchStage {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "LAUNCH_STAGE_UNSPECIFIED",
                Self::Experimental => "EXPERIMENTAL",
                Self::PrivatePreview => "PRIVATE_PREVIEW",
                Self::PublicPreview => "PUBLIC_PREVIEW",
                Self::Ga => "GA",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LAUNCH_STAGE_UNSPECIFIED" => Some(Self::Unspecified),
                "EXPERIMENTAL" => Some(Self::Experimental),
                "PRIVATE_PREVIEW" => Some(Self::PrivatePreview),
                "PUBLIC_PREVIEW" => Some(Self::PublicPreview),
                "GA" => Some(Self::Ga),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum VersionState {
        Unspecified = 0,
        Stable = 1,
        Unstable = 2,
    }
    impl VersionState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "VERSION_STATE_UNSPECIFIED",
                Self::Stable => "VERSION_STATE_STABLE",
                Self::Unstable => "VERSION_STATE_UNSTABLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "VERSION_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "VERSION_STATE_STABLE" => Some(Self::Stable),
                "VERSION_STATE_UNSTABLE" => Some(Self::Unstable),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for PublisherModel {
    const NAME: &'static str = "PublisherModel";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.PublisherModel".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.PublisherModel".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPublisherModelRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub language_code: ::prost::alloc::string::String,
    #[prost(enumeration = "PublisherModelView", tag = "3")]
    pub view: i32,
    #[prost(bool, tag = "5")]
    pub is_hugging_face_model: bool,
    #[prost(string, tag = "6")]
    pub hugging_face_token: ::prost::alloc::string::String,
}
impl ::prost::Name for GetPublisherModelRequest {
    const NAME: &'static str = "GetPublisherModelRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetPublisherModelRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetPublisherModelRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployRequest {
    #[prost(string, tag = "4")]
    pub destination: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub model_config: ::core::option::Option<deploy_request::ModelConfig>,
    #[prost(message, optional, tag = "6")]
    pub endpoint_config: ::core::option::Option<deploy_request::EndpointConfig>,
    #[prost(message, optional, tag = "7")]
    pub deploy_config: ::core::option::Option<deploy_request::DeployConfig>,
    #[prost(oneof = "deploy_request::Artifacts", tags = "1, 2")]
    pub artifacts: ::core::option::Option<deploy_request::Artifacts>,
}
/// Nested message and enum types in `DeployRequest`.
pub mod deploy_request {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ModelConfig {
        #[prost(bool, tag = "1")]
        pub accept_eula: bool,
        #[prost(string, tag = "2")]
        pub hugging_face_access_token: ::prost::alloc::string::String,
        #[prost(bool, tag = "3")]
        pub hugging_face_cache_enabled: bool,
        #[prost(string, tag = "4")]
        pub model_display_name: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "5")]
        pub container_spec: ::core::option::Option<super::ModelContainerSpec>,
        #[prost(string, tag = "6")]
        pub model_user_id: ::prost::alloc::string::String,
    }
    impl ::prost::Name for ModelConfig {
        const NAME: &'static str = "ModelConfig";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.DeployRequest.ModelConfig".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.DeployRequest.ModelConfig"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EndpointConfig {
        #[prost(string, tag = "1")]
        pub endpoint_display_name: ::prost::alloc::string::String,
        #[deprecated]
        #[prost(bool, tag = "2")]
        pub dedicated_endpoint_enabled: bool,
        #[prost(bool, tag = "4")]
        pub dedicated_endpoint_disabled: bool,
        #[prost(string, tag = "3")]
        pub endpoint_user_id: ::prost::alloc::string::String,
    }
    impl ::prost::Name for EndpointConfig {
        const NAME: &'static str = "EndpointConfig";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.DeployRequest.EndpointConfig".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.DeployRequest.EndpointConfig"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DeployConfig {
        #[prost(message, optional, tag = "1")]
        pub dedicated_resources: ::core::option::Option<super::DedicatedResources>,
        #[prost(bool, tag = "2")]
        pub fast_tryout_enabled: bool,
        #[prost(map = "string, string", tag = "3")]
        pub system_labels: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            ::prost::alloc::string::String,
        >,
    }
    impl ::prost::Name for DeployConfig {
        const NAME: &'static str = "DeployConfig";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.DeployRequest.DeployConfig".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.DeployRequest.DeployConfig"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Artifacts {
        #[prost(string, tag = "1")]
        PublisherModelName(::prost::alloc::string::String),
        #[prost(string, tag = "2")]
        HuggingFaceModelId(::prost::alloc::string::String),
    }
}
impl ::prost::Name for DeployRequest {
    const NAME: &'static str = "DeployRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeployRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeployRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployResponse {
    #[prost(string, tag = "1")]
    pub publisher_model: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub endpoint: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub model: ::prost::alloc::string::String,
}
impl ::prost::Name for DeployResponse {
    const NAME: &'static str = "DeployResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeployResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeployResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeployOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
    #[prost(string, tag = "2")]
    pub publisher_model: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub destination: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub project_number: i64,
    #[prost(string, tag = "5")]
    pub model_id: ::prost::alloc::string::String,
}
impl ::prost::Name for DeployOperationMetadata {
    const NAME: &'static str = "DeployOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeployOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeployOperationMetadata".into()
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PublisherModelView {
    Unspecified = 0,
    Basic = 1,
    Full = 2,
    PublisherModelVersionViewBasic = 3,
}
impl PublisherModelView {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PUBLISHER_MODEL_VIEW_UNSPECIFIED",
            Self::Basic => "PUBLISHER_MODEL_VIEW_BASIC",
            Self::Full => "PUBLISHER_MODEL_VIEW_FULL",
            Self::PublisherModelVersionViewBasic => "PUBLISHER_MODEL_VERSION_VIEW_BASIC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PUBLISHER_MODEL_VIEW_UNSPECIFIED" => Some(Self::Unspecified),
            "PUBLISHER_MODEL_VIEW_BASIC" => Some(Self::Basic),
            "PUBLISHER_MODEL_VIEW_FULL" => Some(Self::Full),
            "PUBLISHER_MODEL_VERSION_VIEW_BASIC" => {
                Some(Self::PublisherModelVersionViewBasic)
            }
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadModelRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub parent_model: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub model_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub model: ::core::option::Option<Model>,
    #[prost(string, tag = "6")]
    pub service_account: ::prost::alloc::string::String,
}
impl ::prost::Name for UploadModelRequest {
    const NAME: &'static str = "UploadModelRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UploadModelRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UploadModelRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadModelOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for UploadModelOperationMetadata {
    const NAME: &'static str = "UploadModelOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UploadModelOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UploadModelOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadModelResponse {
    #[prost(string, tag = "1")]
    pub model: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub model_version_id: ::prost::alloc::string::String,
}
impl ::prost::Name for UploadModelResponse {
    const NAME: &'static str = "UploadModelResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UploadModelResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UploadModelResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetModelRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for GetModelRequest {
    const NAME: &'static str = "GetModelRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetModelRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetModelRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListModelsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(string, tag = "6")]
    pub order_by: ::prost::alloc::string::String,
}
impl ::prost::Name for ListModelsRequest {
    const NAME: &'static str = "ListModelsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListModelsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListModelsRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListModelsResponse {
    #[prost(message, repeated, tag = "1")]
    pub models: ::prost::alloc::vec::Vec<Model>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListModelsResponse {
    const NAME: &'static str = "ListModelsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListModelsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListModelsResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListModelVersionsRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(string, tag = "6")]
    pub order_by: ::prost::alloc::string::String,
}
impl ::prost::Name for ListModelVersionsRequest {
    const NAME: &'static str = "ListModelVersionsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListModelVersionsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListModelVersionsRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListModelVersionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub models: ::prost::alloc::vec::Vec<Model>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListModelVersionsResponse {
    const NAME: &'static str = "ListModelVersionsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListModelVersionsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListModelVersionsResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListModelVersionCheckpointsRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListModelVersionCheckpointsRequest {
    const NAME: &'static str = "ListModelVersionCheckpointsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListModelVersionCheckpointsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListModelVersionCheckpointsRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModelVersionCheckpoint {
    #[prost(string, tag = "1")]
    pub checkpoint_id: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub epoch: i64,
    #[prost(int64, tag = "3")]
    pub step: i64,
}
impl ::prost::Name for ModelVersionCheckpoint {
    const NAME: &'static str = "ModelVersionCheckpoint";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ModelVersionCheckpoint".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ModelVersionCheckpoint".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListModelVersionCheckpointsResponse {
    #[prost(message, repeated, tag = "1")]
    pub checkpoints: ::prost::alloc::vec::Vec<ModelVersionCheckpoint>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListModelVersionCheckpointsResponse {
    const NAME: &'static str = "ListModelVersionCheckpointsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListModelVersionCheckpointsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListModelVersionCheckpointsResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateModelRequest {
    #[prost(message, optional, tag = "1")]
    pub model: ::core::option::Option<Model>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for UpdateModelRequest {
    const NAME: &'static str = "UpdateModelRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdateModelRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateModelRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateExplanationDatasetRequest {
    #[prost(string, tag = "1")]
    pub model: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub examples: ::core::option::Option<Examples>,
}
impl ::prost::Name for UpdateExplanationDatasetRequest {
    const NAME: &'static str = "UpdateExplanationDatasetRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdateExplanationDatasetRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateExplanationDatasetRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateExplanationDatasetOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for UpdateExplanationDatasetOperationMetadata {
    const NAME: &'static str = "UpdateExplanationDatasetOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdateExplanationDatasetOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateExplanationDatasetOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteModelRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for DeleteModelRequest {
    const NAME: &'static str = "DeleteModelRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeleteModelRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteModelRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteModelVersionRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for DeleteModelVersionRequest {
    const NAME: &'static str = "DeleteModelVersionRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeleteModelVersionRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteModelVersionRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MergeVersionAliasesRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub version_aliases: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for MergeVersionAliasesRequest {
    const NAME: &'static str = "MergeVersionAliasesRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.MergeVersionAliasesRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.MergeVersionAliasesRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportModelRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub output_config: ::core::option::Option<export_model_request::OutputConfig>,
}
/// Nested message and enum types in `ExportModelRequest`.
pub mod export_model_request {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct OutputConfig {
        #[prost(string, tag = "1")]
        pub export_format_id: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "3")]
        pub artifact_destination: ::core::option::Option<super::GcsDestination>,
        #[prost(message, optional, tag = "4")]
        pub image_destination: ::core::option::Option<
            super::ContainerRegistryDestination,
        >,
    }
    impl ::prost::Name for OutputConfig {
        const NAME: &'static str = "OutputConfig";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.ExportModelRequest.OutputConfig".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.ExportModelRequest.OutputConfig"
                .into()
        }
    }
}
impl ::prost::Name for ExportModelRequest {
    const NAME: &'static str = "ExportModelRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ExportModelRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExportModelRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportModelOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
    #[prost(message, optional, tag = "2")]
    pub output_info: ::core::option::Option<export_model_operation_metadata::OutputInfo>,
}
/// Nested message and enum types in `ExportModelOperationMetadata`.
pub mod export_model_operation_metadata {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct OutputInfo {
        #[prost(string, tag = "2")]
        pub artifact_output_uri: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub image_output_uri: ::prost::alloc::string::String,
    }
    impl ::prost::Name for OutputInfo {
        const NAME: &'static str = "OutputInfo";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.ExportModelOperationMetadata.OutputInfo".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.ExportModelOperationMetadata.OutputInfo"
                .into()
        }
    }
}
impl ::prost::Name for ExportModelOperationMetadata {
    const NAME: &'static str = "ExportModelOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ExportModelOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExportModelOperationMetadata"
            .into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UpdateExplanationDatasetResponse {}
impl ::prost::Name for UpdateExplanationDatasetResponse {
    const NAME: &'static str = "UpdateExplanationDatasetResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdateExplanationDatasetResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateExplanationDatasetResponse"
            .into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExportModelResponse {}
impl ::prost::Name for ExportModelResponse {
    const NAME: &'static str = "ExportModelResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ExportModelResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExportModelResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CopyModelRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub source_model: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub encryption_spec: ::core::option::Option<EncryptionSpec>,
    #[prost(oneof = "copy_model_request::DestinationModel", tags = "4, 5")]
    pub destination_model: ::core::option::Option<copy_model_request::DestinationModel>,
}
/// Nested message and enum types in `CopyModelRequest`.
pub mod copy_model_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum DestinationModel {
        #[prost(string, tag = "4")]
        ModelId(::prost::alloc::string::String),
        #[prost(string, tag = "5")]
        ParentModel(::prost::alloc::string::String),
    }
}
impl ::prost::Name for CopyModelRequest {
    const NAME: &'static str = "CopyModelRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CopyModelRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CopyModelRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CopyModelOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for CopyModelOperationMetadata {
    const NAME: &'static str = "CopyModelOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CopyModelOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CopyModelOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CopyModelResponse {
    #[prost(string, tag = "1")]
    pub model: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub model_version_id: ::prost::alloc::string::String,
}
impl ::prost::Name for CopyModelResponse {
    const NAME: &'static str = "CopyModelResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CopyModelResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CopyModelResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportModelEvaluationRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub model_evaluation: ::core::option::Option<ModelEvaluation>,
}
impl ::prost::Name for ImportModelEvaluationRequest {
    const NAME: &'static str = "ImportModelEvaluationRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ImportModelEvaluationRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ImportModelEvaluationRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchImportModelEvaluationSlicesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub model_evaluation_slices: ::prost::alloc::vec::Vec<ModelEvaluationSlice>,
}
impl ::prost::Name for BatchImportModelEvaluationSlicesRequest {
    const NAME: &'static str = "BatchImportModelEvaluationSlicesRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.BatchImportModelEvaluationSlicesRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchImportModelEvaluationSlicesRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchImportModelEvaluationSlicesResponse {
    #[prost(string, repeated, tag = "1")]
    pub imported_model_evaluation_slices: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
}
impl ::prost::Name for BatchImportModelEvaluationSlicesResponse {
    const NAME: &'static str = "BatchImportModelEvaluationSlicesResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.BatchImportModelEvaluationSlicesResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchImportModelEvaluationSlicesResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchImportEvaluatedAnnotationsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub evaluated_annotations: ::prost::alloc::vec::Vec<EvaluatedAnnotation>,
}
impl ::prost::Name for BatchImportEvaluatedAnnotationsRequest {
    const NAME: &'static str = "BatchImportEvaluatedAnnotationsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.BatchImportEvaluatedAnnotationsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchImportEvaluatedAnnotationsRequest"
            .into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BatchImportEvaluatedAnnotationsResponse {
    #[prost(int32, tag = "1")]
    pub imported_evaluated_annotations_count: i32,
}
impl ::prost::Name for BatchImportEvaluatedAnnotationsResponse {
    const NAME: &'static str = "BatchImportEvaluatedAnnotationsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.BatchImportEvaluatedAnnotationsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchImportEvaluatedAnnotationsResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetModelEvaluationRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for GetModelEvaluationRequest {
    const NAME: &'static str = "GetModelEvaluationRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetModelEvaluationRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetModelEvaluationRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListModelEvaluationsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for ListModelEvaluationsRequest {
    const NAME: &'static str = "ListModelEvaluationsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListModelEvaluationsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListModelEvaluationsRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListModelEvaluationsResponse {
    #[prost(message, repeated, tag = "1")]
    pub model_evaluations: ::prost::alloc::vec::Vec<ModelEvaluation>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListModelEvaluationsResponse {
    const NAME: &'static str = "ListModelEvaluationsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListModelEvaluationsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListModelEvaluationsResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetModelEvaluationSliceRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for GetModelEvaluationSliceRequest {
    const NAME: &'static str = "GetModelEvaluationSliceRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetModelEvaluationSliceRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetModelEvaluationSliceRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListModelEvaluationSlicesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for ListModelEvaluationSlicesRequest {
    const NAME: &'static str = "ListModelEvaluationSlicesRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListModelEvaluationSlicesRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListModelEvaluationSlicesRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListModelEvaluationSlicesResponse {
    #[prost(message, repeated, tag = "1")]
    pub model_evaluation_slices: ::prost::alloc::vec::Vec<ModelEvaluationSlice>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListModelEvaluationSlicesResponse {
    const NAME: &'static str = "ListModelEvaluationSlicesResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListModelEvaluationSlicesResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListModelEvaluationSlicesResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkSpec {
    #[prost(bool, tag = "1")]
    pub enable_internet_access: bool,
    #[prost(string, tag = "2")]
    pub network: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub subnetwork: ::prost::alloc::string::String,
}
impl ::prost::Name for NetworkSpec {
    const NAME: &'static str = "NetworkSpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.NetworkSpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.NetworkSpec".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NotebookEucConfig {
    #[prost(bool, tag = "1")]
    pub euc_disabled: bool,
    #[prost(bool, tag = "2")]
    pub bypass_actas_check: bool,
}
impl ::prost::Name for NotebookEucConfig {
    const NAME: &'static str = "NotebookEucConfig";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.NotebookEucConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.NotebookEucConfig".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotebookExecutionJob {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub execution_timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(string, tag = "6")]
    pub schedule_resource_name: ::prost::alloc::string::String,
    #[prost(enumeration = "JobState", tag = "10")]
    pub job_state: i32,
    #[prost(message, optional, tag = "11")]
    pub status: ::core::option::Option<super::super::super::rpc::Status>,
    #[prost(message, optional, tag = "12")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "13")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "19")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "20")]
    pub kernel_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "22")]
    pub encryption_spec: ::core::option::Option<EncryptionSpec>,
    #[prost(oneof = "notebook_execution_job::NotebookSource", tags = "3, 4, 17")]
    pub notebook_source: ::core::option::Option<notebook_execution_job::NotebookSource>,
    #[prost(oneof = "notebook_execution_job::EnvironmentSpec", tags = "14, 16")]
    pub environment_spec: ::core::option::Option<
        notebook_execution_job::EnvironmentSpec,
    >,
    #[prost(oneof = "notebook_execution_job::ExecutionSink", tags = "8")]
    pub execution_sink: ::core::option::Option<notebook_execution_job::ExecutionSink>,
    #[prost(oneof = "notebook_execution_job::ExecutionIdentity", tags = "9, 18")]
    pub execution_identity: ::core::option::Option<
        notebook_execution_job::ExecutionIdentity,
    >,
    #[prost(oneof = "notebook_execution_job::RuntimeEnvironment", tags = "23")]
    pub runtime_environment: ::core::option::Option<
        notebook_execution_job::RuntimeEnvironment,
    >,
}
/// Nested message and enum types in `NotebookExecutionJob`.
pub mod notebook_execution_job {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DataformRepositorySource {
        #[prost(string, tag = "1")]
        pub dataform_repository_resource_name: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub commit_sha: ::prost::alloc::string::String,
    }
    impl ::prost::Name for DataformRepositorySource {
        const NAME: &'static str = "DataformRepositorySource";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.NotebookExecutionJob.DataformRepositorySource"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.NotebookExecutionJob.DataformRepositorySource"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GcsNotebookSource {
        #[prost(string, tag = "1")]
        pub uri: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub generation: ::prost::alloc::string::String,
    }
    impl ::prost::Name for GcsNotebookSource {
        const NAME: &'static str = "GcsNotebookSource";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.NotebookExecutionJob.GcsNotebookSource".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.NotebookExecutionJob.GcsNotebookSource"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DirectNotebookSource {
        #[prost(bytes = "bytes", tag = "1")]
        pub content: ::prost::bytes::Bytes,
    }
    impl ::prost::Name for DirectNotebookSource {
        const NAME: &'static str = "DirectNotebookSource";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.NotebookExecutionJob.DirectNotebookSource".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.NotebookExecutionJob.DirectNotebookSource"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CustomEnvironmentSpec {
        #[prost(message, optional, tag = "1")]
        pub machine_spec: ::core::option::Option<super::MachineSpec>,
        #[prost(message, optional, tag = "2")]
        pub persistent_disk_spec: ::core::option::Option<super::PersistentDiskSpec>,
        #[prost(message, optional, tag = "3")]
        pub network_spec: ::core::option::Option<super::NetworkSpec>,
    }
    impl ::prost::Name for CustomEnvironmentSpec {
        const NAME: &'static str = "CustomEnvironmentSpec";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.NotebookExecutionJob.CustomEnvironmentSpec"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.NotebookExecutionJob.CustomEnvironmentSpec"
                .into()
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct WorkbenchRuntime {}
    impl ::prost::Name for WorkbenchRuntime {
        const NAME: &'static str = "WorkbenchRuntime";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.NotebookExecutionJob.WorkbenchRuntime".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.NotebookExecutionJob.WorkbenchRuntime"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum NotebookSource {
        #[prost(message, tag = "3")]
        DataformRepositorySource(DataformRepositorySource),
        #[prost(message, tag = "4")]
        GcsNotebookSource(GcsNotebookSource),
        #[prost(message, tag = "17")]
        DirectNotebookSource(DirectNotebookSource),
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum EnvironmentSpec {
        #[prost(string, tag = "14")]
        NotebookRuntimeTemplateResourceName(::prost::alloc::string::String),
        #[prost(message, tag = "16")]
        CustomEnvironmentSpec(CustomEnvironmentSpec),
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ExecutionSink {
        #[prost(string, tag = "8")]
        GcsOutputUri(::prost::alloc::string::String),
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ExecutionIdentity {
        #[prost(string, tag = "9")]
        ExecutionUser(::prost::alloc::string::String),
        #[prost(string, tag = "18")]
        ServiceAccount(::prost::alloc::string::String),
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum RuntimeEnvironment {
        #[prost(message, tag = "23")]
        WorkbenchRuntime(WorkbenchRuntime),
    }
}
impl ::prost::Name for NotebookExecutionJob {
    const NAME: &'static str = "NotebookExecutionJob";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.NotebookExecutionJob".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.NotebookExecutionJob".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NotebookIdleShutdownConfig {
    #[prost(message, optional, tag = "1")]
    pub idle_timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(bool, tag = "2")]
    pub idle_shutdown_disabled: bool,
}
impl ::prost::Name for NotebookIdleShutdownConfig {
    const NAME: &'static str = "NotebookIdleShutdownConfig";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.NotebookIdleShutdownConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.NotebookIdleShutdownConfig"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotebookRuntimeTemplateRef {
    #[prost(string, tag = "1")]
    pub notebook_runtime_template: ::prost::alloc::string::String,
}
impl ::prost::Name for NotebookRuntimeTemplateRef {
    const NAME: &'static str = "NotebookRuntimeTemplateRef";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.NotebookRuntimeTemplateRef".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.NotebookRuntimeTemplateRef"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PostStartupScriptConfig {
    #[prost(string, tag = "1")]
    pub post_startup_script: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub post_startup_script_url: ::prost::alloc::string::String,
    #[prost(
        enumeration = "post_startup_script_config::PostStartupScriptBehavior",
        tag = "3"
    )]
    pub post_startup_script_behavior: i32,
}
/// Nested message and enum types in `PostStartupScriptConfig`.
pub mod post_startup_script_config {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PostStartupScriptBehavior {
        Unspecified = 0,
        RunOnce = 1,
        RunEveryStart = 2,
        DownloadAndRunEveryStart = 3,
    }
    impl PostStartupScriptBehavior {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "POST_STARTUP_SCRIPT_BEHAVIOR_UNSPECIFIED",
                Self::RunOnce => "RUN_ONCE",
                Self::RunEveryStart => "RUN_EVERY_START",
                Self::DownloadAndRunEveryStart => "DOWNLOAD_AND_RUN_EVERY_START",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "POST_STARTUP_SCRIPT_BEHAVIOR_UNSPECIFIED" => Some(Self::Unspecified),
                "RUN_ONCE" => Some(Self::RunOnce),
                "RUN_EVERY_START" => Some(Self::RunEveryStart),
                "DOWNLOAD_AND_RUN_EVERY_START" => Some(Self::DownloadAndRunEveryStart),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for PostStartupScriptConfig {
    const NAME: &'static str = "PostStartupScriptConfig";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.PostStartupScriptConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.PostStartupScriptConfig".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ColabImage {
    #[prost(string, tag = "1")]
    pub release_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
}
impl ::prost::Name for ColabImage {
    const NAME: &'static str = "ColabImage";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ColabImage".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ColabImage".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotebookSoftwareConfig {
    #[prost(message, repeated, tag = "1")]
    pub env: ::prost::alloc::vec::Vec<EnvVar>,
    #[prost(message, optional, tag = "2")]
    pub post_startup_script_config: ::core::option::Option<PostStartupScriptConfig>,
    #[prost(oneof = "notebook_software_config::RuntimeImage", tags = "5")]
    pub runtime_image: ::core::option::Option<notebook_software_config::RuntimeImage>,
}
/// Nested message and enum types in `NotebookSoftwareConfig`.
pub mod notebook_software_config {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum RuntimeImage {
        #[prost(message, tag = "5")]
        ColabImage(super::ColabImage),
    }
}
impl ::prost::Name for NotebookSoftwareConfig {
    const NAME: &'static str = "NotebookSoftwareConfig";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.NotebookSoftwareConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.NotebookSoftwareConfig".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotebookRuntimeTemplate {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[deprecated]
    #[prost(bool, tag = "4")]
    pub is_default: bool,
    #[prost(message, optional, tag = "5")]
    pub machine_spec: ::core::option::Option<MachineSpec>,
    #[prost(message, optional, tag = "8")]
    pub data_persistent_disk_spec: ::core::option::Option<PersistentDiskSpec>,
    #[prost(message, optional, tag = "12")]
    pub network_spec: ::core::option::Option<NetworkSpec>,
    #[deprecated]
    #[prost(string, tag = "13")]
    pub service_account: ::prost::alloc::string::String,
    #[prost(string, tag = "14")]
    pub etag: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "15")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "17")]
    pub idle_shutdown_config: ::core::option::Option<NotebookIdleShutdownConfig>,
    #[prost(message, optional, tag = "18")]
    pub euc_config: ::core::option::Option<NotebookEucConfig>,
    #[prost(message, optional, tag = "10")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "11")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration = "NotebookRuntimeType", tag = "19")]
    pub notebook_runtime_type: i32,
    #[prost(message, optional, tag = "20")]
    pub shielded_vm_config: ::core::option::Option<ShieldedVmConfig>,
    #[prost(string, repeated, tag = "21")]
    pub network_tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "23")]
    pub encryption_spec: ::core::option::Option<EncryptionSpec>,
    #[prost(message, optional, tag = "24")]
    pub software_config: ::core::option::Option<NotebookSoftwareConfig>,
}
impl ::prost::Name for NotebookRuntimeTemplate {
    const NAME: &'static str = "NotebookRuntimeTemplate";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.NotebookRuntimeTemplate".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.NotebookRuntimeTemplate".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotebookRuntime {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub runtime_user: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub notebook_runtime_template_ref: ::core::option::Option<
        NotebookRuntimeTemplateRef,
    >,
    #[prost(string, tag = "5")]
    pub proxy_uri: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration = "notebook_runtime::HealthState", tag = "8")]
    pub health_state: i32,
    #[prost(string, tag = "10")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "13")]
    pub service_account: ::prost::alloc::string::String,
    #[prost(enumeration = "notebook_runtime::RuntimeState", tag = "14")]
    pub runtime_state: i32,
    #[prost(bool, tag = "15")]
    pub is_upgradable: bool,
    #[prost(map = "string, string", tag = "16")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "17")]
    pub expiration_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "18")]
    pub version: ::prost::alloc::string::String,
    #[prost(enumeration = "NotebookRuntimeType", tag = "19")]
    pub notebook_runtime_type: i32,
    #[prost(message, optional, tag = "20")]
    pub machine_spec: ::core::option::Option<MachineSpec>,
    #[prost(message, optional, tag = "21")]
    pub data_persistent_disk_spec: ::core::option::Option<PersistentDiskSpec>,
    #[prost(message, optional, tag = "22")]
    pub network_spec: ::core::option::Option<NetworkSpec>,
    #[prost(message, optional, tag = "23")]
    pub idle_shutdown_config: ::core::option::Option<NotebookIdleShutdownConfig>,
    #[prost(message, optional, tag = "24")]
    pub euc_config: ::core::option::Option<NotebookEucConfig>,
    #[prost(message, optional, tag = "32")]
    pub shielded_vm_config: ::core::option::Option<ShieldedVmConfig>,
    #[prost(string, repeated, tag = "25")]
    pub network_tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "31")]
    pub software_config: ::core::option::Option<NotebookSoftwareConfig>,
    #[prost(message, optional, tag = "28")]
    pub encryption_spec: ::core::option::Option<EncryptionSpec>,
    #[prost(bool, tag = "29")]
    pub satisfies_pzs: bool,
    #[prost(bool, tag = "30")]
    pub satisfies_pzi: bool,
}
/// Nested message and enum types in `NotebookRuntime`.
pub mod notebook_runtime {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum HealthState {
        Unspecified = 0,
        Healthy = 1,
        Unhealthy = 2,
    }
    impl HealthState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "HEALTH_STATE_UNSPECIFIED",
                Self::Healthy => "HEALTHY",
                Self::Unhealthy => "UNHEALTHY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "HEALTH_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "HEALTHY" => Some(Self::Healthy),
                "UNHEALTHY" => Some(Self::Unhealthy),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RuntimeState {
        Unspecified = 0,
        Running = 1,
        BeingStarted = 2,
        BeingStopped = 3,
        Stopped = 4,
        BeingUpgraded = 5,
        Error = 100,
        Invalid = 101,
    }
    impl RuntimeState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "RUNTIME_STATE_UNSPECIFIED",
                Self::Running => "RUNNING",
                Self::BeingStarted => "BEING_STARTED",
                Self::BeingStopped => "BEING_STOPPED",
                Self::Stopped => "STOPPED",
                Self::BeingUpgraded => "BEING_UPGRADED",
                Self::Error => "ERROR",
                Self::Invalid => "INVALID",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RUNTIME_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "RUNNING" => Some(Self::Running),
                "BEING_STARTED" => Some(Self::BeingStarted),
                "BEING_STOPPED" => Some(Self::BeingStopped),
                "STOPPED" => Some(Self::Stopped),
                "BEING_UPGRADED" => Some(Self::BeingUpgraded),
                "ERROR" => Some(Self::Error),
                "INVALID" => Some(Self::Invalid),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for NotebookRuntime {
    const NAME: &'static str = "NotebookRuntime";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.NotebookRuntime".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.NotebookRuntime".into()
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NotebookRuntimeType {
    Unspecified = 0,
    UserDefined = 1,
    OneClick = 2,
}
impl NotebookRuntimeType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "NOTEBOOK_RUNTIME_TYPE_UNSPECIFIED",
            Self::UserDefined => "USER_DEFINED",
            Self::OneClick => "ONE_CLICK",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NOTEBOOK_RUNTIME_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "USER_DEFINED" => Some(Self::UserDefined),
            "ONE_CLICK" => Some(Self::OneClick),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateNotebookRuntimeTemplateRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub notebook_runtime_template: ::core::option::Option<NotebookRuntimeTemplate>,
    #[prost(string, tag = "3")]
    pub notebook_runtime_template_id: ::prost::alloc::string::String,
}
impl ::prost::Name for CreateNotebookRuntimeTemplateRequest {
    const NAME: &'static str = "CreateNotebookRuntimeTemplateRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateNotebookRuntimeTemplateRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateNotebookRuntimeTemplateRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateNotebookRuntimeTemplateOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for CreateNotebookRuntimeTemplateOperationMetadata {
    const NAME: &'static str = "CreateNotebookRuntimeTemplateOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateNotebookRuntimeTemplateOperationMetadata"
            .into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateNotebookRuntimeTemplateOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNotebookRuntimeTemplateRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for GetNotebookRuntimeTemplateRequest {
    const NAME: &'static str = "GetNotebookRuntimeTemplateRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetNotebookRuntimeTemplateRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetNotebookRuntimeTemplateRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNotebookRuntimeTemplatesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(string, tag = "6")]
    pub order_by: ::prost::alloc::string::String,
}
impl ::prost::Name for ListNotebookRuntimeTemplatesRequest {
    const NAME: &'static str = "ListNotebookRuntimeTemplatesRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListNotebookRuntimeTemplatesRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListNotebookRuntimeTemplatesRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNotebookRuntimeTemplatesResponse {
    #[prost(message, repeated, tag = "1")]
    pub notebook_runtime_templates: ::prost::alloc::vec::Vec<NotebookRuntimeTemplate>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListNotebookRuntimeTemplatesResponse {
    const NAME: &'static str = "ListNotebookRuntimeTemplatesResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListNotebookRuntimeTemplatesResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListNotebookRuntimeTemplatesResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteNotebookRuntimeTemplateRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for DeleteNotebookRuntimeTemplateRequest {
    const NAME: &'static str = "DeleteNotebookRuntimeTemplateRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeleteNotebookRuntimeTemplateRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteNotebookRuntimeTemplateRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateNotebookRuntimeTemplateRequest {
    #[prost(message, optional, tag = "1")]
    pub notebook_runtime_template: ::core::option::Option<NotebookRuntimeTemplate>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for UpdateNotebookRuntimeTemplateRequest {
    const NAME: &'static str = "UpdateNotebookRuntimeTemplateRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdateNotebookRuntimeTemplateRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateNotebookRuntimeTemplateRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssignNotebookRuntimeRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub notebook_runtime_template: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub notebook_runtime: ::core::option::Option<NotebookRuntime>,
    #[prost(string, tag = "4")]
    pub notebook_runtime_id: ::prost::alloc::string::String,
}
impl ::prost::Name for AssignNotebookRuntimeRequest {
    const NAME: &'static str = "AssignNotebookRuntimeRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.AssignNotebookRuntimeRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.AssignNotebookRuntimeRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssignNotebookRuntimeOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
    #[prost(string, tag = "2")]
    pub progress_message: ::prost::alloc::string::String,
}
impl ::prost::Name for AssignNotebookRuntimeOperationMetadata {
    const NAME: &'static str = "AssignNotebookRuntimeOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.AssignNotebookRuntimeOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.AssignNotebookRuntimeOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNotebookRuntimeRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for GetNotebookRuntimeRequest {
    const NAME: &'static str = "GetNotebookRuntimeRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetNotebookRuntimeRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetNotebookRuntimeRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNotebookRuntimesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(string, tag = "6")]
    pub order_by: ::prost::alloc::string::String,
}
impl ::prost::Name for ListNotebookRuntimesRequest {
    const NAME: &'static str = "ListNotebookRuntimesRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListNotebookRuntimesRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListNotebookRuntimesRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNotebookRuntimesResponse {
    #[prost(message, repeated, tag = "1")]
    pub notebook_runtimes: ::prost::alloc::vec::Vec<NotebookRuntime>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListNotebookRuntimesResponse {
    const NAME: &'static str = "ListNotebookRuntimesResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListNotebookRuntimesResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListNotebookRuntimesResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteNotebookRuntimeRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for DeleteNotebookRuntimeRequest {
    const NAME: &'static str = "DeleteNotebookRuntimeRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeleteNotebookRuntimeRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteNotebookRuntimeRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpgradeNotebookRuntimeRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for UpgradeNotebookRuntimeRequest {
    const NAME: &'static str = "UpgradeNotebookRuntimeRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpgradeNotebookRuntimeRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpgradeNotebookRuntimeRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpgradeNotebookRuntimeOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
    #[prost(string, tag = "2")]
    pub progress_message: ::prost::alloc::string::String,
}
impl ::prost::Name for UpgradeNotebookRuntimeOperationMetadata {
    const NAME: &'static str = "UpgradeNotebookRuntimeOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpgradeNotebookRuntimeOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpgradeNotebookRuntimeOperationMetadata"
            .into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UpgradeNotebookRuntimeResponse {}
impl ::prost::Name for UpgradeNotebookRuntimeResponse {
    const NAME: &'static str = "UpgradeNotebookRuntimeResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpgradeNotebookRuntimeResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpgradeNotebookRuntimeResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartNotebookRuntimeRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for StartNotebookRuntimeRequest {
    const NAME: &'static str = "StartNotebookRuntimeRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.StartNotebookRuntimeRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.StartNotebookRuntimeRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartNotebookRuntimeOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
    #[prost(string, tag = "2")]
    pub progress_message: ::prost::alloc::string::String,
}
impl ::prost::Name for StartNotebookRuntimeOperationMetadata {
    const NAME: &'static str = "StartNotebookRuntimeOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.StartNotebookRuntimeOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.StartNotebookRuntimeOperationMetadata"
            .into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StartNotebookRuntimeResponse {}
impl ::prost::Name for StartNotebookRuntimeResponse {
    const NAME: &'static str = "StartNotebookRuntimeResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.StartNotebookRuntimeResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.StartNotebookRuntimeResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopNotebookRuntimeRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for StopNotebookRuntimeRequest {
    const NAME: &'static str = "StopNotebookRuntimeRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.StopNotebookRuntimeRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.StopNotebookRuntimeRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopNotebookRuntimeOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for StopNotebookRuntimeOperationMetadata {
    const NAME: &'static str = "StopNotebookRuntimeOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.StopNotebookRuntimeOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.StopNotebookRuntimeOperationMetadata"
            .into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StopNotebookRuntimeResponse {}
impl ::prost::Name for StopNotebookRuntimeResponse {
    const NAME: &'static str = "StopNotebookRuntimeResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.StopNotebookRuntimeResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.StopNotebookRuntimeResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateNotebookExecutionJobRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub notebook_execution_job: ::core::option::Option<NotebookExecutionJob>,
    #[prost(string, tag = "3")]
    pub notebook_execution_job_id: ::prost::alloc::string::String,
}
impl ::prost::Name for CreateNotebookExecutionJobRequest {
    const NAME: &'static str = "CreateNotebookExecutionJobRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateNotebookExecutionJobRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateNotebookExecutionJobRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateNotebookExecutionJobOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
    #[prost(string, tag = "2")]
    pub progress_message: ::prost::alloc::string::String,
}
impl ::prost::Name for CreateNotebookExecutionJobOperationMetadata {
    const NAME: &'static str = "CreateNotebookExecutionJobOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateNotebookExecutionJobOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateNotebookExecutionJobOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNotebookExecutionJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "NotebookExecutionJobView", tag = "6")]
    pub view: i32,
}
impl ::prost::Name for GetNotebookExecutionJobRequest {
    const NAME: &'static str = "GetNotebookExecutionJobRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetNotebookExecutionJobRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetNotebookExecutionJobRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNotebookExecutionJobsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    #[prost(enumeration = "NotebookExecutionJobView", tag = "6")]
    pub view: i32,
}
impl ::prost::Name for ListNotebookExecutionJobsRequest {
    const NAME: &'static str = "ListNotebookExecutionJobsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListNotebookExecutionJobsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListNotebookExecutionJobsRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNotebookExecutionJobsResponse {
    #[prost(message, repeated, tag = "1")]
    pub notebook_execution_jobs: ::prost::alloc::vec::Vec<NotebookExecutionJob>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListNotebookExecutionJobsResponse {
    const NAME: &'static str = "ListNotebookExecutionJobsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListNotebookExecutionJobsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListNotebookExecutionJobsResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteNotebookExecutionJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for DeleteNotebookExecutionJobRequest {
    const NAME: &'static str = "DeleteNotebookExecutionJobRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeleteNotebookExecutionJobRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteNotebookExecutionJobRequest"
            .into()
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NotebookExecutionJobView {
    Unspecified = 0,
    Basic = 1,
    Full = 2,
}
impl NotebookExecutionJobView {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "NOTEBOOK_EXECUTION_JOB_VIEW_UNSPECIFIED",
            Self::Basic => "NOTEBOOK_EXECUTION_JOB_VIEW_BASIC",
            Self::Full => "NOTEBOOK_EXECUTION_JOB_VIEW_FULL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NOTEBOOK_EXECUTION_JOB_VIEW_UNSPECIFIED" => Some(Self::Unspecified),
            "NOTEBOOK_EXECUTION_JOB_VIEW_BASIC" => Some(Self::Basic),
            "NOTEBOOK_EXECUTION_JOB_VIEW_FULL" => Some(Self::Full),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PersistentResource {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "4")]
    pub resource_pools: ::prost::alloc::vec::Vec<ResourcePool>,
    #[prost(enumeration = "persistent_resource::State", tag = "5")]
    pub state: i32,
    #[prost(message, optional, tag = "6")]
    pub error: ::core::option::Option<super::super::super::rpc::Status>,
    #[prost(message, optional, tag = "7")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "10")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "11")]
    pub network: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "17")]
    pub psc_interface_config: ::core::option::Option<PscInterfaceConfig>,
    #[prost(message, optional, tag = "12")]
    pub encryption_spec: ::core::option::Option<EncryptionSpec>,
    #[prost(message, optional, tag = "13")]
    pub resource_runtime_spec: ::core::option::Option<ResourceRuntimeSpec>,
    #[prost(message, optional, tag = "14")]
    pub resource_runtime: ::core::option::Option<ResourceRuntime>,
    #[prost(string, repeated, tag = "15")]
    pub reserved_ip_ranges: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `PersistentResource`.
pub mod persistent_resource {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Provisioning = 1,
        Running = 3,
        Stopping = 4,
        Error = 5,
        Rebooting = 6,
        Updating = 7,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Provisioning => "PROVISIONING",
                Self::Running => "RUNNING",
                Self::Stopping => "STOPPING",
                Self::Error => "ERROR",
                Self::Rebooting => "REBOOTING",
                Self::Updating => "UPDATING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PROVISIONING" => Some(Self::Provisioning),
                "RUNNING" => Some(Self::Running),
                "STOPPING" => Some(Self::Stopping),
                "ERROR" => Some(Self::Error),
                "REBOOTING" => Some(Self::Rebooting),
                "UPDATING" => Some(Self::Updating),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for PersistentResource {
    const NAME: &'static str = "PersistentResource";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.PersistentResource".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.PersistentResource".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourcePool {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub machine_spec: ::core::option::Option<MachineSpec>,
    #[prost(int64, optional, tag = "3")]
    pub replica_count: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "4")]
    pub disk_spec: ::core::option::Option<DiskSpec>,
    #[prost(int64, tag = "6")]
    pub used_replica_count: i64,
    #[prost(message, optional, tag = "7")]
    pub autoscaling_spec: ::core::option::Option<resource_pool::AutoscalingSpec>,
}
/// Nested message and enum types in `ResourcePool`.
pub mod resource_pool {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct AutoscalingSpec {
        #[prost(int64, optional, tag = "1")]
        pub min_replica_count: ::core::option::Option<i64>,
        #[prost(int64, optional, tag = "2")]
        pub max_replica_count: ::core::option::Option<i64>,
    }
    impl ::prost::Name for AutoscalingSpec {
        const NAME: &'static str = "AutoscalingSpec";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.ResourcePool.AutoscalingSpec".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.ResourcePool.AutoscalingSpec"
                .into()
        }
    }
}
impl ::prost::Name for ResourcePool {
    const NAME: &'static str = "ResourcePool";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ResourcePool".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ResourcePool".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceRuntimeSpec {
    #[prost(message, optional, tag = "2")]
    pub service_account_spec: ::core::option::Option<ServiceAccountSpec>,
    #[prost(message, optional, tag = "1")]
    pub ray_spec: ::core::option::Option<RaySpec>,
}
impl ::prost::Name for ResourceRuntimeSpec {
    const NAME: &'static str = "ResourceRuntimeSpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ResourceRuntimeSpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ResourceRuntimeSpec".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RaySpec {
    #[prost(string, tag = "1")]
    pub image_uri: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "6")]
    pub resource_pool_images: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "7")]
    pub head_node_resource_pool_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "8")]
    pub ray_metric_spec: ::core::option::Option<RayMetricSpec>,
    #[prost(message, optional, tag = "10")]
    pub ray_logs_spec: ::core::option::Option<RayLogsSpec>,
}
impl ::prost::Name for RaySpec {
    const NAME: &'static str = "RaySpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.RaySpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.RaySpec".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceRuntime {
    #[prost(map = "string, string", tag = "1")]
    pub access_uris: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
impl ::prost::Name for ResourceRuntime {
    const NAME: &'static str = "ResourceRuntime";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ResourceRuntime".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ResourceRuntime".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceAccountSpec {
    #[prost(bool, tag = "1")]
    pub enable_custom_service_account: bool,
    #[prost(string, tag = "2")]
    pub service_account: ::prost::alloc::string::String,
}
impl ::prost::Name for ServiceAccountSpec {
    const NAME: &'static str = "ServiceAccountSpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ServiceAccountSpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ServiceAccountSpec".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RayMetricSpec {
    #[prost(bool, tag = "1")]
    pub disabled: bool,
}
impl ::prost::Name for RayMetricSpec {
    const NAME: &'static str = "RayMetricSpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.RayMetricSpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.RayMetricSpec".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RayLogsSpec {
    #[prost(bool, tag = "1")]
    pub disabled: bool,
}
impl ::prost::Name for RayLogsSpec {
    const NAME: &'static str = "RayLogsSpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.RayLogsSpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.RayLogsSpec".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreatePersistentResourceRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub persistent_resource: ::core::option::Option<PersistentResource>,
    #[prost(string, tag = "3")]
    pub persistent_resource_id: ::prost::alloc::string::String,
}
impl ::prost::Name for CreatePersistentResourceRequest {
    const NAME: &'static str = "CreatePersistentResourceRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreatePersistentResourceRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreatePersistentResourceRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreatePersistentResourceOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
    #[prost(string, tag = "2")]
    pub progress_message: ::prost::alloc::string::String,
}
impl ::prost::Name for CreatePersistentResourceOperationMetadata {
    const NAME: &'static str = "CreatePersistentResourceOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreatePersistentResourceOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreatePersistentResourceOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePersistentResourceOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
    #[prost(string, tag = "2")]
    pub progress_message: ::prost::alloc::string::String,
}
impl ::prost::Name for UpdatePersistentResourceOperationMetadata {
    const NAME: &'static str = "UpdatePersistentResourceOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdatePersistentResourceOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdatePersistentResourceOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RebootPersistentResourceOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
    #[prost(string, tag = "2")]
    pub progress_message: ::prost::alloc::string::String,
}
impl ::prost::Name for RebootPersistentResourceOperationMetadata {
    const NAME: &'static str = "RebootPersistentResourceOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.RebootPersistentResourceOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.RebootPersistentResourceOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPersistentResourceRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for GetPersistentResourceRequest {
    const NAME: &'static str = "GetPersistentResourceRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetPersistentResourceRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetPersistentResourceRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPersistentResourcesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListPersistentResourcesRequest {
    const NAME: &'static str = "ListPersistentResourcesRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListPersistentResourcesRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListPersistentResourcesRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPersistentResourcesResponse {
    #[prost(message, repeated, tag = "1")]
    pub persistent_resources: ::prost::alloc::vec::Vec<PersistentResource>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListPersistentResourcesResponse {
    const NAME: &'static str = "ListPersistentResourcesResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListPersistentResourcesResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListPersistentResourcesResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeletePersistentResourceRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for DeletePersistentResourceRequest {
    const NAME: &'static str = "DeletePersistentResourceRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeletePersistentResourceRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeletePersistentResourceRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePersistentResourceRequest {
    #[prost(message, optional, tag = "1")]
    pub persistent_resource: ::core::option::Option<PersistentResource>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for UpdatePersistentResourceRequest {
    const NAME: &'static str = "UpdatePersistentResourceRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdatePersistentResourceRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdatePersistentResourceRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RebootPersistentResourceRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for RebootPersistentResourceRequest {
    const NAME: &'static str = "RebootPersistentResourceRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.RebootPersistentResourceRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.RebootPersistentResourceRequest"
            .into()
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PipelineFailurePolicy {
    Unspecified = 0,
    FailSlow = 1,
    FailFast = 2,
}
impl PipelineFailurePolicy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PIPELINE_FAILURE_POLICY_UNSPECIFIED",
            Self::FailSlow => "PIPELINE_FAILURE_POLICY_FAIL_SLOW",
            Self::FailFast => "PIPELINE_FAILURE_POLICY_FAIL_FAST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PIPELINE_FAILURE_POLICY_UNSPECIFIED" => Some(Self::Unspecified),
            "PIPELINE_FAILURE_POLICY_FAIL_SLOW" => Some(Self::FailSlow),
            "PIPELINE_FAILURE_POLICY_FAIL_FAST" => Some(Self::FailFast),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PipelineState {
    Unspecified = 0,
    Queued = 1,
    Pending = 2,
    Running = 3,
    Succeeded = 4,
    Failed = 5,
    Cancelling = 6,
    Cancelled = 7,
    Paused = 8,
}
impl PipelineState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PIPELINE_STATE_UNSPECIFIED",
            Self::Queued => "PIPELINE_STATE_QUEUED",
            Self::Pending => "PIPELINE_STATE_PENDING",
            Self::Running => "PIPELINE_STATE_RUNNING",
            Self::Succeeded => "PIPELINE_STATE_SUCCEEDED",
            Self::Failed => "PIPELINE_STATE_FAILED",
            Self::Cancelling => "PIPELINE_STATE_CANCELLING",
            Self::Cancelled => "PIPELINE_STATE_CANCELLED",
            Self::Paused => "PIPELINE_STATE_PAUSED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PIPELINE_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "PIPELINE_STATE_QUEUED" => Some(Self::Queued),
            "PIPELINE_STATE_PENDING" => Some(Self::Pending),
            "PIPELINE_STATE_RUNNING" => Some(Self::Running),
            "PIPELINE_STATE_SUCCEEDED" => Some(Self::Succeeded),
            "PIPELINE_STATE_FAILED" => Some(Self::Failed),
            "PIPELINE_STATE_CANCELLING" => Some(Self::Cancelling),
            "PIPELINE_STATE_CANCELLED" => Some(Self::Cancelled),
            "PIPELINE_STATE_PAUSED" => Some(Self::Paused),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Value {
    #[prost(oneof = "value::Value", tags = "1, 2, 3")]
    pub value: ::core::option::Option<value::Value>,
}
/// Nested message and enum types in `Value`.
pub mod value {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(int64, tag = "1")]
        IntValue(i64),
        #[prost(double, tag = "2")]
        DoubleValue(f64),
        #[prost(string, tag = "3")]
        StringValue(::prost::alloc::string::String),
    }
}
impl ::prost::Name for Value {
    const NAME: &'static str = "Value";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.Value".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.Value".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PipelineJob {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "5")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub pipeline_spec: ::core::option::Option<::prost_types::Struct>,
    #[prost(enumeration = "PipelineState", tag = "8")]
    pub state: i32,
    #[prost(message, optional, tag = "9")]
    pub job_detail: ::core::option::Option<PipelineJobDetail>,
    #[prost(message, optional, tag = "10")]
    pub error: ::core::option::Option<super::super::super::rpc::Status>,
    #[prost(map = "string, string", tag = "11")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "12")]
    pub runtime_config: ::core::option::Option<pipeline_job::RuntimeConfig>,
    #[prost(message, optional, tag = "16")]
    pub encryption_spec: ::core::option::Option<EncryptionSpec>,
    #[prost(string, tag = "17")]
    pub service_account: ::prost::alloc::string::String,
    #[prost(string, tag = "18")]
    pub network: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "25")]
    pub reserved_ip_ranges: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "31")]
    pub psc_interface_config: ::core::option::Option<PscInterfaceConfig>,
    #[prost(string, tag = "19")]
    pub template_uri: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "20")]
    pub template_metadata: ::core::option::Option<PipelineTemplateMetadata>,
    #[prost(string, tag = "22")]
    pub schedule_name: ::prost::alloc::string::String,
    #[prost(bool, tag = "26")]
    pub preflight_validations: bool,
}
/// Nested message and enum types in `PipelineJob`.
pub mod pipeline_job {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RuntimeConfig {
        #[prost(map = "string, message", tag = "1")]
        pub parameters: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            super::Value,
        >,
        #[prost(string, tag = "2")]
        pub gcs_output_directory: ::prost::alloc::string::String,
        #[prost(map = "string, message", tag = "3")]
        pub parameter_values: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            ::prost_types::Value,
        >,
        #[prost(enumeration = "super::PipelineFailurePolicy", tag = "4")]
        pub failure_policy: i32,
        #[prost(map = "string, message", tag = "5")]
        pub input_artifacts: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            runtime_config::InputArtifact,
        >,
    }
    /// Nested message and enum types in `RuntimeConfig`.
    pub mod runtime_config {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct InputArtifact {
            #[prost(oneof = "input_artifact::Kind", tags = "1")]
            pub kind: ::core::option::Option<input_artifact::Kind>,
        }
        /// Nested message and enum types in `InputArtifact`.
        pub mod input_artifact {
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum Kind {
                #[prost(string, tag = "1")]
                ArtifactId(::prost::alloc::string::String),
            }
        }
        impl ::prost::Name for InputArtifact {
            const NAME: &'static str = "InputArtifact";
            const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "google.cloud.aiplatform.v1.PipelineJob.RuntimeConfig.InputArtifact"
                    .into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.cloud.aiplatform.v1.PipelineJob.RuntimeConfig.InputArtifact"
                    .into()
            }
        }
    }
    impl ::prost::Name for RuntimeConfig {
        const NAME: &'static str = "RuntimeConfig";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.PipelineJob.RuntimeConfig".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.PipelineJob.RuntimeConfig"
                .into()
        }
    }
}
impl ::prost::Name for PipelineJob {
    const NAME: &'static str = "PipelineJob";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.PipelineJob".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.PipelineJob".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PipelineTemplateMetadata {
    #[prost(string, tag = "3")]
    pub version: ::prost::alloc::string::String,
}
impl ::prost::Name for PipelineTemplateMetadata {
    const NAME: &'static str = "PipelineTemplateMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.PipelineTemplateMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.PipelineTemplateMetadata".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PipelineJobDetail {
    #[prost(message, optional, tag = "1")]
    pub pipeline_context: ::core::option::Option<Context>,
    #[prost(message, optional, tag = "2")]
    pub pipeline_run_context: ::core::option::Option<Context>,
    #[prost(message, repeated, tag = "3")]
    pub task_details: ::prost::alloc::vec::Vec<PipelineTaskDetail>,
}
impl ::prost::Name for PipelineJobDetail {
    const NAME: &'static str = "PipelineJobDetail";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.PipelineJobDetail".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.PipelineJobDetail".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PipelineTaskDetail {
    #[prost(int64, tag = "1")]
    pub task_id: i64,
    #[prost(int64, tag = "12")]
    pub parent_task_id: i64,
    #[prost(string, tag = "2")]
    pub task_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "5")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub executor_detail: ::core::option::Option<PipelineTaskExecutorDetail>,
    #[prost(enumeration = "pipeline_task_detail::State", tag = "7")]
    pub state: i32,
    #[prost(message, optional, tag = "8")]
    pub execution: ::core::option::Option<Execution>,
    #[prost(message, optional, tag = "9")]
    pub error: ::core::option::Option<super::super::super::rpc::Status>,
    #[prost(message, repeated, tag = "13")]
    pub pipeline_task_status: ::prost::alloc::vec::Vec<
        pipeline_task_detail::PipelineTaskStatus,
    >,
    #[prost(map = "string, message", tag = "10")]
    pub inputs: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        pipeline_task_detail::ArtifactList,
    >,
    #[prost(map = "string, message", tag = "11")]
    pub outputs: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        pipeline_task_detail::ArtifactList,
    >,
    #[prost(string, tag = "14")]
    pub task_unique_name: ::prost::alloc::string::String,
}
/// Nested message and enum types in `PipelineTaskDetail`.
pub mod pipeline_task_detail {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PipelineTaskStatus {
        #[prost(message, optional, tag = "1")]
        pub update_time: ::core::option::Option<::prost_types::Timestamp>,
        #[prost(enumeration = "State", tag = "2")]
        pub state: i32,
        #[prost(message, optional, tag = "3")]
        pub error: ::core::option::Option<super::super::super::super::rpc::Status>,
    }
    impl ::prost::Name for PipelineTaskStatus {
        const NAME: &'static str = "PipelineTaskStatus";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.PipelineTaskDetail.PipelineTaskStatus".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.PipelineTaskDetail.PipelineTaskStatus"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ArtifactList {
        #[prost(message, repeated, tag = "1")]
        pub artifacts: ::prost::alloc::vec::Vec<super::Artifact>,
    }
    impl ::prost::Name for ArtifactList {
        const NAME: &'static str = "ArtifactList";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.PipelineTaskDetail.ArtifactList".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.PipelineTaskDetail.ArtifactList"
                .into()
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Pending = 1,
        Running = 2,
        Succeeded = 3,
        CancelPending = 4,
        Cancelling = 5,
        Cancelled = 6,
        Failed = 7,
        Skipped = 8,
        NotTriggered = 9,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Pending => "PENDING",
                Self::Running => "RUNNING",
                Self::Succeeded => "SUCCEEDED",
                Self::CancelPending => "CANCEL_PENDING",
                Self::Cancelling => "CANCELLING",
                Self::Cancelled => "CANCELLED",
                Self::Failed => "FAILED",
                Self::Skipped => "SKIPPED",
                Self::NotTriggered => "NOT_TRIGGERED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PENDING" => Some(Self::Pending),
                "RUNNING" => Some(Self::Running),
                "SUCCEEDED" => Some(Self::Succeeded),
                "CANCEL_PENDING" => Some(Self::CancelPending),
                "CANCELLING" => Some(Self::Cancelling),
                "CANCELLED" => Some(Self::Cancelled),
                "FAILED" => Some(Self::Failed),
                "SKIPPED" => Some(Self::Skipped),
                "NOT_TRIGGERED" => Some(Self::NotTriggered),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for PipelineTaskDetail {
    const NAME: &'static str = "PipelineTaskDetail";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.PipelineTaskDetail".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.PipelineTaskDetail".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PipelineTaskExecutorDetail {
    #[prost(oneof = "pipeline_task_executor_detail::Details", tags = "1, 2")]
    pub details: ::core::option::Option<pipeline_task_executor_detail::Details>,
}
/// Nested message and enum types in `PipelineTaskExecutorDetail`.
pub mod pipeline_task_executor_detail {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ContainerDetail {
        #[prost(string, tag = "1")]
        pub main_job: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub pre_caching_check_job: ::prost::alloc::string::String,
        #[prost(string, repeated, tag = "3")]
        pub failed_main_jobs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "4")]
        pub failed_pre_caching_check_jobs: ::prost::alloc::vec::Vec<
            ::prost::alloc::string::String,
        >,
    }
    impl ::prost::Name for ContainerDetail {
        const NAME: &'static str = "ContainerDetail";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.PipelineTaskExecutorDetail.ContainerDetail"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.PipelineTaskExecutorDetail.ContainerDetail"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CustomJobDetail {
        #[prost(string, tag = "1")]
        pub job: ::prost::alloc::string::String,
        #[prost(string, repeated, tag = "3")]
        pub failed_jobs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    impl ::prost::Name for CustomJobDetail {
        const NAME: &'static str = "CustomJobDetail";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.PipelineTaskExecutorDetail.CustomJobDetail"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.PipelineTaskExecutorDetail.CustomJobDetail"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Details {
        #[prost(message, tag = "1")]
        ContainerDetail(ContainerDetail),
        #[prost(message, tag = "2")]
        CustomJobDetail(CustomJobDetail),
    }
}
impl ::prost::Name for PipelineTaskExecutorDetail {
    const NAME: &'static str = "PipelineTaskExecutorDetail";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.PipelineTaskExecutorDetail".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.PipelineTaskExecutorDetail"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TrainingPipeline {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub input_data_config: ::core::option::Option<InputDataConfig>,
    #[prost(string, tag = "4")]
    pub training_task_definition: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub training_task_inputs: ::core::option::Option<::prost_types::Value>,
    #[prost(message, optional, tag = "6")]
    pub training_task_metadata: ::core::option::Option<::prost_types::Value>,
    #[prost(message, optional, tag = "7")]
    pub model_to_upload: ::core::option::Option<Model>,
    #[prost(string, tag = "22")]
    pub model_id: ::prost::alloc::string::String,
    #[prost(string, tag = "21")]
    pub parent_model: ::prost::alloc::string::String,
    #[prost(enumeration = "PipelineState", tag = "9")]
    pub state: i32,
    #[prost(message, optional, tag = "10")]
    pub error: ::core::option::Option<super::super::super::rpc::Status>,
    #[prost(message, optional, tag = "11")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "12")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "13")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "14")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "15")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "18")]
    pub encryption_spec: ::core::option::Option<EncryptionSpec>,
}
impl ::prost::Name for TrainingPipeline {
    const NAME: &'static str = "TrainingPipeline";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.TrainingPipeline".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.TrainingPipeline".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InputDataConfig {
    #[prost(string, tag = "1")]
    pub dataset_id: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub annotations_filter: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub annotation_schema_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub saved_query_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "11")]
    pub persist_ml_use_assignment: bool,
    #[prost(oneof = "input_data_config::Split", tags = "2, 3, 4, 5, 12")]
    pub split: ::core::option::Option<input_data_config::Split>,
    #[prost(oneof = "input_data_config::Destination", tags = "8, 10")]
    pub destination: ::core::option::Option<input_data_config::Destination>,
}
/// Nested message and enum types in `InputDataConfig`.
pub mod input_data_config {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Split {
        #[prost(message, tag = "2")]
        FractionSplit(super::FractionSplit),
        #[prost(message, tag = "3")]
        FilterSplit(super::FilterSplit),
        #[prost(message, tag = "4")]
        PredefinedSplit(super::PredefinedSplit),
        #[prost(message, tag = "5")]
        TimestampSplit(super::TimestampSplit),
        #[prost(message, tag = "12")]
        StratifiedSplit(super::StratifiedSplit),
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Destination {
        #[prost(message, tag = "8")]
        GcsDestination(super::GcsDestination),
        #[prost(message, tag = "10")]
        BigqueryDestination(super::BigQueryDestination),
    }
}
impl ::prost::Name for InputDataConfig {
    const NAME: &'static str = "InputDataConfig";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.InputDataConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.InputDataConfig".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FractionSplit {
    #[prost(double, tag = "1")]
    pub training_fraction: f64,
    #[prost(double, tag = "2")]
    pub validation_fraction: f64,
    #[prost(double, tag = "3")]
    pub test_fraction: f64,
}
impl ::prost::Name for FractionSplit {
    const NAME: &'static str = "FractionSplit";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.FractionSplit".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.FractionSplit".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FilterSplit {
    #[prost(string, tag = "1")]
    pub training_filter: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub validation_filter: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub test_filter: ::prost::alloc::string::String,
}
impl ::prost::Name for FilterSplit {
    const NAME: &'static str = "FilterSplit";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.FilterSplit".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.FilterSplit".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PredefinedSplit {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
}
impl ::prost::Name for PredefinedSplit {
    const NAME: &'static str = "PredefinedSplit";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.PredefinedSplit".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.PredefinedSplit".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimestampSplit {
    #[prost(double, tag = "1")]
    pub training_fraction: f64,
    #[prost(double, tag = "2")]
    pub validation_fraction: f64,
    #[prost(double, tag = "3")]
    pub test_fraction: f64,
    #[prost(string, tag = "4")]
    pub key: ::prost::alloc::string::String,
}
impl ::prost::Name for TimestampSplit {
    const NAME: &'static str = "TimestampSplit";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.TimestampSplit".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.TimestampSplit".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StratifiedSplit {
    #[prost(double, tag = "1")]
    pub training_fraction: f64,
    #[prost(double, tag = "2")]
    pub validation_fraction: f64,
    #[prost(double, tag = "3")]
    pub test_fraction: f64,
    #[prost(string, tag = "4")]
    pub key: ::prost::alloc::string::String,
}
impl ::prost::Name for StratifiedSplit {
    const NAME: &'static str = "StratifiedSplit";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.StratifiedSplit".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.StratifiedSplit".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCancelPipelineJobsOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for BatchCancelPipelineJobsOperationMetadata {
    const NAME: &'static str = "BatchCancelPipelineJobsOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.BatchCancelPipelineJobsOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchCancelPipelineJobsOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTrainingPipelineRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub training_pipeline: ::core::option::Option<TrainingPipeline>,
}
impl ::prost::Name for CreateTrainingPipelineRequest {
    const NAME: &'static str = "CreateTrainingPipelineRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateTrainingPipelineRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateTrainingPipelineRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTrainingPipelineRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for GetTrainingPipelineRequest {
    const NAME: &'static str = "GetTrainingPipelineRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetTrainingPipelineRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetTrainingPipelineRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTrainingPipelinesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for ListTrainingPipelinesRequest {
    const NAME: &'static str = "ListTrainingPipelinesRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListTrainingPipelinesRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListTrainingPipelinesRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTrainingPipelinesResponse {
    #[prost(message, repeated, tag = "1")]
    pub training_pipelines: ::prost::alloc::vec::Vec<TrainingPipeline>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListTrainingPipelinesResponse {
    const NAME: &'static str = "ListTrainingPipelinesResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListTrainingPipelinesResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListTrainingPipelinesResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteTrainingPipelineRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for DeleteTrainingPipelineRequest {
    const NAME: &'static str = "DeleteTrainingPipelineRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeleteTrainingPipelineRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteTrainingPipelineRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelTrainingPipelineRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for CancelTrainingPipelineRequest {
    const NAME: &'static str = "CancelTrainingPipelineRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CancelTrainingPipelineRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CancelTrainingPipelineRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreatePipelineJobRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub pipeline_job: ::core::option::Option<PipelineJob>,
    #[prost(string, tag = "3")]
    pub pipeline_job_id: ::prost::alloc::string::String,
}
impl ::prost::Name for CreatePipelineJobRequest {
    const NAME: &'static str = "CreatePipelineJobRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreatePipelineJobRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreatePipelineJobRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPipelineJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for GetPipelineJobRequest {
    const NAME: &'static str = "GetPipelineJobRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetPipelineJobRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetPipelineJobRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPipelineJobsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub order_by: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "7")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for ListPipelineJobsRequest {
    const NAME: &'static str = "ListPipelineJobsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListPipelineJobsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListPipelineJobsRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPipelineJobsResponse {
    #[prost(message, repeated, tag = "1")]
    pub pipeline_jobs: ::prost::alloc::vec::Vec<PipelineJob>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListPipelineJobsResponse {
    const NAME: &'static str = "ListPipelineJobsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListPipelineJobsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListPipelineJobsResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeletePipelineJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for DeletePipelineJobRequest {
    const NAME: &'static str = "DeletePipelineJobRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeletePipelineJobRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeletePipelineJobRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchDeletePipelineJobsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for BatchDeletePipelineJobsRequest {
    const NAME: &'static str = "BatchDeletePipelineJobsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.BatchDeletePipelineJobsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchDeletePipelineJobsRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchDeletePipelineJobsResponse {
    #[prost(message, repeated, tag = "1")]
    pub pipeline_jobs: ::prost::alloc::vec::Vec<PipelineJob>,
}
impl ::prost::Name for BatchDeletePipelineJobsResponse {
    const NAME: &'static str = "BatchDeletePipelineJobsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.BatchDeletePipelineJobsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchDeletePipelineJobsResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelPipelineJobRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for CancelPipelineJobRequest {
    const NAME: &'static str = "CancelPipelineJobRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CancelPipelineJobRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CancelPipelineJobRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCancelPipelineJobsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for BatchCancelPipelineJobsRequest {
    const NAME: &'static str = "BatchCancelPipelineJobsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.BatchCancelPipelineJobsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchCancelPipelineJobsRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCancelPipelineJobsResponse {
    #[prost(message, repeated, tag = "1")]
    pub pipeline_jobs: ::prost::alloc::vec::Vec<PipelineJob>,
}
impl ::prost::Name for BatchCancelPipelineJobsResponse {
    const NAME: &'static str = "BatchCancelPipelineJobsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.BatchCancelPipelineJobsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchCancelPipelineJobsResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReasoningEngineSpec {
    #[prost(string, optional, tag = "1")]
    pub service_account: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    pub package_spec: ::core::option::Option<reasoning_engine_spec::PackageSpec>,
    #[prost(message, optional, tag = "4")]
    pub deployment_spec: ::core::option::Option<reasoning_engine_spec::DeploymentSpec>,
    #[prost(message, repeated, tag = "3")]
    pub class_methods: ::prost::alloc::vec::Vec<::prost_types::Struct>,
    #[prost(string, tag = "5")]
    pub agent_framework: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ReasoningEngineSpec`.
pub mod reasoning_engine_spec {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PackageSpec {
        #[prost(string, tag = "1")]
        pub pickle_object_gcs_uri: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub dependency_files_gcs_uri: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub requirements_gcs_uri: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub python_version: ::prost::alloc::string::String,
    }
    impl ::prost::Name for PackageSpec {
        const NAME: &'static str = "PackageSpec";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.ReasoningEngineSpec.PackageSpec".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.ReasoningEngineSpec.PackageSpec"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DeploymentSpec {
        #[prost(message, repeated, tag = "1")]
        pub env: ::prost::alloc::vec::Vec<super::EnvVar>,
        #[prost(message, repeated, tag = "2")]
        pub secret_env: ::prost::alloc::vec::Vec<super::SecretEnvVar>,
        #[prost(message, optional, tag = "4")]
        pub psc_interface_config: ::core::option::Option<super::PscInterfaceConfig>,
        #[prost(int32, optional, tag = "5")]
        pub min_instances: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "6")]
        pub max_instances: ::core::option::Option<i32>,
        #[prost(map = "string, string", tag = "7")]
        pub resource_limits: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            ::prost::alloc::string::String,
        >,
        #[prost(int32, optional, tag = "8")]
        pub container_concurrency: ::core::option::Option<i32>,
    }
    impl ::prost::Name for DeploymentSpec {
        const NAME: &'static str = "DeploymentSpec";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.ReasoningEngineSpec.DeploymentSpec".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.ReasoningEngineSpec.DeploymentSpec"
                .into()
        }
    }
}
impl ::prost::Name for ReasoningEngineSpec {
    const NAME: &'static str = "ReasoningEngineSpec";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ReasoningEngineSpec".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ReasoningEngineSpec".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReasoningEngine {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub spec: ::core::option::Option<ReasoningEngineSpec>,
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "5")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "6")]
    pub etag: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "11")]
    pub encryption_spec: ::core::option::Option<EncryptionSpec>,
}
impl ::prost::Name for ReasoningEngine {
    const NAME: &'static str = "ReasoningEngine";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ReasoningEngine".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ReasoningEngine".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryReasoningEngineRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub input: ::core::option::Option<::prost_types::Struct>,
    #[prost(string, tag = "3")]
    pub class_method: ::prost::alloc::string::String,
}
impl ::prost::Name for QueryReasoningEngineRequest {
    const NAME: &'static str = "QueryReasoningEngineRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.QueryReasoningEngineRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.QueryReasoningEngineRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryReasoningEngineResponse {
    #[prost(message, optional, tag = "1")]
    pub output: ::core::option::Option<::prost_types::Value>,
}
impl ::prost::Name for QueryReasoningEngineResponse {
    const NAME: &'static str = "QueryReasoningEngineResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.QueryReasoningEngineResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.QueryReasoningEngineResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamQueryReasoningEngineRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub input: ::core::option::Option<::prost_types::Struct>,
    #[prost(string, tag = "3")]
    pub class_method: ::prost::alloc::string::String,
}
impl ::prost::Name for StreamQueryReasoningEngineRequest {
    const NAME: &'static str = "StreamQueryReasoningEngineRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.StreamQueryReasoningEngineRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.StreamQueryReasoningEngineRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateReasoningEngineRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub reasoning_engine: ::core::option::Option<ReasoningEngine>,
}
impl ::prost::Name for CreateReasoningEngineRequest {
    const NAME: &'static str = "CreateReasoningEngineRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateReasoningEngineRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateReasoningEngineRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateReasoningEngineOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for CreateReasoningEngineOperationMetadata {
    const NAME: &'static str = "CreateReasoningEngineOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateReasoningEngineOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateReasoningEngineOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetReasoningEngineRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for GetReasoningEngineRequest {
    const NAME: &'static str = "GetReasoningEngineRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetReasoningEngineRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetReasoningEngineRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateReasoningEngineRequest {
    #[prost(message, optional, tag = "1")]
    pub reasoning_engine: ::core::option::Option<ReasoningEngine>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for UpdateReasoningEngineRequest {
    const NAME: &'static str = "UpdateReasoningEngineRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdateReasoningEngineRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateReasoningEngineRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateReasoningEngineOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for UpdateReasoningEngineOperationMetadata {
    const NAME: &'static str = "UpdateReasoningEngineOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdateReasoningEngineOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateReasoningEngineOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListReasoningEnginesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListReasoningEnginesRequest {
    const NAME: &'static str = "ListReasoningEnginesRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListReasoningEnginesRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListReasoningEnginesRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListReasoningEnginesResponse {
    #[prost(message, repeated, tag = "1")]
    pub reasoning_engines: ::prost::alloc::vec::Vec<ReasoningEngine>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListReasoningEnginesResponse {
    const NAME: &'static str = "ListReasoningEnginesResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListReasoningEnginesResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListReasoningEnginesResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteReasoningEngineRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub force: bool,
}
impl ::prost::Name for DeleteReasoningEngineRequest {
    const NAME: &'static str = "DeleteReasoningEngineRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeleteReasoningEngineRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteReasoningEngineRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Schedule {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(int64, tag = "16")]
    pub max_run_count: i64,
    #[prost(int64, tag = "17")]
    pub started_run_count: i64,
    #[prost(enumeration = "schedule::State", tag = "5")]
    pub state: i32,
    #[prost(message, optional, tag = "6")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "19")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub next_run_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub last_pause_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub last_resume_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(int64, tag = "11")]
    pub max_concurrent_run_count: i64,
    #[prost(bool, tag = "12")]
    pub allow_queueing: bool,
    #[prost(bool, tag = "13")]
    pub catch_up: bool,
    #[prost(message, optional, tag = "18")]
    pub last_scheduled_run_response: ::core::option::Option<schedule::RunResponse>,
    #[prost(oneof = "schedule::TimeSpecification", tags = "10")]
    pub time_specification: ::core::option::Option<schedule::TimeSpecification>,
    #[prost(oneof = "schedule::Request", tags = "14, 20")]
    pub request: ::core::option::Option<schedule::Request>,
}
/// Nested message and enum types in `Schedule`.
pub mod schedule {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RunResponse {
        #[prost(message, optional, tag = "1")]
        pub scheduled_run_time: ::core::option::Option<::prost_types::Timestamp>,
        #[prost(string, tag = "2")]
        pub run_response: ::prost::alloc::string::String,
    }
    impl ::prost::Name for RunResponse {
        const NAME: &'static str = "RunResponse";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.Schedule.RunResponse".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.Schedule.RunResponse".into()
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Active = 1,
        Paused = 2,
        Completed = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::Paused => "PAUSED",
                Self::Completed => "COMPLETED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "PAUSED" => Some(Self::Paused),
                "COMPLETED" => Some(Self::Completed),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum TimeSpecification {
        #[prost(string, tag = "10")]
        Cron(::prost::alloc::string::String),
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Request {
        #[prost(message, tag = "14")]
        CreatePipelineJobRequest(super::CreatePipelineJobRequest),
        #[prost(message, tag = "20")]
        CreateNotebookExecutionJobRequest(super::CreateNotebookExecutionJobRequest),
    }
}
impl ::prost::Name for Schedule {
    const NAME: &'static str = "Schedule";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.Schedule".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.Schedule".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateScheduleRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub schedule: ::core::option::Option<Schedule>,
}
impl ::prost::Name for CreateScheduleRequest {
    const NAME: &'static str = "CreateScheduleRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateScheduleRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateScheduleRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetScheduleRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for GetScheduleRequest {
    const NAME: &'static str = "GetScheduleRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetScheduleRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetScheduleRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSchedulesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
impl ::prost::Name for ListSchedulesRequest {
    const NAME: &'static str = "ListSchedulesRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListSchedulesRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListSchedulesRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSchedulesResponse {
    #[prost(message, repeated, tag = "1")]
    pub schedules: ::prost::alloc::vec::Vec<Schedule>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListSchedulesResponse {
    const NAME: &'static str = "ListSchedulesResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListSchedulesResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListSchedulesResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteScheduleRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for DeleteScheduleRequest {
    const NAME: &'static str = "DeleteScheduleRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeleteScheduleRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteScheduleRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PauseScheduleRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for PauseScheduleRequest {
    const NAME: &'static str = "PauseScheduleRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.PauseScheduleRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.PauseScheduleRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResumeScheduleRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub catch_up: bool,
}
impl ::prost::Name for ResumeScheduleRequest {
    const NAME: &'static str = "ResumeScheduleRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ResumeScheduleRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ResumeScheduleRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateScheduleRequest {
    #[prost(message, optional, tag = "1")]
    pub schedule: ::core::option::Option<Schedule>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for UpdateScheduleRequest {
    const NAME: &'static str = "UpdateScheduleRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdateScheduleRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateScheduleRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpecialistPool {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub specialist_managers_count: i32,
    #[prost(string, repeated, tag = "4")]
    pub specialist_manager_emails: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(string, repeated, tag = "5")]
    pub pending_data_labeling_jobs: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(string, repeated, tag = "7")]
    pub specialist_worker_emails: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
}
impl ::prost::Name for SpecialistPool {
    const NAME: &'static str = "SpecialistPool";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SpecialistPool".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SpecialistPool".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSpecialistPoolRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub specialist_pool: ::core::option::Option<SpecialistPool>,
}
impl ::prost::Name for CreateSpecialistPoolRequest {
    const NAME: &'static str = "CreateSpecialistPoolRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateSpecialistPoolRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateSpecialistPoolRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSpecialistPoolOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for CreateSpecialistPoolOperationMetadata {
    const NAME: &'static str = "CreateSpecialistPoolOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateSpecialistPoolOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateSpecialistPoolOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSpecialistPoolRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for GetSpecialistPoolRequest {
    const NAME: &'static str = "GetSpecialistPoolRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetSpecialistPoolRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetSpecialistPoolRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSpecialistPoolsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for ListSpecialistPoolsRequest {
    const NAME: &'static str = "ListSpecialistPoolsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListSpecialistPoolsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListSpecialistPoolsRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSpecialistPoolsResponse {
    #[prost(message, repeated, tag = "1")]
    pub specialist_pools: ::prost::alloc::vec::Vec<SpecialistPool>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListSpecialistPoolsResponse {
    const NAME: &'static str = "ListSpecialistPoolsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListSpecialistPoolsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListSpecialistPoolsResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSpecialistPoolRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub force: bool,
}
impl ::prost::Name for DeleteSpecialistPoolRequest {
    const NAME: &'static str = "DeleteSpecialistPoolRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeleteSpecialistPoolRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteSpecialistPoolRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSpecialistPoolRequest {
    #[prost(message, optional, tag = "1")]
    pub specialist_pool: ::core::option::Option<SpecialistPool>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for UpdateSpecialistPoolRequest {
    const NAME: &'static str = "UpdateSpecialistPoolRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdateSpecialistPoolRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateSpecialistPoolRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSpecialistPoolOperationMetadata {
    #[prost(string, tag = "1")]
    pub specialist_pool: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for UpdateSpecialistPoolOperationMetadata {
    const NAME: &'static str = "UpdateSpecialistPoolOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdateSpecialistPoolOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateSpecialistPoolOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Tensorboard {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "11")]
    pub encryption_spec: ::core::option::Option<EncryptionSpec>,
    #[prost(string, tag = "10")]
    pub blob_storage_path_prefix: ::prost::alloc::string::String,
    #[prost(int32, tag = "5")]
    pub run_count: i32,
    #[prost(message, optional, tag = "6")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "8")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "9")]
    pub etag: ::prost::alloc::string::String,
    #[prost(bool, tag = "12")]
    pub is_default: bool,
    #[prost(bool, tag = "13")]
    pub satisfies_pzs: bool,
    #[prost(bool, tag = "14")]
    pub satisfies_pzi: bool,
}
impl ::prost::Name for Tensorboard {
    const NAME: &'static str = "Tensorboard";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.Tensorboard".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.Tensorboard".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TensorboardTimeSeries {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(enumeration = "tensorboard_time_series::ValueType", tag = "4")]
    pub value_type: i32,
    #[prost(message, optional, tag = "5")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "7")]
    pub etag: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub plugin_name: ::prost::alloc::string::String,
    #[prost(bytes = "bytes", tag = "9")]
    pub plugin_data: ::prost::bytes::Bytes,
    #[prost(message, optional, tag = "10")]
    pub metadata: ::core::option::Option<tensorboard_time_series::Metadata>,
}
/// Nested message and enum types in `TensorboardTimeSeries`.
pub mod tensorboard_time_series {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Metadata {
        #[prost(int64, tag = "1")]
        pub max_step: i64,
        #[prost(message, optional, tag = "2")]
        pub max_wall_time: ::core::option::Option<::prost_types::Timestamp>,
        #[prost(int64, tag = "3")]
        pub max_blob_sequence_length: i64,
    }
    impl ::prost::Name for Metadata {
        const NAME: &'static str = "Metadata";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.TensorboardTimeSeries.Metadata".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.TensorboardTimeSeries.Metadata"
                .into()
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ValueType {
        Unspecified = 0,
        Scalar = 1,
        Tensor = 2,
        BlobSequence = 3,
    }
    impl ValueType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "VALUE_TYPE_UNSPECIFIED",
                Self::Scalar => "SCALAR",
                Self::Tensor => "TENSOR",
                Self::BlobSequence => "BLOB_SEQUENCE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "VALUE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "SCALAR" => Some(Self::Scalar),
                "TENSOR" => Some(Self::Tensor),
                "BLOB_SEQUENCE" => Some(Self::BlobSequence),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for TensorboardTimeSeries {
    const NAME: &'static str = "TensorboardTimeSeries";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.TensorboardTimeSeries".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.TensorboardTimeSeries".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimeSeriesData {
    #[prost(string, tag = "1")]
    pub tensorboard_time_series_id: ::prost::alloc::string::String,
    #[prost(enumeration = "tensorboard_time_series::ValueType", tag = "2")]
    pub value_type: i32,
    #[prost(message, repeated, tag = "3")]
    pub values: ::prost::alloc::vec::Vec<TimeSeriesDataPoint>,
}
impl ::prost::Name for TimeSeriesData {
    const NAME: &'static str = "TimeSeriesData";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.TimeSeriesData".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.TimeSeriesData".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimeSeriesDataPoint {
    #[prost(message, optional, tag = "1")]
    pub wall_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(int64, tag = "2")]
    pub step: i64,
    #[prost(oneof = "time_series_data_point::Value", tags = "3, 4, 5")]
    pub value: ::core::option::Option<time_series_data_point::Value>,
}
/// Nested message and enum types in `TimeSeriesDataPoint`.
pub mod time_series_data_point {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(message, tag = "3")]
        Scalar(super::Scalar),
        #[prost(message, tag = "4")]
        Tensor(super::TensorboardTensor),
        #[prost(message, tag = "5")]
        Blobs(super::TensorboardBlobSequence),
    }
}
impl ::prost::Name for TimeSeriesDataPoint {
    const NAME: &'static str = "TimeSeriesDataPoint";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.TimeSeriesDataPoint".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.TimeSeriesDataPoint".into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Scalar {
    #[prost(double, tag = "1")]
    pub value: f64,
}
impl ::prost::Name for Scalar {
    const NAME: &'static str = "Scalar";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.Scalar".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.Scalar".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TensorboardTensor {
    #[prost(bytes = "bytes", tag = "1")]
    pub value: ::prost::bytes::Bytes,
    #[prost(int32, tag = "2")]
    pub version_number: i32,
}
impl ::prost::Name for TensorboardTensor {
    const NAME: &'static str = "TensorboardTensor";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.TensorboardTensor".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.TensorboardTensor".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TensorboardBlobSequence {
    #[prost(message, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<TensorboardBlob>,
}
impl ::prost::Name for TensorboardBlobSequence {
    const NAME: &'static str = "TensorboardBlobSequence";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.TensorboardBlobSequence".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.TensorboardBlobSequence".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TensorboardBlob {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(bytes = "bytes", tag = "2")]
    pub data: ::prost::bytes::Bytes,
}
impl ::prost::Name for TensorboardBlob {
    const NAME: &'static str = "TensorboardBlob";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.TensorboardBlob".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.TensorboardBlob".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TensorboardExperiment {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "5")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "6")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "7")]
    pub etag: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub source: ::prost::alloc::string::String,
}
impl ::prost::Name for TensorboardExperiment {
    const NAME: &'static str = "TensorboardExperiment";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.TensorboardExperiment".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.TensorboardExperiment".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TensorboardRun {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "8")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "9")]
    pub etag: ::prost::alloc::string::String,
}
impl ::prost::Name for TensorboardRun {
    const NAME: &'static str = "TensorboardRun";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.TensorboardRun".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.TensorboardRun".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTensorboardRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub tensorboard: ::core::option::Option<Tensorboard>,
}
impl ::prost::Name for CreateTensorboardRequest {
    const NAME: &'static str = "CreateTensorboardRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateTensorboardRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateTensorboardRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTensorboardRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for GetTensorboardRequest {
    const NAME: &'static str = "GetTensorboardRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetTensorboardRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetTensorboardRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTensorboardsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for ListTensorboardsRequest {
    const NAME: &'static str = "ListTensorboardsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListTensorboardsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListTensorboardsRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTensorboardsResponse {
    #[prost(message, repeated, tag = "1")]
    pub tensorboards: ::prost::alloc::vec::Vec<Tensorboard>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListTensorboardsResponse {
    const NAME: &'static str = "ListTensorboardsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListTensorboardsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListTensorboardsResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateTensorboardRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub tensorboard: ::core::option::Option<Tensorboard>,
}
impl ::prost::Name for UpdateTensorboardRequest {
    const NAME: &'static str = "UpdateTensorboardRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdateTensorboardRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateTensorboardRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteTensorboardRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for DeleteTensorboardRequest {
    const NAME: &'static str = "DeleteTensorboardRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeleteTensorboardRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteTensorboardRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadTensorboardUsageRequest {
    #[prost(string, tag = "1")]
    pub tensorboard: ::prost::alloc::string::String,
}
impl ::prost::Name for ReadTensorboardUsageRequest {
    const NAME: &'static str = "ReadTensorboardUsageRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ReadTensorboardUsageRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ReadTensorboardUsageRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadTensorboardUsageResponse {
    #[prost(map = "string, message", tag = "1")]
    pub monthly_usage_data: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        read_tensorboard_usage_response::PerMonthUsageData,
    >,
}
/// Nested message and enum types in `ReadTensorboardUsageResponse`.
pub mod read_tensorboard_usage_response {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PerUserUsageData {
        #[prost(string, tag = "1")]
        pub username: ::prost::alloc::string::String,
        #[prost(int64, tag = "2")]
        pub view_count: i64,
    }
    impl ::prost::Name for PerUserUsageData {
        const NAME: &'static str = "PerUserUsageData";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.ReadTensorboardUsageResponse.PerUserUsageData"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.ReadTensorboardUsageResponse.PerUserUsageData"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PerMonthUsageData {
        #[prost(message, repeated, tag = "1")]
        pub user_usage_data: ::prost::alloc::vec::Vec<PerUserUsageData>,
    }
    impl ::prost::Name for PerMonthUsageData {
        const NAME: &'static str = "PerMonthUsageData";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.ReadTensorboardUsageResponse.PerMonthUsageData"
                .into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.ReadTensorboardUsageResponse.PerMonthUsageData"
                .into()
        }
    }
}
impl ::prost::Name for ReadTensorboardUsageResponse {
    const NAME: &'static str = "ReadTensorboardUsageResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ReadTensorboardUsageResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ReadTensorboardUsageResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadTensorboardSizeRequest {
    #[prost(string, tag = "1")]
    pub tensorboard: ::prost::alloc::string::String,
}
impl ::prost::Name for ReadTensorboardSizeRequest {
    const NAME: &'static str = "ReadTensorboardSizeRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ReadTensorboardSizeRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ReadTensorboardSizeRequest"
            .into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReadTensorboardSizeResponse {
    #[prost(int64, tag = "1")]
    pub storage_size_byte: i64,
}
impl ::prost::Name for ReadTensorboardSizeResponse {
    const NAME: &'static str = "ReadTensorboardSizeResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ReadTensorboardSizeResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ReadTensorboardSizeResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTensorboardExperimentRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub tensorboard_experiment: ::core::option::Option<TensorboardExperiment>,
    #[prost(string, tag = "3")]
    pub tensorboard_experiment_id: ::prost::alloc::string::String,
}
impl ::prost::Name for CreateTensorboardExperimentRequest {
    const NAME: &'static str = "CreateTensorboardExperimentRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateTensorboardExperimentRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateTensorboardExperimentRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTensorboardExperimentRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for GetTensorboardExperimentRequest {
    const NAME: &'static str = "GetTensorboardExperimentRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetTensorboardExperimentRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetTensorboardExperimentRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTensorboardExperimentsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for ListTensorboardExperimentsRequest {
    const NAME: &'static str = "ListTensorboardExperimentsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListTensorboardExperimentsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListTensorboardExperimentsRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTensorboardExperimentsResponse {
    #[prost(message, repeated, tag = "1")]
    pub tensorboard_experiments: ::prost::alloc::vec::Vec<TensorboardExperiment>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListTensorboardExperimentsResponse {
    const NAME: &'static str = "ListTensorboardExperimentsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListTensorboardExperimentsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListTensorboardExperimentsResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateTensorboardExperimentRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub tensorboard_experiment: ::core::option::Option<TensorboardExperiment>,
}
impl ::prost::Name for UpdateTensorboardExperimentRequest {
    const NAME: &'static str = "UpdateTensorboardExperimentRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdateTensorboardExperimentRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateTensorboardExperimentRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteTensorboardExperimentRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for DeleteTensorboardExperimentRequest {
    const NAME: &'static str = "DeleteTensorboardExperimentRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeleteTensorboardExperimentRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteTensorboardExperimentRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateTensorboardRunsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub requests: ::prost::alloc::vec::Vec<CreateTensorboardRunRequest>,
}
impl ::prost::Name for BatchCreateTensorboardRunsRequest {
    const NAME: &'static str = "BatchCreateTensorboardRunsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.BatchCreateTensorboardRunsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchCreateTensorboardRunsRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateTensorboardRunsResponse {
    #[prost(message, repeated, tag = "1")]
    pub tensorboard_runs: ::prost::alloc::vec::Vec<TensorboardRun>,
}
impl ::prost::Name for BatchCreateTensorboardRunsResponse {
    const NAME: &'static str = "BatchCreateTensorboardRunsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.BatchCreateTensorboardRunsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchCreateTensorboardRunsResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTensorboardRunRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub tensorboard_run: ::core::option::Option<TensorboardRun>,
    #[prost(string, tag = "3")]
    pub tensorboard_run_id: ::prost::alloc::string::String,
}
impl ::prost::Name for CreateTensorboardRunRequest {
    const NAME: &'static str = "CreateTensorboardRunRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateTensorboardRunRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateTensorboardRunRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTensorboardRunRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for GetTensorboardRunRequest {
    const NAME: &'static str = "GetTensorboardRunRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetTensorboardRunRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetTensorboardRunRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadTensorboardBlobDataRequest {
    #[prost(string, tag = "1")]
    pub time_series: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub blob_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for ReadTensorboardBlobDataRequest {
    const NAME: &'static str = "ReadTensorboardBlobDataRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ReadTensorboardBlobDataRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ReadTensorboardBlobDataRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadTensorboardBlobDataResponse {
    #[prost(message, repeated, tag = "1")]
    pub blobs: ::prost::alloc::vec::Vec<TensorboardBlob>,
}
impl ::prost::Name for ReadTensorboardBlobDataResponse {
    const NAME: &'static str = "ReadTensorboardBlobDataResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ReadTensorboardBlobDataResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ReadTensorboardBlobDataResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTensorboardRunsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for ListTensorboardRunsRequest {
    const NAME: &'static str = "ListTensorboardRunsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListTensorboardRunsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListTensorboardRunsRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTensorboardRunsResponse {
    #[prost(message, repeated, tag = "1")]
    pub tensorboard_runs: ::prost::alloc::vec::Vec<TensorboardRun>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListTensorboardRunsResponse {
    const NAME: &'static str = "ListTensorboardRunsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListTensorboardRunsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListTensorboardRunsResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateTensorboardRunRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub tensorboard_run: ::core::option::Option<TensorboardRun>,
}
impl ::prost::Name for UpdateTensorboardRunRequest {
    const NAME: &'static str = "UpdateTensorboardRunRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdateTensorboardRunRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateTensorboardRunRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteTensorboardRunRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for DeleteTensorboardRunRequest {
    const NAME: &'static str = "DeleteTensorboardRunRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeleteTensorboardRunRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteTensorboardRunRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateTensorboardTimeSeriesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub requests: ::prost::alloc::vec::Vec<CreateTensorboardTimeSeriesRequest>,
}
impl ::prost::Name for BatchCreateTensorboardTimeSeriesRequest {
    const NAME: &'static str = "BatchCreateTensorboardTimeSeriesRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.BatchCreateTensorboardTimeSeriesRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchCreateTensorboardTimeSeriesRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateTensorboardTimeSeriesResponse {
    #[prost(message, repeated, tag = "1")]
    pub tensorboard_time_series: ::prost::alloc::vec::Vec<TensorboardTimeSeries>,
}
impl ::prost::Name for BatchCreateTensorboardTimeSeriesResponse {
    const NAME: &'static str = "BatchCreateTensorboardTimeSeriesResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.BatchCreateTensorboardTimeSeriesResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchCreateTensorboardTimeSeriesResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTensorboardTimeSeriesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub tensorboard_time_series_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub tensorboard_time_series: ::core::option::Option<TensorboardTimeSeries>,
}
impl ::prost::Name for CreateTensorboardTimeSeriesRequest {
    const NAME: &'static str = "CreateTensorboardTimeSeriesRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateTensorboardTimeSeriesRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateTensorboardTimeSeriesRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTensorboardTimeSeriesRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for GetTensorboardTimeSeriesRequest {
    const NAME: &'static str = "GetTensorboardTimeSeriesRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetTensorboardTimeSeriesRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetTensorboardTimeSeriesRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTensorboardTimeSeriesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub read_mask: ::core::option::Option<::prost_types::FieldMask>,
}
impl ::prost::Name for ListTensorboardTimeSeriesRequest {
    const NAME: &'static str = "ListTensorboardTimeSeriesRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListTensorboardTimeSeriesRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListTensorboardTimeSeriesRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTensorboardTimeSeriesResponse {
    #[prost(message, repeated, tag = "1")]
    pub tensorboard_time_series: ::prost::alloc::vec::Vec<TensorboardTimeSeries>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListTensorboardTimeSeriesResponse {
    const NAME: &'static str = "ListTensorboardTimeSeriesResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListTensorboardTimeSeriesResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListTensorboardTimeSeriesResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateTensorboardTimeSeriesRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub tensorboard_time_series: ::core::option::Option<TensorboardTimeSeries>,
}
impl ::prost::Name for UpdateTensorboardTimeSeriesRequest {
    const NAME: &'static str = "UpdateTensorboardTimeSeriesRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdateTensorboardTimeSeriesRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateTensorboardTimeSeriesRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteTensorboardTimeSeriesRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for DeleteTensorboardTimeSeriesRequest {
    const NAME: &'static str = "DeleteTensorboardTimeSeriesRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeleteTensorboardTimeSeriesRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteTensorboardTimeSeriesRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchReadTensorboardTimeSeriesDataRequest {
    #[prost(string, tag = "1")]
    pub tensorboard: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub time_series: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for BatchReadTensorboardTimeSeriesDataRequest {
    const NAME: &'static str = "BatchReadTensorboardTimeSeriesDataRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.BatchReadTensorboardTimeSeriesDataRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchReadTensorboardTimeSeriesDataRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchReadTensorboardTimeSeriesDataResponse {
    #[prost(message, repeated, tag = "1")]
    pub time_series_data: ::prost::alloc::vec::Vec<TimeSeriesData>,
}
impl ::prost::Name for BatchReadTensorboardTimeSeriesDataResponse {
    const NAME: &'static str = "BatchReadTensorboardTimeSeriesDataResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.BatchReadTensorboardTimeSeriesDataResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.BatchReadTensorboardTimeSeriesDataResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadTensorboardTimeSeriesDataRequest {
    #[prost(string, tag = "1")]
    pub tensorboard_time_series: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub max_data_points: i32,
    #[prost(string, tag = "3")]
    pub filter: ::prost::alloc::string::String,
}
impl ::prost::Name for ReadTensorboardTimeSeriesDataRequest {
    const NAME: &'static str = "ReadTensorboardTimeSeriesDataRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ReadTensorboardTimeSeriesDataRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ReadTensorboardTimeSeriesDataRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadTensorboardTimeSeriesDataResponse {
    #[prost(message, optional, tag = "1")]
    pub time_series_data: ::core::option::Option<TimeSeriesData>,
}
impl ::prost::Name for ReadTensorboardTimeSeriesDataResponse {
    const NAME: &'static str = "ReadTensorboardTimeSeriesDataResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ReadTensorboardTimeSeriesDataResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ReadTensorboardTimeSeriesDataResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteTensorboardExperimentDataRequest {
    #[prost(string, tag = "1")]
    pub tensorboard_experiment: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub write_run_data_requests: ::prost::alloc::vec::Vec<
        WriteTensorboardRunDataRequest,
    >,
}
impl ::prost::Name for WriteTensorboardExperimentDataRequest {
    const NAME: &'static str = "WriteTensorboardExperimentDataRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.WriteTensorboardExperimentDataRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.WriteTensorboardExperimentDataRequest"
            .into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WriteTensorboardExperimentDataResponse {}
impl ::prost::Name for WriteTensorboardExperimentDataResponse {
    const NAME: &'static str = "WriteTensorboardExperimentDataResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.WriteTensorboardExperimentDataResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.WriteTensorboardExperimentDataResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteTensorboardRunDataRequest {
    #[prost(string, tag = "1")]
    pub tensorboard_run: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub time_series_data: ::prost::alloc::vec::Vec<TimeSeriesData>,
}
impl ::prost::Name for WriteTensorboardRunDataRequest {
    const NAME: &'static str = "WriteTensorboardRunDataRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.WriteTensorboardRunDataRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.WriteTensorboardRunDataRequest"
            .into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WriteTensorboardRunDataResponse {}
impl ::prost::Name for WriteTensorboardRunDataResponse {
    const NAME: &'static str = "WriteTensorboardRunDataResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.WriteTensorboardRunDataResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.WriteTensorboardRunDataResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportTensorboardTimeSeriesDataRequest {
    #[prost(string, tag = "1")]
    pub tensorboard_time_series: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
impl ::prost::Name for ExportTensorboardTimeSeriesDataRequest {
    const NAME: &'static str = "ExportTensorboardTimeSeriesDataRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ExportTensorboardTimeSeriesDataRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExportTensorboardTimeSeriesDataRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportTensorboardTimeSeriesDataResponse {
    #[prost(message, repeated, tag = "1")]
    pub time_series_data_points: ::prost::alloc::vec::Vec<TimeSeriesDataPoint>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ExportTensorboardTimeSeriesDataResponse {
    const NAME: &'static str = "ExportTensorboardTimeSeriesDataResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ExportTensorboardTimeSeriesDataResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ExportTensorboardTimeSeriesDataResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTensorboardOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for CreateTensorboardOperationMetadata {
    const NAME: &'static str = "CreateTensorboardOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateTensorboardOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateTensorboardOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateTensorboardOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for UpdateTensorboardOperationMetadata {
    const NAME: &'static str = "UpdateTensorboardOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdateTensorboardOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateTensorboardOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateRagCorpusRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub rag_corpus: ::core::option::Option<RagCorpus>,
}
impl ::prost::Name for CreateRagCorpusRequest {
    const NAME: &'static str = "CreateRagCorpusRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateRagCorpusRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateRagCorpusRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRagCorpusRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for GetRagCorpusRequest {
    const NAME: &'static str = "GetRagCorpusRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetRagCorpusRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetRagCorpusRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRagCorporaRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListRagCorporaRequest {
    const NAME: &'static str = "ListRagCorporaRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListRagCorporaRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListRagCorporaRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRagCorporaResponse {
    #[prost(message, repeated, tag = "1")]
    pub rag_corpora: ::prost::alloc::vec::Vec<RagCorpus>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListRagCorporaResponse {
    const NAME: &'static str = "ListRagCorporaResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListRagCorporaResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListRagCorporaResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRagCorpusRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub force: bool,
}
impl ::prost::Name for DeleteRagCorpusRequest {
    const NAME: &'static str = "DeleteRagCorpusRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeleteRagCorpusRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteRagCorpusRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadRagFileRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub rag_file: ::core::option::Option<RagFile>,
    #[prost(message, optional, tag = "5")]
    pub upload_rag_file_config: ::core::option::Option<UploadRagFileConfig>,
}
impl ::prost::Name for UploadRagFileRequest {
    const NAME: &'static str = "UploadRagFileRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UploadRagFileRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UploadRagFileRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UploadRagFileResponse {
    #[prost(oneof = "upload_rag_file_response::Result", tags = "1, 4")]
    pub result: ::core::option::Option<upload_rag_file_response::Result>,
}
/// Nested message and enum types in `UploadRagFileResponse`.
pub mod upload_rag_file_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(message, tag = "1")]
        RagFile(super::RagFile),
        #[prost(message, tag = "4")]
        Error(super::super::super::super::rpc::Status),
    }
}
impl ::prost::Name for UploadRagFileResponse {
    const NAME: &'static str = "UploadRagFileResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UploadRagFileResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UploadRagFileResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportRagFilesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub import_rag_files_config: ::core::option::Option<ImportRagFilesConfig>,
}
impl ::prost::Name for ImportRagFilesRequest {
    const NAME: &'static str = "ImportRagFilesRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ImportRagFilesRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ImportRagFilesRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportRagFilesResponse {
    #[prost(int64, tag = "1")]
    pub imported_rag_files_count: i64,
    #[prost(int64, tag = "2")]
    pub failed_rag_files_count: i64,
    #[prost(int64, tag = "3")]
    pub skipped_rag_files_count: i64,
    #[prost(oneof = "import_rag_files_response::PartialFailureSink", tags = "4, 5")]
    pub partial_failure_sink: ::core::option::Option<
        import_rag_files_response::PartialFailureSink,
    >,
}
/// Nested message and enum types in `ImportRagFilesResponse`.
pub mod import_rag_files_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum PartialFailureSink {
        #[prost(string, tag = "4")]
        PartialFailuresGcsPath(::prost::alloc::string::String),
        #[prost(string, tag = "5")]
        PartialFailuresBigqueryTable(::prost::alloc::string::String),
    }
}
impl ::prost::Name for ImportRagFilesResponse {
    const NAME: &'static str = "ImportRagFilesResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ImportRagFilesResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ImportRagFilesResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRagFileRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for GetRagFileRequest {
    const NAME: &'static str = "GetRagFileRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetRagFileRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetRagFileRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRagFilesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListRagFilesRequest {
    const NAME: &'static str = "ListRagFilesRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListRagFilesRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListRagFilesRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRagFilesResponse {
    #[prost(message, repeated, tag = "1")]
    pub rag_files: ::prost::alloc::vec::Vec<RagFile>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListRagFilesResponse {
    const NAME: &'static str = "ListRagFilesResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListRagFilesResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListRagFilesResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRagFileRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for DeleteRagFileRequest {
    const NAME: &'static str = "DeleteRagFileRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeleteRagFileRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteRagFileRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateRagCorpusOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for CreateRagCorpusOperationMetadata {
    const NAME: &'static str = "CreateRagCorpusOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateRagCorpusOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateRagCorpusOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRagEngineConfigRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for GetRagEngineConfigRequest {
    const NAME: &'static str = "GetRagEngineConfigRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetRagEngineConfigRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetRagEngineConfigRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateRagCorpusRequest {
    #[prost(message, optional, tag = "1")]
    pub rag_corpus: ::core::option::Option<RagCorpus>,
}
impl ::prost::Name for UpdateRagCorpusRequest {
    const NAME: &'static str = "UpdateRagCorpusRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdateRagCorpusRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateRagCorpusRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateRagCorpusOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for UpdateRagCorpusOperationMetadata {
    const NAME: &'static str = "UpdateRagCorpusOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdateRagCorpusOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateRagCorpusOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportRagFilesOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
    #[prost(int64, tag = "2")]
    pub rag_corpus_id: i64,
    #[prost(message, optional, tag = "3")]
    pub import_rag_files_config: ::core::option::Option<ImportRagFilesConfig>,
    #[prost(int32, tag = "4")]
    pub progress_percentage: i32,
}
impl ::prost::Name for ImportRagFilesOperationMetadata {
    const NAME: &'static str = "ImportRagFilesOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ImportRagFilesOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ImportRagFilesOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateRagEngineConfigRequest {
    #[prost(message, optional, tag = "1")]
    pub rag_engine_config: ::core::option::Option<RagEngineConfig>,
}
impl ::prost::Name for UpdateRagEngineConfigRequest {
    const NAME: &'static str = "UpdateRagEngineConfigRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdateRagEngineConfigRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateRagEngineConfigRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateRagEngineConfigOperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
}
impl ::prost::Name for UpdateRagEngineConfigOperationMetadata {
    const NAME: &'static str = "UpdateRagEngineConfigOperationMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.UpdateRagEngineConfigOperationMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.UpdateRagEngineConfigOperationMetadata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RagQuery {
    #[prost(message, optional, tag = "6")]
    pub rag_retrieval_config: ::core::option::Option<RagRetrievalConfig>,
    #[prost(oneof = "rag_query::Query", tags = "1")]
    pub query: ::core::option::Option<rag_query::Query>,
}
/// Nested message and enum types in `RagQuery`.
pub mod rag_query {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Query {
        #[prost(string, tag = "1")]
        Text(::prost::alloc::string::String),
    }
}
impl ::prost::Name for RagQuery {
    const NAME: &'static str = "RagQuery";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.RagQuery".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.RagQuery".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RetrieveContextsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub query: ::core::option::Option<RagQuery>,
    #[prost(oneof = "retrieve_contexts_request::DataSource", tags = "2")]
    pub data_source: ::core::option::Option<retrieve_contexts_request::DataSource>,
}
/// Nested message and enum types in `RetrieveContextsRequest`.
pub mod retrieve_contexts_request {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct VertexRagStore {
        #[prost(message, repeated, tag = "3")]
        pub rag_resources: ::prost::alloc::vec::Vec<vertex_rag_store::RagResource>,
        #[deprecated]
        #[prost(double, optional, tag = "2")]
        pub vector_distance_threshold: ::core::option::Option<f64>,
    }
    /// Nested message and enum types in `VertexRagStore`.
    pub mod vertex_rag_store {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct RagResource {
            #[prost(string, tag = "1")]
            pub rag_corpus: ::prost::alloc::string::String,
            #[prost(string, repeated, tag = "2")]
            pub rag_file_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
        impl ::prost::Name for RagResource {
            const NAME: &'static str = "RagResource";
            const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
            fn full_name() -> ::prost::alloc::string::String {
                "google.cloud.aiplatform.v1.RetrieveContextsRequest.VertexRagStore.RagResource"
                    .into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "type.googleapis.com/google.cloud.aiplatform.v1.RetrieveContextsRequest.VertexRagStore.RagResource"
                    .into()
            }
        }
    }
    impl ::prost::Name for VertexRagStore {
        const NAME: &'static str = "VertexRagStore";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.RetrieveContextsRequest.VertexRagStore".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.RetrieveContextsRequest.VertexRagStore"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum DataSource {
        #[prost(message, tag = "2")]
        VertexRagStore(VertexRagStore),
    }
}
impl ::prost::Name for RetrieveContextsRequest {
    const NAME: &'static str = "RetrieveContextsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.RetrieveContextsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.RetrieveContextsRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RagContexts {
    #[prost(message, repeated, tag = "1")]
    pub contexts: ::prost::alloc::vec::Vec<rag_contexts::Context>,
}
/// Nested message and enum types in `RagContexts`.
pub mod rag_contexts {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Context {
        #[prost(string, tag = "1")]
        pub source_uri: ::prost::alloc::string::String,
        #[prost(string, tag = "5")]
        pub source_display_name: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub text: ::prost::alloc::string::String,
        #[prost(double, optional, tag = "6")]
        pub score: ::core::option::Option<f64>,
        #[prost(message, optional, tag = "7")]
        pub chunk: ::core::option::Option<super::RagChunk>,
    }
    impl ::prost::Name for Context {
        const NAME: &'static str = "Context";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.RagContexts.Context".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.RagContexts.Context".into()
        }
    }
}
impl ::prost::Name for RagContexts {
    const NAME: &'static str = "RagContexts";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.RagContexts".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.RagContexts".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RetrieveContextsResponse {
    #[prost(message, optional, tag = "1")]
    pub contexts: ::core::option::Option<RagContexts>,
}
impl ::prost::Name for RetrieveContextsResponse {
    const NAME: &'static str = "RetrieveContextsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.RetrieveContextsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.RetrieveContextsResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AugmentPromptRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub contents: ::prost::alloc::vec::Vec<Content>,
    #[prost(message, optional, tag = "3")]
    pub model: ::core::option::Option<augment_prompt_request::Model>,
    #[prost(oneof = "augment_prompt_request::DataSource", tags = "4")]
    pub data_source: ::core::option::Option<augment_prompt_request::DataSource>,
}
/// Nested message and enum types in `AugmentPromptRequest`.
pub mod augment_prompt_request {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Model {
        #[prost(string, tag = "1")]
        pub model: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub model_version: ::prost::alloc::string::String,
    }
    impl ::prost::Name for Model {
        const NAME: &'static str = "Model";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.AugmentPromptRequest.Model".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.AugmentPromptRequest.Model"
                .into()
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum DataSource {
        #[prost(message, tag = "4")]
        VertexRagStore(super::VertexRagStore),
    }
}
impl ::prost::Name for AugmentPromptRequest {
    const NAME: &'static str = "AugmentPromptRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.AugmentPromptRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.AugmentPromptRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AugmentPromptResponse {
    #[prost(message, repeated, tag = "1")]
    pub augmented_prompt: ::prost::alloc::vec::Vec<Content>,
    #[prost(message, repeated, tag = "2")]
    pub facts: ::prost::alloc::vec::Vec<Fact>,
}
impl ::prost::Name for AugmentPromptResponse {
    const NAME: &'static str = "AugmentPromptResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.AugmentPromptResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.AugmentPromptResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CorroborateContentRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub content: ::core::option::Option<Content>,
    #[prost(message, repeated, tag = "3")]
    pub facts: ::prost::alloc::vec::Vec<Fact>,
    #[prost(message, optional, tag = "4")]
    pub parameters: ::core::option::Option<corroborate_content_request::Parameters>,
}
/// Nested message and enum types in `CorroborateContentRequest`.
pub mod corroborate_content_request {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Parameters {
        #[prost(double, tag = "1")]
        pub citation_threshold: f64,
    }
    impl ::prost::Name for Parameters {
        const NAME: &'static str = "Parameters";
        const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "google.cloud.aiplatform.v1.CorroborateContentRequest.Parameters".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "type.googleapis.com/google.cloud.aiplatform.v1.CorroborateContentRequest.Parameters"
                .into()
        }
    }
}
impl ::prost::Name for CorroborateContentRequest {
    const NAME: &'static str = "CorroborateContentRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CorroborateContentRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CorroborateContentRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CorroborateContentResponse {
    #[prost(float, optional, tag = "1")]
    pub corroboration_score: ::core::option::Option<f32>,
    #[prost(message, repeated, tag = "2")]
    pub claims: ::prost::alloc::vec::Vec<Claim>,
}
impl ::prost::Name for CorroborateContentResponse {
    const NAME: &'static str = "CorroborateContentResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CorroborateContentResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CorroborateContentResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Fact {
    #[prost(string, optional, tag = "1")]
    pub query: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub title: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub uri: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub summary: ::core::option::Option<::prost::alloc::string::String>,
    #[deprecated]
    #[prost(double, optional, tag = "5")]
    pub vector_distance: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "6")]
    pub score: ::core::option::Option<f64>,
    #[prost(message, optional, tag = "7")]
    pub chunk: ::core::option::Option<RagChunk>,
}
impl ::prost::Name for Fact {
    const NAME: &'static str = "Fact";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.Fact".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.Fact".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Claim {
    #[prost(int32, optional, tag = "1")]
    pub start_index: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub end_index: ::core::option::Option<i32>,
    #[prost(int32, repeated, tag = "3")]
    pub fact_indexes: ::prost::alloc::vec::Vec<i32>,
    #[prost(float, optional, tag = "4")]
    pub score: ::core::option::Option<f32>,
}
impl ::prost::Name for Claim {
    const NAME: &'static str = "Claim";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.Claim".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.Claim".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStudyRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for GetStudyRequest {
    const NAME: &'static str = "GetStudyRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetStudyRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetStudyRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateStudyRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub study: ::core::option::Option<Study>,
}
impl ::prost::Name for CreateStudyRequest {
    const NAME: &'static str = "CreateStudyRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateStudyRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateStudyRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListStudiesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
}
impl ::prost::Name for ListStudiesRequest {
    const NAME: &'static str = "ListStudiesRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListStudiesRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListStudiesRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListStudiesResponse {
    #[prost(message, repeated, tag = "1")]
    pub studies: ::prost::alloc::vec::Vec<Study>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListStudiesResponse {
    const NAME: &'static str = "ListStudiesResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListStudiesResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListStudiesResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteStudyRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for DeleteStudyRequest {
    const NAME: &'static str = "DeleteStudyRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeleteStudyRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteStudyRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupStudyRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
}
impl ::prost::Name for LookupStudyRequest {
    const NAME: &'static str = "LookupStudyRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.LookupStudyRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.LookupStudyRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestTrialsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub suggestion_count: i32,
    #[prost(string, tag = "3")]
    pub client_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "4")]
    pub contexts: ::prost::alloc::vec::Vec<TrialContext>,
}
impl ::prost::Name for SuggestTrialsRequest {
    const NAME: &'static str = "SuggestTrialsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SuggestTrialsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SuggestTrialsRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestTrialsResponse {
    #[prost(message, repeated, tag = "1")]
    pub trials: ::prost::alloc::vec::Vec<Trial>,
    #[prost(enumeration = "study::State", tag = "2")]
    pub study_state: i32,
    #[prost(message, optional, tag = "3")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
}
impl ::prost::Name for SuggestTrialsResponse {
    const NAME: &'static str = "SuggestTrialsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SuggestTrialsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SuggestTrialsResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuggestTrialsMetadata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
    #[prost(string, tag = "2")]
    pub client_id: ::prost::alloc::string::String,
}
impl ::prost::Name for SuggestTrialsMetadata {
    const NAME: &'static str = "SuggestTrialsMetadata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.SuggestTrialsMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.SuggestTrialsMetadata".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTrialRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub trial: ::core::option::Option<Trial>,
}
impl ::prost::Name for CreateTrialRequest {
    const NAME: &'static str = "CreateTrialRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CreateTrialRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CreateTrialRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTrialRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for GetTrialRequest {
    const NAME: &'static str = "GetTrialRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.GetTrialRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.GetTrialRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTrialsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
}
impl ::prost::Name for ListTrialsRequest {
    const NAME: &'static str = "ListTrialsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListTrialsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListTrialsRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTrialsResponse {
    #[prost(message, repeated, tag = "1")]
    pub trials: ::prost::alloc::vec::Vec<Trial>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
impl ::prost::Name for ListTrialsResponse {
    const NAME: &'static str = "ListTrialsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListTrialsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListTrialsResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddTrialMeasurementRequest {
    #[prost(string, tag = "1")]
    pub trial_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub measurement: ::core::option::Option<Measurement>,
}
impl ::prost::Name for AddTrialMeasurementRequest {
    const NAME: &'static str = "AddTrialMeasurementRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.AddTrialMeasurementRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.AddTrialMeasurementRequest"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompleteTrialRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub final_measurement: ::core::option::Option<Measurement>,
    #[prost(bool, tag = "3")]
    pub trial_infeasible: bool,
    #[prost(string, tag = "4")]
    pub infeasible_reason: ::prost::alloc::string::String,
}
impl ::prost::Name for CompleteTrialRequest {
    const NAME: &'static str = "CompleteTrialRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CompleteTrialRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CompleteTrialRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteTrialRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for DeleteTrialRequest {
    const NAME: &'static str = "DeleteTrialRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.DeleteTrialRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.DeleteTrialRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckTrialEarlyStoppingStateRequest {
    #[prost(string, tag = "1")]
    pub trial_name: ::prost::alloc::string::String,
}
impl ::prost::Name for CheckTrialEarlyStoppingStateRequest {
    const NAME: &'static str = "CheckTrialEarlyStoppingStateRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CheckTrialEarlyStoppingStateRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CheckTrialEarlyStoppingStateRequest"
            .into()
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CheckTrialEarlyStoppingStateResponse {
    #[prost(bool, tag = "1")]
    pub should_stop: bool,
}
impl ::prost::Name for CheckTrialEarlyStoppingStateResponse {
    const NAME: &'static str = "CheckTrialEarlyStoppingStateResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CheckTrialEarlyStoppingStateResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CheckTrialEarlyStoppingStateResponse"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckTrialEarlyStoppingStateMetatdata {
    #[prost(message, optional, tag = "1")]
    pub generic_metadata: ::core::option::Option<GenericOperationMetadata>,
    #[prost(string, tag = "2")]
    pub study: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub trial: ::prost::alloc::string::String,
}
impl ::prost::Name for CheckTrialEarlyStoppingStateMetatdata {
    const NAME: &'static str = "CheckTrialEarlyStoppingStateMetatdata";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.CheckTrialEarlyStoppingStateMetatdata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.CheckTrialEarlyStoppingStateMetatdata"
            .into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopTrialRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for StopTrialRequest {
    const NAME: &'static str = "StopTrialRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.StopTrialRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.StopTrialRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListOptimalTrialsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
}
impl ::prost::Name for ListOptimalTrialsRequest {
    const NAME: &'static str = "ListOptimalTrialsRequest";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListOptimalTrialsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListOptimalTrialsRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListOptimalTrialsResponse {
    #[prost(message, repeated, tag = "1")]
    pub optimal_trials: ::prost::alloc::vec::Vec<Trial>,
}
impl ::prost::Name for ListOptimalTrialsResponse {
    const NAME: &'static str = "ListOptimalTrialsResponse";
    const PACKAGE: &'static str = "google.cloud.aiplatform.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "google.cloud.aiplatform.v1.ListOptimalTrialsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "type.googleapis.com/google.cloud.aiplatform.v1.ListOptimalTrialsResponse".into()
    }
}
